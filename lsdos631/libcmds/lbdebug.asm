; LBDEBUG/ASM - Debug / Verify commands	TITLE	<DEBUG/VERIFY - LSDOS 6.3>;CR	EQU	13;*GET	SVCMAC			; System SVC macros*GET	SYSRES/EQU		; SYS0 equates;	ORG	2400H;	JP	VERIFY;;	DEBUG entry;DEBUG	LD	DE,PRM1TBL	; Pt to y/n on/off parms	@@PARAM			; Get parameters	JP	NZ,IOERR	; Jump on param error	CALL	NPARM		; Check on yes or no entry				; And get flags ptr to IY	JR	Z,DBG2		; Go if no (OFF)	LD	A,(EPARM)	; Chk for extended debug	OR	A	JR	Z,DBG0	BIT	0,(IY+'C'-'A')	; Can't put extended debug	JP	NZ,CANT		; if himem not available	CALL	DBG3		; Call if EXT enteredDBG0	SET	7,(IY+'S'-'A')	; Turn on DEBUG flag	LD	D,8		; Set to mask bit 3	CALL	GET$DODBG0A	XOR	A		; & enable DEBUGDBG1	LD	(@DBGHK),AEXIT	LD	HL,0		; Set no error	RET;DBG2	RES	7,(IY+'S'-'A')	; Turn off DEBUG flag	LD	D,80H		; Set to mask bit 7	CALL	GET$DODBG2A	LD	A,(EPARM)	; Check on extended DEBUG	OR	A		;   requested	JR	Z,DBG4		; Go if not;;	User requested we remove extended debug;	BIT	0,(IY+'C'-'A')	; Can we alter HIGH$?	JR	NZ,DBG4		; Go if not	LD	DE,(EXTDBG$)	; Is extended resident?	LD	HL,-ORARET@	; Check if vector same as	ADC	HL,DE		;  the default	JR	Z,DBG4		; Go if not resident	LD	HL,0		; Set to get high$	LD	B,L	@@HIGH$			; Get current pointer	INC	HL		; Point to assumed module	XOR	A		;   & check if extended	SBC	HL,DE		;   debugger is lowest	JR	NZ,DBG4		; Can't release if not	INC	DE		; Point to lsat byte used	INC	DE	EX	DE,HL		; This will be new HIGH$	LD	E,(HL)	INC	HL	LD	D,(HL)	EX	DE,HL		; New high to HL	@@HIGH$			; Reset HIGH$	LD	HL,ORARET@	; Reset extended debugger	LD	(EXTDBG$),HL	;   vector to defaultDBG4	LD	A,0C9H		; Turn off DEBUG vector	JR	DBG1;EPARM	DW	0DBG3	LD	A,9BH		; Get SYS9 loaded & up	RST	28H;;	Verify entry point;VERIFY	LD	DE,PRM2TBL	; Pt to ext + above	@@PARAM	JR	NZ,IOERR	; Quit on param error	CALL	NPARM		; Check yes/no	LD	HL,@WRITE	; Init to vector @WRITE	RES	2,(IY+'D'-'A')	; Indicate verify off	JR	Z,VER1		; Use WRITE if VER=OFF	LD	HL,@VER	SET	2,(IY+'D'-'A')	; Indicate verify onVER1	LD	(75*2+SVCTAB$),HL	; Change SVCTAB vector	JR	EXIT;;	Routine to save or restore SPACE COMPRESSION state;GET$DO	PUSH	DE		; Save mask value	LD	DE,$DO$		; Get *DO driver	@@GTMOD	LD	HL,4		; Point to 1st data byte	ADD	HL,DE	POP	DE		; Recover mask value	RET	NZ		; Return if not found	LD	A,(HL)		; Get existing state	AND	D		; Strip state of space comp	RLCA			;   & move to bit 7 or 3	RLCA	RLCA	RLCA	LD	E,A		; Save temporarily	LD	A,(HL)	AND	77H		; Strip bits 3 and 7	OR	E		; Merge compr state	LD	(HL),A		; Save it back	RET;$DO$	DB	'$DO',3		; Module name to find;;	Parameter parsing of yes/no;NPARM	LD	BC,0	@@FLAGS			; Point IY to flags	LD	A,B	OR	C		; If no, make Z	XOR	0FFH	RETYPARM	DW	0;;	Do I/O error processing;IOERR	LD	L,A		; Set HL to error code	LD	H,0	OR	0C0H		; Short error messages	LD	C,A		; Transfer err code to C	@@ERROR	RET;;	Error exits;CANT	LD	HL,CANT$	@@LOGOT	LD	HL,-1	RET;CANT$	DB	'No memory space available',CR;;	LDOS 5.x style param table;PRM1TBL	DB	'EXT   '	DW	EPARM	DB	'E     '	DW	EPARMPRM2TBL	DB	'ON    '	DW	YPARM	DB	'OFF   '	DW	NPARM+1	DB	'Y     '	DW	YPARM	DB	'N     '	DW	NPARM+1	DB	00H;	END	DEBUG