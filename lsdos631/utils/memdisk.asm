; ***************************************************************; * Filename: MEMDISK/ASM					*; * Revision: 06.03.01						*; * Rev Date: 18 Dec 97						*; ***************************************************************; * Memory Disk driver for LS-DOS				*; *								*; ***************************************************************;	TITLE	<MEMDISK/DCT - LS-DOS 6.3>;*GET	SVCMAC			; System SVC Macros*GET	VALUES			; Misc. Equates*GET	COPYCOM			; Copyright message;SDBPC	EQU	0A00H		; Single density bytes/cylDDBPC	EQU	1200H		; Double density bytes/cylLOWEST	EQU	8000H		; Lowest addr for bank 0HIDRVR	EQU	1300H		; Highest addr for driverBUFFER$	EQU	2300H		; Temporary I/O buffer addrMINCYL	EQU	3WP	EQU	15		; Write prot disk error #;;	ORG	3000H;START	LD	(EXIT+1),SP	; Save SP location	@@CKBRKC		; Check for <BREAK>	JR	NZ,ABORT+3	; Quit if break detected;;	Install or disable MemDISK;	CALL	CALCDRV		; Calculate drive #	CALL	DOMEM		; Get type of MemDISK	CALL	INSTMEM		; Install MemDISK;;	Exit - clean stack, set HL, revector <BREAK>;NORMEX	LD	HL,0		; Normal exit, HL=0	JR	EXIT		; Get SP and return;ABORT	CALL	GETDUP		; Get duplicate DCT	LD	HL,-1		; Abort;EXIT	LD	SP,0		; Get SP address	@@CKBRKC		; Clear BREAK	RET			; Return to user;;	=================================;	Miscellaneous MemDISK subroutines;	=================================;;	SETBANK - Tell system which banks are used;SETBANK	LD	A,00H		; Get bank number	LD	C,A		; Store in C	CP	03H		; Both banks 1 and 2?	JR	NZ,STBANK	; No, just one bank	DEC	C		; Set C = 2	CALL	STBANK		; Show bank in use	DEC	C		; Set C = 1STBANK	PUSH	BC		; Save BC	LD	B,03H		; Show in use function #	@@BANK			; Let system know it	POP	BC	RET;;	FREBANK - Free up bank C;FREBANK	PUSH	BC		; Save B and C	LD	B,01H		; Show bank available	@@BANK			; Let system know	POP	BC		; Recover C	RET;;	DECASC2 - Display number to video;DECASC2	CALL	SAVEREG		; Save registers	PUSH	AF		; Save #	LD	C,BS		; Backspace twice	CALL	DSP	CALL	DSP	POP	AF		; Recover A	CALL	DECASC		; Convert to ASCII	LD	C,H		; Get m/s digit	CALL	DSP		; Display it	LD	C,L		; Get l/s and fall through;;	DSP - Output byte to video and exit if I/O error;DSP	@@DSP			; Output byte	RET	Z		; Return if no error;;;	LD	L,A		; Error code to HL	LD	H,00H	JP	EXIT		; Go to exit routine;;	DECASC - Display Decimal ASCII equivalent;DECASC	LD	H,2FH		; H=MSB of BCD ASCIILPADD	INC	H		; Bump MSB	SUB	10		; Successive subs of 10	JR	NC,LPADD	; Keep going until carry	ADD	A,3AH		; A = LSB in ASCII	LD	L,A		; HL = DEC ASCII	RET;;	DECHEX - Convert Decimal ASCII to HEX;DECHEX	CALL	GETDIG		; Get digit	INC	HL		; Next byte in buffer	DEC	B		; Dec digit counter	JR	Z,DONE1		; All done when 0	LD	D,A		; Transfer to D	CALL	GETDIG		; Get digit	LD	E,A		; Save digit in E	LD	A,D		; Get ten's digit	ADD	A,A		; A = A * 2	ADD	A,A		; A = A * 4	ADD	A,D		; A = A * 5	ADD	A,A		; A = A * 10	ADD	A,E		; Add in the onesDONE1	CP	A		; Set Z flag	RET;;	GETDIG - Get a digit from (HL) buffer;GETDIG	LD	A,(HL)		; Get character to A	SUB	'0'		; Convert to binary	JR	C,ILLEGAL	; Go on error	CP	0AH		; Legal digit	RET	C		; Yes - A = digitILLEGAL	INC	A		; Reset Z flag	POP	HL		; Clear stack	RET			;   and return;;	Verify error - Get Bank/Address and display it;ERROR	PUSH	HL		; L=LSB of address	LD	A,0C9H		; Modify GETADR routine	LD	(STFRET),A	CALL	GETADR		; HL <= page from DE	POP	DE		; E=LSB of address	LD	L,E		; HL = bad RAM address;;	Stuff Bank # and address into string;	LD	A,'0'		; Convert bank to ASCII	ADD	A,C	LD	(VBANK),A	; Put ASCII bank in string	EX	DE,HL		; Move address into DE	LD	HL,VLOC		; HL => string destination	@@HEX16			; Convert DE to hex ASCII @ HL;;	Display string and restore hi/low memory;	LD	HL,BADRAM	; "Bad ram...	@@LOGOT			; display it	JP	OLDRVR		; Leave and clear stack;;	SAVEREG - Save all primary registers;SAVEREG	EX	(SP),HL		; Get return address	LD	(RETADDR+1),HL	; Save it for JP	POP	HL		; Get HL back	PUSH	HL	LD	(SAVEDE),DE	; Save DE in memory	PUSH	DE		; Save everything on	PUSH	BC		;   the stack	PUSH	AF	LD	DE,RESTREG	; Reg restore addr	PUSH	DE		; Push for return later	LD	DE,(SAVEDE)	; Get DE backRETADDR	JP	$-$;;	RESTREG - Restore all primary registers;RESTREG	POP	AF		; Restore all the registers	POP	BC	POP	DE	POP	HL	RET;;	CKBANK - Check if bank C is in use;CKBANK	PUSH	BC		; Save BC	LD	B,02H		; Bank in use?	@@BANK			; Check it out	POP	BC		; Recover BC	RET	Z		; Return if available	JP	BNKUSE		;   else "Bank in use...;;	INPUT - Input a line to the input buffer;INPUT	LD	HL,BUFFER	; HL => input buffer	@@KEYIN			; Get user input	JP	C,ABORT		; Exit if <BREAK> hit	INC	B		; Set Z if no chars entered	DEC	B	RET			; Return to caller;;	GETCYL - Get max # cylinders in A;GETCYL	PUSH	DE		; Save registers	PUSH	HL;;	Init DE = # bytes/cyl, A = dividend (-1);BPC	LD	DE,DDBPC	; Get bytes/cyl	LD	A,-1		; Init avail cyls to -1;;	Divide total bytes availabye by bytes/cylinder;DIVLP	INC	A		; Bymp cylinder count	OR	A	SBC	HL,DE		; Take off one cylinder	JR	NC,DIVLP	; Loop until carry;;	A = # of cyls available - Restore registers;	POP	HL	POP	DE;;	Set Z flag if more than one cylidner available;	CP	02H		; 0 or 1?	RET	C		; Yes - return NZ	CP	A		; Set Z flag	RET			;   and return;;	CALCDRV - Calculate drive number for MemDISK;;	DE => DCT block for drive;CALCDRV	EX	DE,HL		; Xfer DCT to HL	LD	(SAVEDCT),HL	; Save DCT pointer	CALL	SAVDCT		; Save the DCT	LD	A,H		; Drive number issued?	OR	L	JP	Z,NODRV		; No drive entered!;;	Get start of Drive Code Table;	LD	C,00H		; Get start of DCT	@@GTDCT	PUSH	IY		; Move DCT start to DE	POP	DE;;	Calculate offset in table;	XOR	A	SBC	HL,DE		; L = offset from start	OR	L		; Get offset	JP	Z,BADDRV	; Cannot use drive 0!!;;	Divide offset by 10 to get drive #;	LD	B,-1		; Init dividend to -1DIVLP1	INC	B		; Bump dividend	SUB	10		; Subtract ten	JR	NC,DIVLP1	; Keep doing so til carry;;	Stuff drive number into WRSEC routine;	LD	A,B		; Get drive in A	LD	(DRIVE+1),A	; Stuff into code;;	Point IY to System flag table and return;	@@FLAGS	RET;;	SAVDCT - Save old DCT setup;SAVDCT	CALL	SAVEREG		; Save registers	LD	DE,DUPDCT	; DestinationDOXFER1	LD	BC,10		; 10 bytes to transfer	LDIR	RET;;	GETDUP - Get duplicate of original DCT setup;GETDUP	LD	DE,(SAVEDCT)	; DE => DCT+0	LD	HL,DUPDCT	; Where we saved it	JR	DOXFER1		; Transfer back;;	GTDRV - Get next available driver address;;	IX <= Driver address pointer;	DE <= Current address;GTDRV	PUSH	HL		; Save HL	LD	DE,'IK'		; Get *KI DCB address	@@GTDCB	DEC	HL		; KIDCB-2 => Free area	PUSH	HL		; Transfer to IX	POP	IX	LD	D,(HL)		; Get address to DE	DEC	HL	LD	(KIDCB$+1),HL	; Save address to stuff	LD	E,(HL)	POP	HL		; Recover HL	RET;;	INSTDRV - Relocate and install disk driver;INSTDRV	EX	DE,HL		; Transfer dest to HL	LD	DE,DRIVER	; Start of driver	PUSH	HL		; Save source and dest pointers	PUSH	DE	OR	A		; Clear carry	SBC	HL,DE		; Calculate offset to relocate;;	Relocate internal references in the driver;	LD	IX,RELTBL	; Point to relocation table	LD	B,H		; Move to BC	LD	C,LRLOOP	LD	L,(IX+00H)	; Get address to change	LD	H,(IX+01H)	LD	A,H		; Is entry 0?	OR	L	JR	Z,RELDUN	; Done if so	LD	E,(HL)		; Get address to relocate	INC	HL		;   into DE	LD	D,(HL)	EX	DE,HL		; Swap for addition	ADD	HL,BC		; Offset address	EX	DE,HL		; Swap it back	LD	(HL),D		; Put new address back	DEC	HL	LD	(HL),E	INC	IX		; Bump relocation table	INC	IX		;   pointer	JR	RLOOP		; Loop until done;;;RELTBL	DW	REL1+1,REL2+1,REL3+1,REL4+1	DW	REL5+1,REL6+2,REL7+1,REL8+1	DW	REL8A+1,REL8B+1,REL9+1,REL2A+1	DW	0;;	Transfer MemDISK driver into the driver area;RELDUN	POP	HL		; HL => Source	POP	DE		; DE => Destination	PUSH	DE		; Save start	LD	BC,LENGTH	; Length of the driver	LDIR			; Move into position	POP	DE		; Get start back	RET			;   and return;;	SETDCT - Set up drive code table for MemDISK;SETDCT	LD	IX,(SAVEDCT)	; Get DCT address into IX	LD	(IX+00H),0C3H	; Enable	LD	(IX+01H),E	; LSB of driver	LD	(IX+02H),D	; MSB of driverSDEND	LD	(IX+03H),40H	; DD, 5", floppy, step=6SDENE	LD	(IX+04H),50H	; DDC=Y, 1 side, Alien	LD	(IX+05H),00H	; Current cyl = 0	LD	(IX+06H),A	; # tracks rel from 0SDENF	LD	(IX+07H),17	; 18 SPT (DD), 10 if SDSDENG	LD	(IX+08H),45H	; 2/3 Grn/Cyl, 5/6 Sec/Grn	LD	(IX+09H),01H	; Directory cylinder = 1	RET;;;	====================================;	====	MemDISK Driver Code	====;	====================================;DRIVER	JR	INIT		; Jump around headerOLDHIGH	DW	0		; Old HIDRV$	DB	03H,'$MD'	; HeaderOLD_HI	DW	0		; Old high$ for bank 0BANKIM	DB	00000000B	; Bank imageDRVLOW	DW	0		; What driver addr wasMEMHIGH	DW	0		; HIGH$ after installed;	IF	@MOD2	DC	32,0		; Model 2 stack area;	ELSE	DC	16,0		; Driver stack area	ENDIFMYSTACK	EQU	$;;	Reset SP to MYSTACK and CALL driver;INIT	PUSH	HL		; Save registers	PUSH	DE	PUSH	BCREL6	LD	(SAVESP+1),SP	; Save original SP	DI			; Disable interruptsREL7	LD	SP,MYSTACK	; Set MemDISK stackREL9	LD	(BUFF+1),HL	; Save buffer addr requestREL8	CALL	MEMDRIV		; Call the actual driverSAVESP	LD	SP,$-$		; Get original SP	EI			; Interrupts back on	POP	BC		; Restore registers	POP	DE	POP	HL	RET;MEMDRIV	LD	A,B		; Get operation byte;B9	CP	09H		; Operation #9?	JR	NZ,B10		; No, check for verify;;	READ sector - Set Z if D = directory cyl;	DEC	D		; Set Z if cylinder 1	PUSH	AF		; Save flag for later	INC	D		; Original cyl back;;	Set up for transfer to temporary I/O buffer;	PUSH	HL		; Save user I/O buffer ptrREL1	CALL	GETADR		; HL => MemDISK sector	JR	C,DOXFER	; High - use temporary buf;;	I/O buff is low - xfer MemDISK sector to it;	LDIR			; Transfer directly to bufferREL2A	CALL	GETOLD		; Get original bank	POP	HL		; HL => User I/O buffer	JR	CHKDIR2		; Check if dir cylinder;;	Transfer MemDISK sector to temporary buffer;DOXFER	PUSH	DE		; DE => tmeporary buffer	LDIR			; Transfer to system area;;	Transfer data from temp buffer to user buffer;REL2	CALL	GETOLD		; Get original bank back	POP	HL		; HL => temporary buffer	POP	DE		; DE => User I/O buffer	LD	BC,256		; One sector worth to xfer	LDIR			; Do it;;	Set A = Error #6 if cylinder = 1 (directory);CHKDIR2	POP	AF		; Get Z/NZ statusCHKDIR	JR	NZ,NOTDIR	; Not a directory read	LD	A,06H		; Set error code 6	OR	A		; Set NZ status	RET;NOTDIR	XOR	A		; Set Z flag	RET;B10	CP	10		; Verify sector?	JR	NZ,B13		; Check more if not;;	Verify a sector;	DEC	D		; Directory cylinder?	JR	CHKDIR		; Check if directory cyl;B13	CP	13		; Write a sector?	JR	NZ,B14		; Check further if not;;	Write a sector;WRITES	LD	A,WP		; WP error x'0F'	BIT	7,(IY+03H)	; Software write protect?	RET	NZ		; Return with error if so;;	Set up for transfer to temporary buffer;	PUSH	DE		; Save cyl and sectorREL8A	CALL	GETBUF		; Get buffer pointer	JR	NC,RECVDE	; Get DE back if error	LD	BC,256		; One sector's worth	LDIRRECVDE	POP	DE		; DE = cyl/sector;;	Get sector from MemDISK & transfer to user buffer;REL3	CALL	GETADR		; HL <= mem, DE <= buffer	EX	DE,HL	LDIR			; Transfer to user bufferREL4	CALL	GETOLD		; Get original back	XOR	A		; Set Z flag	RET;B14	CP	0EH		; Write system sector?	JR	Z,WRITES	; Go if so;	CP	0CH		; Format command?	JR	Z,B14A		; Go if so	CP	0FH		; Write track?	JR	NZ,EX1		; No - exit ZB14A	LD	A,08H		; Yes - exit NZ	OR	A		; Error - device not avail	RET;EX1	XOR	A		; Zero A, Set Z	RET;;	GETADR - Point HL to MemDISK area;		 Point DE to temporary buffer;		 Set BC = 256 (sector size);GETADR	LD	A,D		; Get cylinder #;;	Multiply cylinder # by 10 or 18 (sec/cyl);SDENA	ADD	A,A		; X 2 or NOP if SDEN	LD	D,A		; DDEN * 2	SDEN * 1	ADD	A,A		; DDEN * 4	SDEN * 2	ADD	A,A		; DDEN * 8	SDEN * 4SDENB	ADD	A,A		; DDEN * 16	SDEN * 5SDENC	ADD	A,D		; DDEN * 18	SDEN * 10;;	Add sector offset (E) and add 80H if bank 2 active;	ADD	A,E		; Add sector offsetOFFSET	ADD	A,00H		; 80H if 2 active;;	HL => Sector, C = default bank (0 or 1);	LD	H,A		; Stuff MSB in H	LD	L,00H		; Land on page boundaryDEFBANK	LD	C,00H		; C = 0 or C = 1;;	Set C = Bank #2 if Address > x'7FFF';	RLCA			; Address > x'7FFF'?	JR	NC,GOTBANK	; No, Got it	INC	C		; Yes, set C = 2;;	Force address > x'7FFF' and select bank C;GOTBANK	SET	7,H		; Force it above x'7FFFSTFRET	LD	B,L		; Bring in bank C	@@BANK;;	Pick up bank previously in use and save it;	LD	A,C		; Get last bank in use	AND	7FH		; Ignore high bitREL5	LD	(GETOLD+1),A	; Save for restoration;;	Set DE => Overlay buffer, BC = 256;REL8B	CALL	GETBUF		; Get buffer pointer	LD	BC,256		; Set BC = sector size	RET;;	GETOLD - Get original bank used;GETOLD	LD	BC,0		; B=0, C=Bank #	@@BANK			; Get old bank back	RET;;	GETBUF - Get buffer to LDIR from or to;GETBUF	PUSH	HL		; Save source/dest pointerBUFF	LD	DE,0		; Get requested I/O buffer	LD	HL,7F00H	; Use (BUFF+1) if < 7F00H	OR	A	SBC	HL,DE		; Past 7F00H?	POP	HL		; Recover pointer	RET	NC		; No - use requested buffer	LD	DE,BUFFER$	; Yes - use buffer$	RET;LENGTH	EQU	$-DRIVER	; Length of MemDISK driver;;	====================================;		MemDISK Initialization;	====================================;INSTMEM	PUSH	AF		; Save # cylinders	PUSH	BC		; Save bank number;;	Is there a MemDISK driver trapped?;	LD	DE,MD$		; "$MD"	@@GTMOD			; Look for it	JR	NZ,NOT__IN	; No, jump;;	There is a driver trapped - use that area;	LD	(OLDRVR+1),HL	; Save old driver addr	EX	DE,HL		; Point DE to destination	LD	HL,RE_USE	; Set re-use flag	INC	(HL)	LD	HL,LENGTH-1	; Set HL = last used	ADD	HL,DE		;   address of driver	LD	(OLDHIGH),HL	; Xfer into driver	JR	DO_INST		; Install the driver;;	Driver not in memory - is there room for it?;NOT__IN	CALL	GTDRV		; Get low driver pointer	LD	(OLDRVR+1),DE	; Save it	LD	HL,LENGTH-1	; HL = length of driver	LD	BC,HIDRVR	; BC = 1 + highest avail	ADD	HL,DE		; HL = last used by MemDISK	LD	(OLDHIGH),HL	INC	HL	OR	A	PUSH	HL		; Will MemDISK fit?	SBC	HL,BC	POP	HL	JR	C,OKTOGO	; Yes, let's do it;;	Insufficient driver space;	LD	HL,NOMEM	; Alter exit message	LD	($NOT+1),HL	JR	OLDRVR		; Reclaim hi mem if bank 0;;	Save next avail mem addr & set MemDISK bit;OKTOGO	LD	(IX+00H),H	; Stuff MSB	LD	(IX+0FFH),L	; Stuff LSB;;	Install MemDISK driver and set up the DCT;DO_INST	CALL	INSTDRV		; Relocate and install driver	POP	BC		; C = bank # requests	POP	AF		; A = # cylinders	CALL	SETDCT		; Set up the DCT;;	Prompt for format;	CALL	FORMTIT		; Format this?	JR	Z,DOFORM1	; Yes - go do it;;	Format = no, is there a MemDISK there?;MEMIN1	LD	A,00H		; 0 = not active	OR	A	JR	NZ,SHOWINU	; MemDISK previously in;;	Abort installation - stuff x'C9' in DCT;OLDRVR	LD	HL,0		; Get original driver address	LD	A,(RE_USE)	; Have we re-used driver area	OR	A		;   that was trapped?	JR	NZ,DONTRES	; Yes - don't reset memptrKIDCB$	LD	(0),HL		; Stuff pointer usedDONTRES	LD	HL,(SAVEDCT)	; Get DCT address	LD	(HL),0C9H	; Disable that DCT	RES	4,(IY+DFLAG$)	; Reset MemDISK bit	LD	A,(SETBANK+1)	; Get bank request	OR	A		; If alternate bank(s),	JR	NZ,$NOT		;   don't reset HIGH$	LD	HL,(MDDATA+2)	; Get old HIGH$	LD	B,A	@@HIGH$			; Reset high memory$NOT	JP	NOTACT		; Show not installed;;	Format memory, init GAT , HIT and BOOT/DIR entries;DOFORM1	CALL	FORMAT		; Do the "disk" format	CALL	WRBOOT		; Write BOOT/SYS	CALL	WRGAT		; Initialize the GAT	CALL	WRHIT		; Initialize the HIT	CALL	WRENT		; Write BOOT & DIR entriesSHOWINU	CALL	SETBANK		; Show banks in use	SET	4,(IY+DFLAG$)	; Set MemDISK flag	LD	HL,INSTALD	; Init "Memdisk inst....	@@LOGOT			; Display the message	RET			; Done - go to EXIT;;	WRBOOT - Write BOOT/SYS information;WRBOOT	XOR	A		; Fill byte	LD	HL,IOBUFF	; HL => I/O buffer;;	Fill BOOT/SYS with zeroes;FILBUF	LD	(HL),A		; Stuff in byte	INC	L		; One sector to fill	JR	NZ,FILBUF	; Loop til done;;	Write # of sectors in BOOT;	LD	D,A		; Cylinder 0	LD	E,A		; Sector 0BTSECS	LD	B,06H		; Get sector count - 5 or 6BTLP	CALL	WRSEC		; Write sector	INC	E		; Bump sector #	DJNZ	BTLP		; Loop;;	Write directory cylinder byte in sector zero;	LD	L,02H		; Byte 2	LD	(HL),01H	; Dir cylinder = 1	LD	DE,0		; Cyl 0, Sector 0	CALL	WRSEC;;	Make a duplicate of sector 0 in sector 1;	INC	E		; Cyl 0, Sector 1	CALL	WRSEC;;	Write C/R in AUTO buffer in sector 2;	LD	E,02H		; Sector 2	LD	L,20H		; Byte x'20'	LD	(HL),0DH	; No auto	CALL	WRSEC		; Write sector	RET;;	WRGAT - Write Granule Allocation Table;WRGAT	LD	HL,IOBUFF	; HL => I/O BufferGAT0	LD	(HL),0F9H	; DD=x'F9, SD=x'FD'	INC	HL		; Bump;;	Lock out next x'CA' bytes in GAT;	LD	B,0CAH		; Lock out countLOCKOUT	LD	(HL),0FFH	; Lock out GAT+01 through	INC	HL		;  GAT+CA	DJNZ	LOCKOUT;;	GAT + x'CB' - DOS version formatted with;	LD	(HL),63H	; Version 6.3 disk;;	GAT + x'CC' - Excess cylinder count;CYLS	LD	A,00H		; Get cylinder count	PUSH	AF		; Save it	SUB	35		; Tracks in excess of 35	INC	HL		; HL => position	LD	(HL),A		; Set tracks - 35;;	GAT + x'CD';	INC	HLGATCD	LD	(HL),4AH	; DDEN, 1 side, 3 gran/cyl;;	GAT + x'CE' and x'CF';	INC	HL	LD	(HL),0E0H	; 16 bit hash code of	INC	HL		;   "PASSWORD"	LD	(HL),42H;;	GAT + x'D0' - x'D7';	INC	HL	LD	DE,MEMDISK	; "MEMDISK" is pack name	LD	C,08H		; Eight bytes	EX	DE,HL		; Swap for LDIR	LDIR			; Move pack name in	EX	DE,HL		; HL => DATE field;;	GAT + x'D8' - x'DF';	@@DATE			; Stuff date in GAT;;	Stuff GAT tracks in use with either X'F8' or X'FC';GPC	LD	A,0F8H		; 3 gran/cyl	LD	HL,IOBUFF+2	; HL => GAT+2	POP	BC		; B = # cylinders	DEC	B		; Subtract 2 for 	DEC	B		;   BOOT and DIR;;	Stuff open cylinder bytes into the GAT;FREETRK	LD	(HL),A		; Free track	INC	HL		; Next GAT byte	DJNZ	FREETRK		; Do it B times;;	Put free cyl bytes to lockout - BOOT & DIR;	LD	L,60H		; HL => Lockout table	LD	(HL),A	INC	L	LD	(HL),A;;	GAT + X'62' - X'BF';	LD	L,02H		; HL => GAT+2	LD	D,H		; Transfer to DE	LD	E,L	LD	C,60H		; of x'60 for the	ADD	HL,BC		;   duplicate of top	DEC	C		; Only duplicate x'5E'	DEC	C		;   bytes	EX	DE,HL		; Prepare for LDIR	LDIR			; HL=>GAT, DE=>Lockout	LD	DE,IOBUFF+0F5H	; Ver 6.3 media data block	LD	HL,LSIID	; Point to header	LD	BC,4		; Set length	LDIR			; Move the header	LD	HL,(SAVEDCT)	; The data to move	INC	HL		;   is at DCT+3	INC	HL	INC	HL	LD	C,07H		; 7 bytes to move	LDIR	JR	WRGAT1		; Branch around string;;	Version 6.3 media data block header;LSIID	DB	03H,'631';WRGAT1	LD	DE,100H		; Cylinder 1, Sector 0;;	WRSEC - Write a sector to MemDISK drive;WRSEC	LD	HL,IOBUFF	; I/O BufferDRIVE	LD	C,00H		; Get drive #	@@WRSEC			; Use driver to write sector	RET;;	RDSEC - Read a sector of MemDISK drive;RDSEC	LD	HL,IOBUFF	;HL => I/O buffer	LD	A,(DRIVE+1)	; Get drive number	LD	C,A		; Store in C	@@RDSEC			; Read sector	RET;;	WRHIT - Write HIT sector in directory;WRHIT	XOR	A		; Set A = 0ZEROHIT	LD	(HL),A		; Zero HIT position	INC	L		; Bump sector pointer	JR	NZ,ZEROHIT	; Loop until filled	LD	(HL),0A2H	; Hash for BOOT/SYS	INC	L	LD	(HL),0C4H	; Hash for DIR/SYS	INC	E		; Cyl = 1, Sector = 1	JR	WRSEC		; Write sector and return;;	WRENT = Write DIR/SYS and BOOT/SYS entries;WRENT	LD	DE,BOOT		; BOOT/SYS byte field	EX	DE,HL		; Swap for LDIR	LD	BC,32		; 32 bytes in entry	LDIR			; Move into position	LD	DE,0102H	; Cyl 1, Sector 2	CALL	WRSEC		; Write sector;	LD	BC,32		; Now do DIR/SYS	EX	DE,HL		; Xfer buffer ptr to DE	LD	HL,DIR		; HL => DIR/SYS entry	LDIR			; Transfer to MemDISK	LD	DE,0103H	; Cyl 1, Sector 3	JR	WRSEC		; Write sector and return;;	BOOT/SYS directory entry data;BOOT	DB	01011110B	; No access,inv,sys,FPDE	DW	0		; Date = 00/00/00	DW	0		; EOF offset = 0, LRL=256	DB	'BOOT    '	; Name field	DB	'SYS'		; Extension	DW	71F4H		; Owner password hash	DW	0		; No extra date fieldBOOTERN	DW	6		; ERN = 6 or 5	DB	0		; First extent = cyl 0	DB	0		; Start gran = 0, 1 gran	DW	0FFFFH		; No more extents	DW	0FFFFH	DW	0FFFFH	DB	0FFH		; No further records	DB	0FFH;;	DIR/SYS directory entry data;DIR	DB	01011101B	; Read only,inv,sys,FPDE	DW	0		; Date = 00/00/00	DW	0		; EOF Offset = 0, LRL=256	DB	'DIR     '	; Name field	DB	'SYS'		; Extension	DW	71F4H		; Owner password hash	DW	4296H		; User password hashDIRERN	DW	18		; ERN+1 = 10 or 18	DB	1		; Starts on cylinder 1SDENI	DB	00000010B	; Start gran=0, 3 grans	DW	0FFFFH		; No more extents	DW	0FFFFH	DW	0FFFFH	DB	0FFH		; No further records	DB	0FFH;;	DOMEM - Issue prompts and take inputs for type;DOMEM	LD	HL,HELLO$	; Display copyright msg	@@DSPLY;;	Check if entry from SYSTEM (DRIVER= command;	@@FLAGS			; Get system flag table	BIT	3,(IY+'C'-'A')	; System request?	JP	Z,VIASET	; Quit if not;;	Input MemDISK type - A, B, C, D or E to disable;GETTYPE	LD	HL,BANKS	; Display prompt	@@DSPLY	LD	B,01H		; # chars to get	CALL	INPUT		; Get user input	JR	Z,GETTYPE	; <ENTER>? - reinput;;	Convert A-E to 0-4;	LD	A,(HL)		; Get input character	RES	5,A		; Force upper case	SUB	'A'		; Convert to 0-4	LD	(SETBANK+1),A	; Save type of MemDISK	LD	C,A		; Transfer to C for @BANK;;	If input is illegal then re-input;	JR	C,GETTYPE	; Less - reinput	CP	04H		; <E> = disable MemDISK	JP	Z,DISMEM	; Yes - take it out	JR	NC,GETTYPE	; If > 4 then reinput;;	Check if MemDISK is already active;	BIT	4,(IY+DFLAG$)	; MemDISK already active?	JP	NZ,MEMIN	; Yes - abort;;	If type = A, B or C - Check Bank, D - Check banks 1 & 2;	PUSH	BC		; Save bank #	CP	03H		; Type "D"?	JR	NZ,A_B_C	; No - A, B or C;;	Type "D" - See if both banks 1 and 2 are available;	LD	C,01H		; Bank 1?	CALL	CKBANK		; Find out...	INC	C		; Bank 2?A_B_C	CALL	CKBANK		; Check if bank active	POP	BC		; C = bank # (0-3);;	Stuff default bank # and offset into driver;	LD	A,C		; Get bank #	DEC	A		; If bank 0 requested	JP	M,WAS0		;   then keep as -1	INC	A		;   for driver bank test	LD	(BANKIM),A	; Save bank in driver	CP	02H		;   instruction if	JR	NZ,NOT2		; Just bank 2 active	LD	HL,OFFSET+1	; Stuff X'80' in ADD	LD	(HL),80HNOT2	LD	A,01H		; Always init to bank 1WAS0	LD	(DEFBANK+1),A	;   if type B, C or D;;	Input Density (Single or Double);INPDENS	LD	HL,DENSITY	; "Density..."	@@DSPLY	LD	B,01H		; 1 char entry	CALL	INPUT		; Get it	JR	Z,DEFAULT	; Use default if <ENTER>;;	<D>ouble density requested by user?;	LD	A,(HL)		; Get character entered	RES	5,A		; Force to upper case	CP	'D'		; DDen?	JR	Z,DEFAULT	; Yes - use 6 sectors/gran;;	<S>ingle density?;	CP	'S'		; If it's not <S>	JR	NZ,INPDENS	;   then ask again;;	Single density selected - change driver math;	LD	A,82H		; ADD A,D instruction	LD	(SDENB),A	LD	A,87H		; ADD A,A instruction	LD	(SDENC),A	LD	A,09H	LD	(SDENF+3),A	; DCT+7	LD	(SPC+1),A	; Save in CALCSIZ routine	INC	A		; SDEN BOOT ERN = 10	LD	(DIRERN),A	; SDEN DIR/SYS ERN = 10	LD	A,24H	LD	(SDENG+3),A	; DCT+8	LD	A,'2'		; Change size to 2.5k	LD	(FRTRK1),A	; Space per cylinder	LD	A,0FDH		; 1 gran free	LD	(GAT0+1),A	; Stuff in WRGAT routine	DEC	A		; 2 grans/cyl - X'FC'	LD	(GPC+1),A	XOR	A		; NOP instruction	LD	(SDENA),A	LD	(SDEND+3),A	; DCT+3	INC	A		; Set A = 1	LD	(SDENI),A	; 2 contiguous grans	LD	A,09H	LD	(GATCD+1),A	; Stuff in WRGAT routine	LD	A,05H		; Set BOOT ERN=5	LD	(BOOTERN),A	LD	A,10H		; Alien disk controller	LD	(SDENE+3),A	LD	HL,BTSECS+1	; HL => #BOOT sectors	DEC	(HL)		; Use 5 instead of 6	LD	HL,SDBPC	; Change GETCYL routine	LD	(BPC+1),HL;;	Calculate number of possible cylinders;DEFAULT	LD	A,(SETBANK+1)	; Get type of MemDISK	LD	C,A		; Save in C	OR	A		; Bank 0?	JR	Z,PIKUPHI	; Yes - use HIGH$;;	Bank 1, Bank 2 or both;	LD	HL,7FFFH	; HL = # bytes in one bank	CP	03H		; Bank 1 and 2?	JR	NZ,CALCYL	; No - use X'7FFF'	LD	H,L		; Set HL = X'FFFF'	JR	CALCYL;;	Bank Zero request - Calculate free memory available;PIKUPHI	XOR	A		; Set A = 0	SBC	HL,HL		; Set HL = 0	LD	B,A		; Set B = 0	@@HIGH$			; Get HIGH$	LD	(MDDATA+2),HL	; Save it	LD	(OLD_HI),HL	; Save it in driver, too	INC	HL		; HL => last page	DEC	H	LD	L,A	LD	(SAVPAGE+1),HL	; Save page boundary	LD	DE,LOWEST	; DE = lowest	XOR	A	SBC	HL,DE		; HL = amount free	JP	C,NOMEM		; Carry - not enough memory!;;	Calculate number of cylinders available;CALCYL	CALL	GETCYL		; Get # of possible cyls	JP	NZ,NOMEM	; NZ = not enough memory;;	Convert A to ASCII and stuff into string;	INC	A		; Bump one	LD	(MAXCYL+1),A	; Save max # of cylinders	DEC	A	LD	(CYLS+1),A	; Stuff in WRGAT routine	PUSH	AF		; Save max # cyls	CALL	DECASC		; Convert to ASCII in HL	POP	AF	EX	DE,HL		; DE = # in ascii	LD	HL,FRTRK2	; HL => position in message	LD	(HL),D		; Write MSB	INC	HL	LD	(HL),E		;   and LSB;;	A = # cyls possible - put in string if bank 0;	INC	C		; Bank zero request?	DEC	C	RET	NZ		; No - done prompting;;	Display cylinders string and input # of cylinders;REDO	LD	HL,FRTRACK	; How many cylinders?	@@DSPLY	LD	B,02H		; Input # of cyls	CALL	INPUT	JR	Z,REDO		; No default - redo it;;	Check if input was legal;	CALL	DECHEX		; Convert to hex	JR	NZ,REDO		; Illegal - re-input	CP	MINCYL		; Less than minimum?	JR	C,REDOMAXCYL	CP	00H		; Greater than max?	JR	NC,REDO		; Too many - reinput	LD	(CYLS+1),A	; New # of cylinders;;	CALCSIZ - Calculate size of cyl request;CALCSIZ	CALL	SAVEREG		; Save registers	LD	C,A		; Xfer cyls to CSPC	LD	B,17		; Get sectors/cyl;;	Multiply sects/cyl by number of cyls;MLOOP	ADD	A,C		; Multiply B * C	DJNZ	MLOOP;;	Set HL to new HIGH$;SAVPAGE	LD	HL,0		; Get page boundary	NEG			; Set H = H - A	ADD	A,H	LD	H,A		; HL = new HIGH$, B=0	LD	(OFFSET+1),A	; Stuff into driver;;	Stuff a memory header in front of MemDISK;	DEC	HL		; Point 1 byte before	EX	DE,HL		;   MemDISK himem area	LD	HL,MDDATA+16	; Point to header block	LD	BC,17	LDDR			;   and move to himem	EX	DE,HL	LD	(MEMHIGH),HL	@@HIGH$			; Set new HIGH$	RET			; Restore regs and return;;	DISMEM - Disable MemDISK if in memory;DISMEM	BIT	4,(IY+DFLAG$)	; Check if MemDISK active	JP	Z,NOTPRS	; Go if not present;;	Get driver address of drive;	LD	HL,(SAVEDCT)	; Get DCT address	PUSH	HL		; Save DCT pointer	INC	HL		; Get driver address	LD	E,(HL)	INC	HL	LD	D,(HL)	PUSH	DE		; Save driver address;;	Calculate end of driver and position to ID;	EX	DE,HL		; Point HL to driver	PUSH	HL		; Save start	LD	BC,LENGTH	; Add length of driver	ADD	HL,BC		;   to start of driver	LD	(DREND+1),HL	; Save next available	POP	HL		; HL => driver add start	INC	HL		; Position to length byte	INC	HL	INC	HL	INC	HL;;	Get name length and point to driver name;	LD	B,(HL)		; Get name length byte	INC	HL		; HL => Driver name	LD	DE,MD$		; DE => "MEMDISK";;	Is this REALLY a certified MemDISK??;MEMLP	LD	A,(DE)		; Get MemDISK byte	CP	(HL)		; Match with driver in memory?	INC	HL		; Bump the pointers	INC	DE	JP	NZ,NOTMEM	; No - it isn't a MemDISK	DJNZ	MEMLP		; Yes - check all chars;;	Get old HIGH$ address and stuff for later;	LD	E,(HL)		; Get old HIGH$ into DE	INC	HL	LD	D,(HL)	LD	(SAVEOLD+1),DE	; Into LD HL instruction;;	Get BANK information;	RES	4,(IY+03H)	; Reset MemDISK bit	INC	HL		; HL => Bank image	LD	A,(HL)		; Get bank image	LD	C,A		; Transfer to C	CP	03H		; Both banks 1 and 2?	JR	C,FRBANK	; No, free up one bank	DEC	C		; Set C = 2	CALL	FREBANK		; Free the bank	DEC	C		; Set C = 1FRBANK	CALL	FREBANK		; Free bank in C;;	Is this a bank zero MemDISK?;	LD	IY,TYPEDIS	; IY => Disable type	INC	C		; Is C = 0?	DEC	C	JR	NZ,GTDRV2	; No - check out driver;;	Bank 0 - Get last HIGH$ from driver storage;	DEC	(IY+00H)	; Change type	INC	HL		; Position to HIGH$ value	INC	HL		;   after MemDISK installation	INC	HL	LD	E,(HL)		; Get address into DE	INC	HL	LD	D,(HL);;	Get current HIGH$ and compare with saved value;	LD	H,B		; Set HL = 0	LD	L,B	@@HIGH$			; Get current HIGH$	OR	A	SBC	HL,DE		; Are they the same?	JR	NZ,GTDRV2	; NZ means we can't do it;;	Reset HIHH$ to the original HIGH$ value;SAVEOLD	LD	HL,0		; Get old HIGH$ here	@@HIGH$			; De-allocate the space	INC	(IY+00H)	; Change Type;;	Can the driver area be de-allocated?;GTDRV2	CALL	GTDRV		; Get driver areaDREND	LD	HL,0		; Get driver address	OR	A	SBC	HL,DE		; Are they the same?	POP	HL		; HL => driver address	JR	NZ,NORECLM	; No - can't reclaim it;;	Stuff original address into low driver pointer;	LD	(IX+00H),H	; MSB	LD	(IX+0FFH),L	; LSB	INC	(IY+00H)	; Change type	INC	(IY+00H);;	Clear out the driver;	LD	BC,LENGTH-1	; BC = # of bytes to clear	LD	(HL),00H	; Null byte	LD	D,H		; Set DE to HL+1	LD	E,L	INC	DE	LDIR			; Clear the driver area;;	Disable DCT slot;NORECLM	POP	HL		; HL => DCT+0	LD	(HL),0C9H	; Disable it;;	Calculate start of disable string;	PUSH	IY		; Transfer to HL	POP	HL	LD	C,(HL)		; Get type of disable	SLA	C		; Multiply by 2	LD	B,00H		; BC = offset into table	INC	HL		; HL => Address table	ADD	HL,BC		; HL => Addr of msg string	LD	E,(HL)		; Get address into DE	INC	HL	LD	D,(HL)	EX	DE,HL		; HL => proper Disable msg	@@LOGOT			; Log the message	JP	EXIT		; Go to exit routine;;	FORMAT - Format memory disk;FORMAT	LD	HL,VERIFY	; "Verifying ram...	@@DSPLY	LD	D,00H		; Track counter;;	Display current cylinder formatting;WIPELP	LD	A,D		; Get track counter	CALL	DECASC2		; Display the ASCII value;;	Run 4 bit tests on each cylinder;	LD	A,0FFH		; All bits on	CALL	VERCYL		; Verify track with bits on	LD	A,55H		; Next pattern	CALL	VERCYL	LD	A,0AAH		; Third pattern	CALL	VERCYL	LD	A,00H		; All bits off	CALL	VERCYL		; Verify with all bits off;;	Finished formatting yet?;	INC	D		; Bump cylinder number	LD	A,D	CP	(IX+06H)	; Finished?	JR	NZ,WIPELP	; No - loop back for another;;	Finished formatting - display message;	LD	HL,FORMCOM	; "Format complete	@@DSPLY	RET			; Done formatting;;	VERCYL - Verify a cylinder of RAM;VERCYL	LD	HL,IOBUFF	; HL => I/O buffer	LD	E,00H		; Init to sector 0;;;STUFLP	LD	(HL),A		; Stuff into buffer	INC	L		; Bump sector pointer	JR	NZ,STUFLP	; Loop for one sector;;	Write the sector and read it back;CYLP	PUSH	AF		; Save fill byte	CALL	WRSEC		; Write the sector	CALL	RDSEC		; Read to other buffer	POP	AF		; Get fill byte back;;	Check if sector read back has correct byte;CKLP	CP	(HL)		; Match?	JP	NZ,ERROR	; No - error!	INC	L		; Done with sector?	JR	NZ,CKLP		; No - loop until done;;	Advance to next sector;	LD	A,E		; Get sector number	CP	(IX+07H)	; Finished?	LD	A,(HL)		; Get cylinder byte	INC	DE		; Bump E	JR	NZ,CYLP		; DCT+8 sectors to check	RET			; Done - return;;	FORMTIT - Check if MemDISK has data on it;FORMTIT	LD	DE,0100H	; Cylinder 1, Sector 0	CALL	RDSEC		; Read GAT sector;;	Check GAT ID byte;	LD	L,0D0H		; MemDISK Pack name	LD	DE,MEMDISK	; What it should be	LD	B,08H		; # of chars to check;CKMLP	LD	A,(DE)		; Get should-be char	CP	(HL)		; Match?	INC	HL		; Bump the pointers	INC	DE	JR	NZ,NOMTCH	; No - must format	DJNZ	CKMLP		; Yes - loop for more;;	Already a MemDISK - Sure about formatting?;	LD	HL,DOFORM	; Destination...	LD	A,01H		; Set MemDISK in flag	LD	(MEMIN1+1),A	JR	DISMES		; Display it;;	Not a MemDISK - do normal prompting;NOMTCH	LD	HL,STILLFM	; Do you wanna format it?DISMES	@@DSPLY;;	Get user input in response to question;	LD	B,01H		; Input 1 char	PUSH	HL	CALL	INPUT	LD	A,(HL)		; Get user response	POP	HL		; Recover message start	DEC	B		; Anything entered?	RET	NZ		; Return if nothing;;	Set Z flag if "Y" and reset Z if "N";	RES	5,A		; Force to upper case	CP	'N'		; Answered "N"??	JR	Z,RESZF		; Return NZ status	CP	'Y'		; Answered "Y"?	RET	Z		; Return with Z set	JR	DISMES		; Neither - repromptRESZF	OR	A		; Reset Z flag	RET			;   and return with status;;	Variables used;SAVEDE	DW	0SAVEDCT	DW	0DRADD	DW	0;;	Informative error display and abort routine;NODRV	LD	HL,NODRV$	; "Drive # required	DB	0DDHBADDRV	LD	HL,BADDRV$	; "Can't do drive 0	DB	0DDHVIASET	LD	HL,VIASET$	; "Must be via SET	DB	0DDHMEMIN	LD	HL,MEMIN$	; "Already installed	DB	0DDHNOTMEM	LD	HL,NOTMEM$	; "Not a memdisk!	DB	0DDHNOMEM	LD	HL,NOMEM$	; Insufficient memory	DB	0DDHNOTPRS	LD	HL,NOTPRS$	; Not present	DB	0DDHBNKUSE	LD	HL,BNKUSE$	; Bank in use	DB	0DDHNOTACT	LD	HL,NOTACT$	; Can't install;;	Log error message and abort;	@@LOGOT	JP	ABORT;;	Messages and data area;HELLO$	DB	'MEMDISK'*GET	CLIENT;BANKS	DB	LF	DB	'<A>  Bank 0 (Primary Memory)',LF	DB	'<B>  Bank 1',LF	DB	'<C>  Bank 2',LF	DB	'<D>  Banks 1 and 2',LF	DB	'<E>  Disable MemDISK',LF	DB	0AH,'Which type of allocation - <A>, <B>, <C>, <D>, or <E> ? ',ETX;FRTRACK	DB	'Note: Each Cylinder equals 'FRTRK1	DB	'4.50K of space.',LF	DB	'Number of free Cylinders: ',MINCYL+'0'&0FFH,'-'FRTRK2	DB	'00 ? ',ETX;DENSITY	DB	'Single or Double Density <S,D> ? ',ETX;DOFORM	DB	'Destination MemDISK contains Data',LF;STILLFM	DB	'Do you wish to Format it <Y/N> ? ',ETX;MEMDISK	DB	'MEMDISK 'MD$	DB	'$MD',ETXMDDATA	DB	18H,17,0,0,8,'MemDISKD',0,0,0,0;NODRV$	DB	'Logical drive number required',CR;BADDRV$	DB	'Can',27H,'t specify SYSTEM drive slot',CR;INSTALD	DB	'MemDISK Successfully Installed',CR;NOTMEM$	DB	'Target Drive not a MemDISK',CR;NOMEM$	DB	'Insufficient Memory ',CR;NOTPRS$	DB	'MemDISK not present',CR;NOTACT$	DB	'MemDISK not present, installation aborted',CR;DISABE1	DB	'MemDISK disabled, memory now available',CR;DISABE2	DB	'MemDISK disabled, Unable to reclaim high memory',CR;DISABE3	DB	'MemDISK disabled, Unable to reclaim driver area',CR;DISABE4	DB	'MemDISK disabled, Unable to reclaim high memory and driver area',CR;BNKUSE$	DB	'Unable to install MemDISK, requested bank in use.',CR;MEMIN$	DB	'MemDISK already Active',CR;VERIFY	DB	'Verifying RAM cylinder 00',ETX;FORMCOM	DB	LF,'Verifying Complete, RAM good',LF	DB	'Directory has been placed on Cylinder 1',CR;VIASET$	DB	'Must install via SYSTEM (DRIVER=',CR;BADRAM	DB	LF,'Verify Error in Bank 'VBANK	DB	'n at location X',27HVLOC	DB	'nnnn',27H,LF,CR;TYPEDIS	DB	01HDISTAB	DW	DISABE4,DISABE3,DISABE2,DISABE1RE_USE	DB	00H;;	Buffers used;	ORG	$<-8+1<+8IOBUFF	DS	256	;EQU	3C00HBUFFER	DS	256	;EQU	3D00HDUPDCT	DS	10	;EQU	3E00H;	END	START