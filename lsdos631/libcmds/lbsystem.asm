;LBSYSTEM/ASM - SYSTEM command	TITLE	<SYSTEM - LS-DOS 6.3>;;MODPORT	EQU	0ECHETX	EQU	03H		; End of textCR	EQU	0DH		; Carriage return;*GET	SVCMAC			; System SVC macros*GET	LOWCORE/EQU		; Get LOWCORE equates*GET	SYSRES/EQU		; Get SYSRES equates;;	ORG	2400H;SYSTEM	JP	SYSTEM1		; Jump over data;NOMEM$	DB	'No memory space available',CRPRMERR$	DB	'Parameter error',CRNOCYL8$	DB	'CYL=c invalid on 8" drive',CRBADCYL$	DB	'Cylinder count out of range <35-96>',CRBADSYS$	DB	'Can',27H,'t SYSRES requested module',CRMODRES$	DB	'System module already resident',CREIPMPT	DB	'Enter DCT driver <BREAK=default> : ',ETXBADBS$	DB	'Boot step out of range <0-3>',CRDCTEXT	DB	'DCT';;	Parameter table - Version 5.x table;PRMTBL$	DB	'ALIVE '	DW	ALIVE+1	DB	'AMPM  '	; New in 6.3	DW	AMPM+1	DB	'BSTEP '	DW	BSPARM+1	DB	'DRIVER'	DW	DVRPARM+1	DB	'FAST  '	DW	FPARM+1	DB	'SLOW  '	DW	SLOW+1	DB	'SWAP  '	; New in 6.3	DW	SWAPRM+1	DB	'SYSRES'	DW	SYSRES+1	DB	'SYSTEM'	DW	SYSPRM+1	DB	'TYPE  '	DW	TYPE+1	DB	'WP    '	DW	WPARM+1	DB	'BLINK '	DW	BLINK+1	DB	'BREAK '	DW	BREAK+1	DB	'CYL   '	DW	CYLPRM+1	DB	'DATE  '	DW	DATE+1	DB	'DELAY '	DW	DELAY+1	DB	'CKDRV '	DW	CKDRV+1	DB	'DISABL'	DW	DISABL+1	DB	'DRIVE '	DW	DRIVE+1	DB	'ENABLE'	DW	ENABLE+1	DB	'GRAPHI'	DW	GRAPHI+1	DB	'LARGE '	DW	LARGE+1	DB	'RESTOR'	DW	RPARM+1	DB	'SMALL '	DW	SMALPRM+1	DB	'PRTIME'	; New in 6.3	DW	PRPARM+1	DB	'STEP  '	DW	STEP+1	DB	'TIME  '	DW	TIME+1	DB	'TRACE '	DW	TRACE+1	DB	'SMOOTH'	DW	SMOOTH+1	DB	'HERTZ5'	DW	HERTZ50+1	DB	'HERTZ6'	DW	HERTZ60+1	DB	00H;;;SYSTEM1	LD	(SAVESP+1),SP	; Save stack ptr	@@CKBRKC		; Check if BREAK pressed	JP	NZ,ABORT	; Abort if it was	LD	DE,PRMTBL$	; Check on user params	@@PARAM	JP	NZ,PRMERR	; Quit if param error	@@FLAGS			; Get IY = flag tableSLOW	LD	BC,0		; Test SLOW param	LD	A,B	OR	C	JR	NZ,SETSLOW	; Jump if SLOW enteredFPARM	LD	BC,0		; Test FAST param	LD	A,B	OR	C	JR	Z,FPEND		; Neither SLOW nor FAST?	SET	3,(IY+'S'-'A')	; Set fast in flag	IF	@MOD4	SET	6,(IY+'M'-'A')	; Set bit 6 in port mask	ENDIF	LD	B,55H		; Init time slice byte	JR	SETCLK;;	Turn off FAST;SETSLOW	RES	3,(IY+'S'-'A')	; Reset the FAST bit	IF	@MOD4	RES	6,(IY+'M'-'A')	; Reset bit in port mask	ENDIFSETCLK	LD	A,B	LD	(TIMSL$),A	; Set 55H=fast, FFH=slow	IF	@MOD4	LD	A,(IY+'M'-'A')	; Update the port	OUT	(MODPORT),A	ENDIFFPEND	EQU	$;;	Trace entry;TRACE	LD	BC,1		; Init to pass by	LD	A,B	OR	C	JR	Z,TROFF		; Go if trace off	INC	A	JR	NZ,TREND	; Go if not entered	IF	@MOD4	LD	DE,TRACE_INT	; Point to trace SYSRES routine	ENDIF	IF	@MOD2	LD	DE,DO_TRACE	; Address	ENDIF	LD	C,7		; Init to task 7	@@ADTSK			; Turn TRACE (ON)	JR	TRENDTROFF	LD	C,7		; Init to task 7	@@RMTSK			; Remove TRACE taskTREND	EQU	$;;	Routine to handle AMPM - New in ver 6.3;AMPM	LD	BC,1		; Init AMPM=ON	LD	A,B		; AMPM=OFF?	OR	C	JR	Z,AMPMOFF	; Turn AMPM off	LD	A,B	AND	C	INC	A		; Specified?	JR	NZ,AMPMEND	; Go if not	RES	4,(IY+'I'-'A')	; Turn off	JR	AMPMENDAMPMOFF	SET	4,(IY+'I'-'A')	; Turn it onAMPMEND	EQU	$;;	Routine to handle BREAK;BREAK	LD	BC,1		; Init BREAK=ON	LD	A,B	OR	C		; Break OFF?	JR	Z,BRKOFF	; Jump if off	INC	A		; Check if on	JR	NZ,BRKEND	; Go if no param used	RES	4,(IY+'S'-'A')	; Correct system flag	JR	BRKENDBRKOFF	SET	4,(IY+'S'-'A')	; Disable break keyBRKEND	EQU	$;;	Routine to handle PRTIME parameter - new in ver 6.3;	Turns printer timeout on or off;PRPARM	LD	BC,1		; Init to PRTIME=ON	LD	HL,TSLPX@	; Point into printer driver	LD	A,B	OR	C		; Is it off?	JR	Z,PRTMOFF	; Go if OFF	LD	A,B	AND	C		; Specified at all?	INC	A	JR	NZ,PRTMEND	; Go if not specified	LD	A,1BH		; Restore DEC DE instrPRTMOFF	LD	(HL),A		; Set into printer driverPRTMEND	EQU	$;;	Date prompt suppression during BOOT;DATE	LD	BC,1		; Init to pass by	LD	A,B	OR	C		; DATE=OFF?	LD	B,0FFH		; Init to date suppress	JR	Z,DOFF		; Go if suppress	INC	A		; Specified at all?	JR	NZ,DATEND	; Go if not entered	LD	B,A		; B=0 on no suppressDOFF	CALL	GETCFG		; Get track 0, sector 2	LD	A,B		; Get back the code byte	LD	(DTPMT$&0FFH+SBUFF$),A	CALL	PUTCFG		; Write it backDATEND	EQU	$;TIME	LD	BC,1		; Init to pass by	LD	A,B	OR	C	LD	B,0FFH		; Init to time suppress	JR	Z,TOFF		; Go if TIME=OFF	INC	A		; Specified at all?	JR	NZ,TIMEND	; Go if not specified	LD	B,A		; B=0 on no suppressTOFF	CALL	GETCFG		; Get track 0, sector 2	LD	A,B		; Get code byte	LD	(TMPMT$&0FFH+SBUFF$),A	CALL	PUTCFG		; Write it backTIMEND	EQU	$;;	Boot step rate adjust;BSPARM	LD	BC,-1		; Pick up parameter	INC	B		; User entry?	JR	Z,BSPEND	; Go if not entered	LD	A,C		; Transfer parameter	CP	04H	JR	C,GUDBS		; Okay if < 4	LD	HL,BADBS$	;   else bad step rate	CALL	SETERR	JR	BSPENDGUDBS	LD	B,A		; Save step rate	CALL	GETCFG		; Get system info sector	LD	L,70H+3		; Offset to data	LD	A,(HL)		; Pick up DCT+3 params	AND	0FCH		; Strip off boot step	OR	B		; Merge new boot step	LD	(HL),A		; Put it back in sector	CALL	PUTCFG		; Write back to diskBSPEND	EQU	$;;	BLINK parameter;BLINK	LD	BC,1		; Pick up param	LD	A,B	OR	C	DEC	A		; Specified?	JR	Z,BLIEND	; Go if not	INC	A	JR	NZ,BLNKON	; Go if BLINK=ON	SET	6,(IY+'V'-'A')	; Turn off blinking	IF	@MOD2	LD	A,(@CRSCHAR)	; Get current char	AND	1FH		; Keep size only	JR	SETBLK		; Setup	ENDIF	IF	@MOD4	JR	BLIEND		; Continue	ENDIFBLNKON	RES	6,(IY+'V'-'A')	; Turn on blinking	CP	0FFH		; If not just BLINK,	IF	@MOD4	JR	NZ,SETBLK	;   set user cursor	ENDIF	IF	@MOD2	JR	Z,LARGE		; Go if notBLIADJ	SUB	7		; Force in range 0-7	JR	NC,BLIADJ	; Go until in range	ADD	A,7		; Add back last SUB	OR	01000000B	; Set blink enable 1/16	JR	SETBLK		; Continue	ENDIFLARGE	LD	BC,0		; Else test if large,	INC	C		;   small or default	IF	@MOD2	LD	A,01000111B	; Standard cursor	ENDIF	IF	@MOD4	LD	A,'_'		; Standard cursor	ENDIF	JR	NZ,SMALPRM	IF	@MOD2	LD	A,01000000B	; To large	ENDIF	IF	@MOD4	LD	A,8FH		; To large	ENDIFSMALPRM	LD	BC,0		; Get small param	INC	C	JR	NZ,SETBLK	IF	@MOD2	LD	A,01000101B	; Small	ENDIF	IF	@MOD4	LD	A,88H		; Small	ENDIFSETBLK	LD	C,A		; Xfer cursor char to C	LD	B,08H		; Cursor update function	@@VDCTLBLIEND	EQU	$;;	RESTORE parameter;RPARM	LD	BC,1		; Pick up param	LD	A,B	OR	C	DEC	A		; Specified?	JR	Z,REND		; Go if not	INC	A	JR	NZ,RSTRON	; Go if RESTORE=on	DB	3EH		; Make LD A,nRSTRON	XOR	A	LD	B,A		; Save step	CALL	GETCFG		; Get config sector	LD	L,RSTOR$&0FFH	; Pt to RESTORE flag	LD	(HL),B		; Stuff back	CALL	PUTCFG		; Write sectorREND	EQU	$;;	Type ahead processing;TYPE	LD	BC,1		; Pick up param value	LD	A,B	OR	C	DEC	A		; Was TYPE used?	JR	Z,TYPEND	; Go if not entered	INC	A		; Is it on?	JR	NZ,TYPEON	; Go if TYPE=ON	RES	1,(IY+'D'-'A')	; Turn TYPE off	JR	TYPENDTYPEON	SET	1,(IY+'D'-'A')	; Turn TYPE onTYPEND	EQU	$;;	Process SMOOTH paramter;SMOOTH	LD	BC,1		; Get smooth param	LD	A,B	OR	C	DEC	A		; Was smooth used?	JR	Z,SMEND		; Skip if not entered	INC	A	JR	NZ,SMON		; Go if smooth=on	IF	@MOD4	RES	3,(IY+'D'-'A')	; Show OFF in DFLAG$	LD	A,00H		; Set to store NOP	LD	(FDDINT$),A	ENDIF	JR	SMENDSMON	EQU	$	IF	@MOD4	SET	3,(IY+'D'-'A')	; Show on in DFLAG$	LD	A,0F3H		; DI opcode	LD	(FDDINT$),A	; Put in FDD driver	ENDIFSMEND	EQU	$;;	Routine to process HERTZ selection;HERTZ50	LD	BC,1		; Pickup H50 parameter	LD	A,B	OR	C	DEC	A		; Check if param entered	JR	Z,HZ50END	; Go if not	LD	A,25		; Init 25 ints/sec	LD	(HERTZ$),A	; Put value in timer codeHZ50END	EQU	$HERTZ60	LD	BC,1		; Pick up H60 parameter	LD	A,B	OR	C	DEC	A		; Check if param entered	JR	Z,HZ60END	; Go if it wasn't	LD	A,30		; Init to 30 ints/sec	LD	(HERTZ$),A	; Load it into timerHZ60END	EQU	$;;	Routine to process GRAPHIC;GRAPHI	LD	BC,1		; Init for bypass	LD	A,B	OR	C	DEC	A		; Check if param entered	JR	Z,GRAEND	; Go if it wasn't	INC	A		; Test if GRAPHIC=OFF	JR	Z,GROFF		; Go if off	SET	7,(IY+'D'-'A')	; Turn graphic on	JR	GRAENDGROFF	RES	7,(IY+'D'-'A')	; Turn graphic offGRAEND	EQU	$;;	Routine to process ALIVE;ALIVE	LD	BC,1		; Pick up ALIVE param	LD	A,B	OR	C	DEC	A		; Was it specified?	JR	Z,ALVEND	; Bypass if omitted	INC	A	JR	NZ,ALIVEON	; Go if on	IF	@MOD2	LD	C,6		; Slot alive	ENDIF	IF	@MOD4	LD	C,03H		; Slot alive	ENDIF	@@RMTSK			; Remove it if OFF	JR	ALVEND;ALIVEON	EQU	$	IF	@MOD2	LD	C,6		; Task slot for ALIVE	LD	DE,DO_ALIVE	; Task address	@@ADTSK			; Add task	ENDIF	IF	@MOD4	CALL	GOTMEM?		; Is HIGH$ frozen?	JP	C,NOMEM		; Quit if so	CALL	GETHI$		; Get address for ALIVE	LD	(ALVBGN+2),HL	; Stuff last byte used	LD	BC,ALVEND-ALVBGN	; Get code length	XOR	A	SBC	HL,BC		; Calc new HIGH$	LD	B,00H	@@HIGH$			; Set new HIGH$	INC	HL		; Point to module start	PUSH	HL		; Save start	LD	C,ALVTCB-ALVBGN+2	ADD	HL,BC		; Point to alive task	LD	(ALVTCB),HL	;   & stuff ALIVE TCB	EX	(SP),HL		; Recover start of module	EX	DE,HL		;   into DE	LD	HL,ALVBGN	LD	BC,ALVEND-ALVBGN	LDIR			; Move to high memory	POP	DE		; Recover start of task	DEC	DE		; Back up to TCB	DEC	DE	LD	C,03H		; Add as task 3	@@ADTSK	JR	ALVEND	ENDIF;;	ALIVE high memory module;	IF	@MOD4ALVBGN	JR	$	DW	$-$	DB	05H,'ALIVE'	DW	0,0;	ALVTCB	DW	0;	LD	HL,79		; Get char at 0,79	PUSH	HL	LD	B,01H		; Set function 1	CALL	@VDCTL		; Get char currently	CP	0A3H		;   on screen and	LD	A,93H		;   exchange it	JR	Z,ALIVE1	LD	A,0A3HALIVE1	POP	HL	LD	B,02H		; Function to put char	LD	C,A	CALL	@VDCTL		;   at row,col	RET	ENDIFALVEND	EQU	$;;	Routine to process SYSRES;SYSRES	LD	BC,-1		; Pick up sysres param val	INC	B		; Test if param entered	JP	Z,RESEND	; Go if not	CALL	GOTMEM?		; Is high memory available?	JP	C,NOMEM		; Quit if not	LD	A,C	OR	A	JR	Z,BADSYS	; Cannot SYSRES 0	CP	2		; Check if it is SYS2	JR	NZ,TEST6	; Go if not	LD	HL,DCT$+4	; Point to system DCT	RES	7,(HL)		;   & allow CKDRV nowTEST6	CP	6	JR	C,GUDSYS	; Can SYSRES 1-5	CP	9	JR	C,BADSYS	; Cannot SYSRES 6-8	CP	13	JR	NC,BADSYS	; Nothing > 12 (yet)GUDSYS	PUSH	AF		; Save sysres request	LD	HL,HKRES$+1	; Check if the driver	LD	E,(HL)		;   is already resident	INC	HL	LD	D,(HL)	LD	HL,CKMOD@	; Standard address	OR	A		; Reset carry	SBC	HL,DE		; No driver if equal	JR	Z,PUTDVR	; Go and install driver	LD	HL,-32		; Find RESTAB$ position	ADD	HL,DE		; Point to vector table	RLCA			; Request times 2	ADD	A,L	LD	L,A	JR	NC,$+3	INC	H		; RESTAB$ + entry index	INC	HL		; Point to high order	LD	A,(HL)		; Get high order	OR	A	JR	Z,MOVITIN	; Go if not there	LD	HL,MODRES$	;   else show already res'd	DB	0DDHBADSYS	LD	HL,BADSYS$	CALL	SETERR		; Log and set error	POP	AF	JP	RESEND;;	SYSRES driver module header;RES1	JR	$	DW	0	DB	4,'SYS '	DW	0,0RES1E	EQU	$-1;MOVITIN	LD	(OVRLY$),A	; Show no overlay res	POP	AF		; Recover requested SYS	PUSH	AF	ADD	A,02H		; Adjust for DEC	OR	80H		; Set SYS request	PUSH	HL		; Save RESTAB$ address	CALL	CKMOD@		; Load SYSn, no exec	CALL	GETHI$		; Pick up HIGH$	LD	(RES1+2),HL	; Save in header	EX	DE,HL	LD	BC,(MAXCOR$-2)	; Get length of SYSx	LD	HL,1E00H	; Point to overlay start	ADD	HL,BC	DEC	HL		; Point to last byte	PUSH	BC		; Save length	LDDR			; Move into position	POP	BC		; Recover length	LD	A,B		;   and stuff in front	LD	(DE),A		;   of SYSRESed module	DEC	DE	LD	A,C	LD	(DE),A	POP	HL		; Recover RESTAB ptr	LD	(HL),D		; Save hi-order addr	DEC	HL	LD	(HL),E		;    and low-order	POP	AF		; Recover module requested	CP	10		; Less than 10?	JR	C,$+4		; Go if 0-9	ADD	A,07H		; Offset to letters	ADD	A,'0'		; Make it ASCII	LD	HL,RES1+8	; Point to name	LD	(HL),A		; Stuff in module name	DEC	DE		; Point to 1st free byte	LD	BC,13		;   and move in the	LD	HL,RES1E	;   linkage protocol	LDDR	EX	DE,HL	@@HIGH$			; Store new HIGH$ (B=0)	JP	RESEND;PUTDVR	CALL	GETHI$		; Pick up HIGH$	LD	(RESBGN+2),HL	; Stuff last used	LD	BC,RESEND-RESBGN	SBC	HL,BC		; Make space for driver	LD	B,00H	@@HIGH$	PUSH	HL		; Save new HIGH$	LD	DE,13		; Point to RESTAB$-3	ADD	HL,DE	LD	(RESD1+1),HL	; Stuff pointer	POP	HL	INC	HL		; Pt to RESBGN	PUSH	HL	EX	DE,HL		; Where it goes to DE	LD	HL,RESBGN	; Where it's at now	LDIR			; Move up to high mem	POP	HL		; Recover where it went	LD	DE,32+RESTAB$-RESBGN	; Index start of dvr	ADD	HL,DE		; Point to driver entry	LD	(HKRES$+1),HL	; Hook into SYS0	POP	AF		; Recover code	JP	GUDSYS		;   and loop;;	SYSRES resident driver module;RESBGN	JR	$		; No real entry	DW	0	DB	06H,'SYSRES'	DW	0,0;;	SYSRES driver data area;RESTAB$	DW	1,0,0,0,0,0,1,1	DW	0,0,0,0,0,0,0,0;;	SYSRES driver code;RESDVR	PUSH	HL	PUSH	AF		; Save SYS needed	LD	HL,OVRLY$	; Check if already in	XOR	(HL)		;   overlay area	AND	0FH		; Strip garbage	JR	Z,NOTRES	POP	AFRESD1	LD	HL,RESTAB$+1	; Pick up table ptr	PUSH	AF	AND	0FH		; Check if in high mem	RLCA			; Times two	ADD	A,L		; Update table pointer	LD	L,A		; Move back to HL	JR	NC,$+3		; Skip if same page	INC	H		;   else bump pointer	LD	A,(HL)		; Pick up high pointer	OR	A	JR	Z,NOTRES	; Go if not in high	DEC	HL		; Point to low	LD	L,(HL)		; Get low order vector	LD	H,A		;   and high order	PUSH	DE		; Save these registers	PUSH	BC	LD	C,(HL)		; Pick up module length	INC	HL		;   into BC	LD	B,(HL)	INC	HL		; Point to module start	LD	DE,1E00H	; Point to overlay region	LD	(HKRES$+9),DE	; Update TRAADR	PUSH	BC		; Save the length	LDIR			; Move code to overlay rgn	POP	HL		; Recover length	LD	(MAXCOR$-2),HL	; Stuff pointer	POP	BC		; Restore regs	POP	DE	POP	AF	LD	(HKRES$+4),A	; Show it's resident	POP	HL		;   in temp location	RETNOTRES	POP	AF		; Clean up stack	POP	HL	JP	CKMOD@		;   and get moduleRESEND	EQU	$GETSEC2	LD	A,(CYLPRM+1)	; If CYL=c entered	OR	A		;   get config sector	CALL	NZ,GETCFGDRIVE	LD	BC,-1		; Get DRIVE param	LD	IX,SBUFF$+70H	; Point to DCT sector fields	LD	IY,DCT$		; Init to do all DCT$'s *	INC	B	JR	Z,CKEI		; Go if drive not entered	LD	A,C	CP	08H		; Drive in range?	JP	NC,PRMERR	; Quit if not	@@GTDCT			; Get drive's DCT	PUSH	IY		; Save the DCT addressCKEI	EQU	$;ADJEI	PUSH	IY		; Calc IY offset into	POP	HL		;   DCTs to adjust IX	LD	DE,-DCT$	ADD	HL,DE	EX	DE,HL	ADD	IX,DEDVRLOOP	EQU	$;;	Routine to process WP parameter;WPARM	LD	BC,1		; Pick up WP param value	LD	A,B	OR	C	DEC	A		; Check if entered	JR	Z,WPEND		; Go if it wasn't	INC	A	JR	Z,WPOFF		; Go if OFFWPON	SET	7,(IY+03H)	; Turn on write protect	JR	WPENDWPOFF	RES	7,(IY+03H)	; Turn off write protectWPEND	EQU	$;;	Routine to process CYL parameter;CYLPRM	LD	BC,0		; Pick up cyl param value	LD	A,B	OR	C	JR	Z,CYLEND	; Go if not entered	BIT	5,(IX+03H)	; If drive is 8",	JR	Z,CYL1		;   can't do it	LD	A,(DRIVE+1)	; If drive entered,	OR	A		;   give error msg	LD	HL,NOCYL8$	CALL	NZ,SETERR	; Msg if DRIVE=d	JR	DISABLCYL1	LD	A,C		; Pick up user entry	DEC	A	CP	34		; Not less than 35!	JR	C,BADCYL	; Go if bad	CP	96		; Not more than 96	JR	C,GUDCYL	; Go if okayBADCYL	LD	HL,BADCYL$	; "Cyl out of range	CALL	SETERR		; Display and quit	XOR	A	LD	(CYLPRM+1),A	JR	DISABLGUDCYL	LD	(IX+06H),A	; Stuff default DCTCYLEND	EQU	$;;	Routine to process DISABL parameter;DISABL	LD	BC,0		; Get param value	LD	A,B	OR	C	JR	Z,ENABLE	; Go if not disable	LD	A,(DRIVE+1)	; Don't allow DISABLE	INC	A		;   if DRIVE parameter	JR	Z,STEP		;   not entered	LD	A,0C9H		; Init disable byte	JR	ENADISENABLE	LD	BC,0		; Pick up param value	LD	A,B	OR	C	JR	Z,STEP		; Go if not ENABLE	LD	A,0C3H		; Init enable byteENADIS	LD	(IY+00H),A	; Set ENABLE/DISABLE;;	Routine to process STEP parameter;STEP	LD	BC,-1		; Pick up STEP param value	INC	B	JR	Z,STEPEND	; Go if not entered	LD	A,C	CP	04H		; STEP must be < 4	JP	NC,PRMERR	; Quit if out of range	BIT	4,(IY+04H)	; Alien controller?	JR	NZ,WDESD	; Bypass if alien	LD	A,(IY+03H)	; Pick up DCT byte and	AND	0FCH		;   mask off the old step	OR	C		; Merge in the new value	LD	(IY+03H),A	;   and put back in DCTSTEPEND	EQU	$;;	Routine to process the DELAY parameter;DELAY	LD	BC,1		; Pick up param value	LD	A,B	OR	C	DEC	A		; Check if entered	JR	Z,CKDRV		; Go if no delay entered	INC	A		; Check if OFF	LD	B,00H		; Init delay=on	JR	NZ,DELAY1	; Go if ON	LD	B,04H		; Init delay=offDELAY1	LD	A,(IY+03H)	; Update delay	AND	0FBH		;   in DCT	OR	B	LD	(IY+03H),A;;	Routine to process CKDRV parameter;CKDRV	LD	BC,1		; Pick up param value	LD	A,B	OR	C	DEC	A		; Check if entered	JR	Z,WDESD		; Go if not entered	INC	A		; See if OFF or ON	LD	B,00H		; Init ckdrv=on	JR	NZ,CKDRV1	; Go if ON	LD	B,80H		; Set bit 7, CKDRV offCKDRV1	LD	A,(IY+04H)	; Update CKDRV bit	AND	7FH		;   by removing old state	OR	B		;   and merging 0 or 80H	LD	(IY+04H),A	; Put back in the DCTWDESD	LD	A,(DRIVE+1)	; Drive param used prev?	INC	A	JR	NZ,PUTSEC2	; Go if DRIVE entered	LD	DE,10		;   else loop thru all DCTs	ADD	IX,DE		; Advance to next DCT	ADD	IY,DE	PUSH	IY	POP	HL		; Xfer DCT start to HL	LD	A,L	CP	80+70H		; Offset is 70H	JP	C,DVRLOOP	; Loop until done	LD	HL,0		; Show no DCT given	PUSH	HLPUTSEC2	LD	A,(CYLPRM+1)	; if CYL=c entered	OR	A		;   put config sector	CALL	NZ,PUTCFG;;	Routine to process DRIVER parameter;DVRPARM	LD	DE,0		; Pick up param value	LD	A,D	OR	E	JP	Z,DVR4		; Go if DRIVER not entered	INC	A		; Full name entered?	JR	Z,GETN3		; Go if not & prompt	LD	HL,FCB1+1	;   else pick it up	PUSH	HL		; Save pointer to startGETN1	LD	A,(DE)		; Pick up name char	CP	0DH	JR	Z,GETN2		; Exit on EOL	CP	','	JR	Z,GETN2		; Exit on end of param	CP	'"'	JR	Z,GETN2		; Exit on closing quote	CP	')'	JR	Z,GETN2		; Exit on end of params	CP	03H	JR	Z,GETN2		; Exit on JCL line end	LD	(HL),A		;   else transfer char	INC	DE		; Bump the pointers	INC	HL	JR	GETN1		; Loop until doneGETN2	LD	(HL),0DH	; End with CR	POP	HL		; Recover name pointer	JR	DVR2GETN3	@@DSPLY	EIPMPT		; "Enter driver name	LD	HL,FCB1+1	; Point to buffer	LD	BC,24<8		; 24 chars max	@@KEYIN			; Get filespec	JR	NC,DVR2		; Go if not break;;	Break entered on DRIVER request;	Reset all drive code table positions;	if DRIVE not entered;	CALL	GETCFG		; Get sys info sector	LD	HL,SBUFF$+70H-DCT$	; Pt to tables "offset"DDCT1	LD	A,(DRIVE+1)	; Was drive entered?	INC	A	POP	DE		; Recover drive #	JR	NZ,DDCT2	; Go if it was spec'd	LD	DE,DCT$		;   else use all eightDDCT2	ADD	HL,DE		; Index the specific DCTDVRA	LD	A,E	CP	40+70H	LD	A,0C9H		; Disable drives 4-7	JR	NC,DVRB	LD	A,0C3H		; Enable drives 0-3DVRB	LD	(HL),A		; Stuff vector (JP/RET)	INC	L		; Point to default DCT+3	INC	L	INC	L	INC	E		; Point to resident DCT+3	INC	E	INC	E	LD	BC,7		; Shift defaults to	LDIR			;   resident DCTDVRC	LD	A,(DRIVE+1)	; Test if DRIVE entered	INC	A		;    again	JR	NZ,GOSYSP	; Go if it was	LD	A,E		; Check on end of DCTs	CP	80+70H	JR	NC,DVRA		; Loop until all 8 doneGOSYSP	JP	SYSPRMDVR2	LD	A,(HL)		; Is first char enter?	CP	0DH	JR	Z,DVR4		; Bypass if default	CALL	GOTMEM?		; Check mem avalaible	POP	DE		; Pop to keep stack	JP	C,NOMEM		;   straight if error	PUSH	DE	LD	DE,FCB1		;   else fetch spec	@@FSPEC	LD	HL,DCTEXT	; Use /DCT as the	@@FEXT			;    default extension	@@FLAGS			; Get system flags	SET	2,(IY+'S'-'A')	; Set RUN bit	@@LOAD			; Load the proggie	POP	DE		; Recover drive table	JP	NZ,IOERR	; Quit on load error	PUSH	DE	PUSH	HL		; Save prog's TRAADR	LD	HL,DVR4		; Point to our return	EX	(SP),HL		; Exchg with his	SET	3,(IY+'C'-'A')	; Set system request	JP	(HL)		; Go to driver;;;ABORT	LD	HL,-1		; Set abort codeSAVESP	LD	SP,0		; Pick up orig stack	@@CKBRKC	RET			; Return;;	More message handling things;BRKABT	LD	HL,BRKABT$	DB	0DDHPSYSJCL	LD	HL,PSJCL$	DB	0DDHBADDRV	LD	HL,BADDRV$	DB	0DDHSWPBAD	LD	HL,SWPBAD$	DB	0DDHNOMEM	LD	HL,NOMEM$	DB	0DDHPRMERR	LD	HL,PRMERR$SETERR	@@LOGOT	JR	ABORTIOERR	LD	L,A		; Error code to HL	LD	H,00H	OR	0C0H		; Abbrev & return	LD	C,A		; Error code to C	@@ERROR	JR	SAVESP		; exitDVR4	POP	DE;;	SYSTEM = new system drive;SYSPRM	LD	BC,-1		; Pick up param value	LD	A,B	AND	C		; Specified?	INC	A		;	JR	Z,SYSPEND	; Go if not	LD	(SWAPRM+1),BC	; Init SWAP to spec'd drive	LD	HL,0	LD	(DRIVE+1),HL	; Set drive 0 as original (?)SYSPEND	EQU	$;;	SWAP parameter handler;SWAPRM	LD	BC,-1		; Pick up param value	LD	A,B	AND	C	INC	A		; Param specified?	JR	Z,EXIT		; Finished if not!	LD	A,C		; Get drive to swap to	CP	08H		; Check range	JP	NC,BADDRV	; Go if out of range	LD	(SWPDRV),A	; Save it	LD	HL,SRCDRV	; Where to save src	OR	A		; Is it drive 0?	JR	Z,SWAP0		; Go if it is	LD	(HL),A		; Set source drive	LD	HL,SWPDRV	; Point to destSWAP0	ADD	A,'0'		; Convert to ascii	LD	(SWAPSRC),A	; Stuff in message	LD	A,(DRIVE+1)	; Pick up DRIVE= drive	CP	08H		; Check range	JP	NC,BADDRV	; Go if out of range	LD	(HL),A		; Store in destination	ADD	A,'0'		; Convert to ascii	LD	(SWAPDST),A	;   and put in message	LD	A,(HL)		; Get dest drive back	XOR	C		; Does source=dest?	JP	Z,SWPBAD	; Error if the same	LD	A,(SWPDRV)	; Get swap destination	OR	A		; Is it drive 0?	LD	A,(SRCDRV)	; Pick up destination	CALL	Z,CHKSYSD	; Check for system disk if 0	CALL	UPDTJCL		; Update JCL file's FCB	LD	C,00H		; Pick up driveSWPDRV	EQU	$-1	@@GTDCT			; Get destination drive	BIT	7,(IY+04H)	; Check CKDRV inhibit	RES	7,(IY+04H)	; Set it OFF	PUSH	AF		; Save result and DCT	PUSH	IY	LD	C,00H		; Pick up source driveSRCDRV	EQU	$-1	@@GTDCT			; Get DCT for drive	POP	HL		; Get old DCT back	POP	AF		; Get old result	RES	7,(IY+04H)	; Force CKDRV off	JR	Z,SWAP1		; Go if was off	SET	7,(IY+04H)	; Turn it back onSWAP1	PUSH	IY		; Move DCT to	POP	DE		;   DE	LD	BC,10		; 10 bytes to swapSWAP2	LD	A,(DE)		; Get byte from DCT	LDI			; Transfer	DEC	HL		; Back up one	LD	(HL),A		; Move byte (again!?!)	INC	HL		; Bump pointer	JP	PE,SWAP2	; Loop until done	LD	HL,SWAPM$	; "Drives swapped" msg	@@DSPLY;;	Exit with no error;EXIT	LD	HL,0	RET;;	UPDTJCL - Update FCB of working /JCL file;UPDTJCL	LD	HL,SFLAG$	; Point to SFLAG$	BIT	5,(HL)		; Test if JCL is active	RET	Z		; Return if not	LD	HL,JFCB$+6	; Point to JCL file's FCB	LD	A,(SWPDRV)	; Get destination drive	LD	B,A		; Save it in B	XOR	(HL)		; XOR with JCL file's drive	AND	07H		; Just keep drive bits	LD	A,(SRCDRV)	; Load src drive	JR	NZ,JCLNOT0	; Go if not drive 0	LD	B,ACHGJCLD	LD	A,(HL)		; Get /JCL file's drive	AND	0F8H		; Keep DEC bits	OR	B		; Merge in new drive	LD	(HL),A		; Store back in FCB	RETJCLNOT0	XOR	(HL)		; Change drive back	AND	07H		; Keep drive of /JCL file	JR	Z,CHGJCLD	; Jump back if 0	RET;;	Check for system disk, prompt for one if needed;CHKSYSD	LD	(SVSYSD+1),A	; Save drive	ADD	A,'0'		; Convert to ASCII	LD	(PMTSYSD),A	; Store in promptSVSYSD	LD	C,00H		; Get system drive	@@CKDRV			; Check if drive ready	JR	NZ,GETSYSD	@@GTDCT	LD	D,(IY+09H)	; Get dir cylinder	LD	HL,SBUFF$	; Point to system buffer	LD	E,L		; Sector 0	@@RDSSC			; Read GAT	JP	NZ,IOERR	; Jump if GAT read error	LD	L,0CDH		; Get data byte	BIT	7,(HL)		; Data disk?	JR	NZ,GETSYSD	; Go if data disk	LD	HL,SBUFF$	LD	E,05H		; SYS1's dir sector	@@RDSSC	LD	A,(HL)		; SYS1 on this disk?	AND	80		; Test for SYS flag	CP	80		; Is it a SYS file?	RET	Z		; Return if it is;;	Prompt for system disk;GETSYSD	LD	HL,SFLAG$	; Get SFLAG$	BIT	5,(HL)		; Test if JCL active	JP	NZ,PSYSJCL	; Can't ask in DO file	LD	HL,PMTSYS$	; Prompt for system disk	@@DSPLY	LD	HL,FCB1		; Nice area for input	LD	BC,0		; 256 allowed?	@@KEYIN	JR	NC,SVSYSD	JP	BRKABT		; Go if break entered;;	Routines to put/read the config sector;PUTCFG	LD	A,53		; @WRSEC;	IF	@MOD4	DB	21H		; Ignore next with LD HL,xx	ENDIF	IF	@MOD2	JR	PUTGETC		; Jump over if Model 2	ENDIF;GETCFG	EQU	$	IF	@MOD4	LD	A,49		; @RDSEC	LD	DE,0<8+2	; Config sector	ENDIF;	IF	@MOD2	LD	A,(DCT$+3)	; Drive 0 DCT data	AND	28H		; Bit 5/3	CP	20H		; 8" floppy?	JR	NZ,SETSYS1	; Go if not	LD	A,(DCT$+4)	; Get data	AND	50H		; Bit 6/4	CP	40H		; DD not alien?	JR	NZ,SETSYS1	; Go if not;	LD	HL,SBUFF$	; System buffer	LD	A,(DCT$+9)	; Get DIR cylinder	LD	D,A		; Pass to D	LD	E,0		; Init sector 0	LD	C,E		; Init drive 0	@RDSSC			; Read directory	JR	NZ,PUTGETE	; Go on disk error	LD	A,(SBUFF$+0CDH)	; Get GAT data byte	BIT	7,A		; Is data disk?SETSYS1	LD	DE,0<8+2	; Init sysinfo sector	JR	NZ,$+3		; Go if data disk	INC	D		;   else new SysInfo	LD	A,49		; Init RDSEC	ENDIF;PUTGETC	LD	HL,SBUFF$	; System buffer	LD	C,L		;   in system drive	RST	28H		; Read or write	RET	Z		; Back if good I/OPUTGETE	POP	HL		;   else abort	JP	IOERR;;	Routine to get HIGH$;GETHI$	LD	B,00H		; Func to get high$	LD	H,B	LD	L,B	@@HIGH$			; Get current HIGH$	RET;;	Routine to test if HIGH$ is frozen;GOTMEM?	LD	A,(CFLAG$)	; Check if memory can	RRCA			;   be altered	RET;;;PSJCL$	DB	'Can',27H,'t prompt for SYSTEM disk during JCL!',CRPMTSYS$	DB	'Insert SYSTEM diskette in drive 'PMTSYSD	DB	'X ',CRSWAPM$	DB	'Drives :'SWAPSRC	DB	'S and :'SWAPDST	DB	'D now swapped',CR;SWPBAD$	DB	'Source & Destination are the same drive!',CRBADDRV$	DB	'Drive specification error <0-7>!',CRBRKABT$	DB	'Manual <BREAK> abort!',CR	DB	'SSSSSSSSSSSSSSSSSS'	DB	'SSSSSSSSSSSSSS'FCB1	DC	32,0;	END	SYSTEM