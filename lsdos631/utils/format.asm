; ***************************************************************; * Filename: FORMAT/ASM					*; * Revision: 06.03.01						*; * Rev Date: 10 Dec 97						*; ***************************************************************; * Floppy diskette formatting utility				*; *								*; ***************************************************************;	TITLE	<FORMAT - LS-DOS 6.3>	SUBTTL	'<Format Execution Code>';PASSWRD	EQU	42E0H		; Blank passwordRLS	EQU	63H		; Version 6.3LF	EQU	10CR	EQU	13CRT3	EQU	3C00H		; Model III screen startCRT4	EQU	0F800H		; Model IV screen start;*GET	SVCMAC			; System SVC macros*GET	COPYCOM			; Copyright message;	ORG	2600H;	IF	@MOD4BOOTST$	DB	9DH		; Boot step rate offset	ENDIF	IF	@MOD2BOOTST$	DB	03H	ENDIF;;GOFMT	BIT	4,(IY+04H)	; Jump if alien controller	JP	NZ,HRDRVFMTTBL	LD	DE,0		; Get table pointer	LD	A,(DE)		; Get # of sectors to format	INC	DE		; Adjust for zero offset	LD	(SECTRK),A	LD	B,A	BIT	5,(IY+04H)	; Need twice as many	JR	Z,$+3		;   if double sided	RLCA	LD	(SECCYL),ASYSPRM	LD	HL,0		; Get System Info param	LD	A,H		; Don't format if system	OR	L		;   info only is requested	JP	NZ,MOVFREE	LD	A,(DE)		; Get track skew	INC	DE	LD	(TRKSKEW+1),A	LD	(SECSKEW+1),DE	; Format sector skew;;	Index past sector info;	INC	A		; Add DE -> begin of sec #	ADD	A,B		; B -> # of sectors/side	ADD	A,E		; A+1 -> a code byte	LD	E,A	ADC	A,D	SUB	E	LD	D,A	LD	HL,FORMAT	; Buffer to format data	LD	BC,HITBUF	; Temp ptrs to trk,sect info;;	Create the formatting data without track,sector info;FMTDAT	LD	A,(DE)		; Get table format byte	INC	DE		; Bump table pointer	CP	0F1H		; Start of cylinder?	JR	Z,CODF1	CP	0F2H		; Start of track trailer?	JR	Z,CODF2	CP	0F3H		; Start of track ID info?	JR	Z,CODF3	CP	0F4H		; End of table params?	JR	Z,CODF4	CP	0F5H		; Start of data?	PUSH	BC	JR	NZ,CODE1	; Go if not;;	Write 2 byte data pattern to format buffer;	LD	A,(DE)		; Get length to write	INC	DE		; Bump to 1st data byte	LD	B,A		; Transfer length to B	LD	A,(DE)		; Get a data byte	INC	DE		; Point to 2nd data byte	LD	C,A		; Move 1st byte to C	LD	A,(DE)		; Get 2nd byteCODF5	LD	(HL),C		; Stuff into buffer	INC	HL	LD	(HL),A	INC	HL	DJNZ	CODF5		; Loop until all done	JR	CODERET;;	Transfer bytes to the format buffer area;	A => Count to move;	DE=> Data byte to duplicate;CODE1	LD	B,A		; Count to B	LD	A,(DE)		; Get data byte to moveCODE1A	LD	(HL),A		; Fill buffer with byte	INC	HL	DJNZ	CODE1A		; Loop til doneCODERET	POP	BC	INC	DE		; Bump table pointer	JR	FMTDAT		; Go back for more;;	Save the current table position and number of;	sectors per cylinder on the stack.;CODF1	LD	A,(SECTRK)	; Get # of sectors/sideCODF1A	PUSH	DE		; Save table pointer	PUSH	AF		; Save value	JR	FMTDAT;;	Done with a sector.  Are there more on this cyl?;CODF2	POP	AF		; Count down the # of	DEC	A		;   sectors to format	JR	Z,CODF2A	; Go if last one done	POP	DE		; Recover table pointer	JR	CODF1A		; Loop for more;CODF2A	POP	AF		; Clean the stack	JR	FMTDAT		;   and finish off the cyl;;	Build a table of the location in the format buffer of;	the track and sector ID bytes, to be filled in during;	the actual formatting;CODF3	LD	A,L		; Stuff pointer to where	LD	(BC),A		;   track and sector info	INC	BC		;   is to be placed	LD	A,H	LD	(BC),A	INC	BC	JR	FMTDAT;;	Finished building format cyl info.  Terminate the ID table;	with an extra 256 bytes in case of overrun.;CODF4	LD	(VERSKEW+1),DE	; Table position of verify order	XOR	A		; Stuff to 00s to indicate end	LD	(BC),A	INC	BC	LD	(BC),A	LD	B,00H		; Stuff 256 FFs into the	LD	A,0FFH		;   format buffer	LD	(HL),A	INC	HL	DJNZ	$-2;;	Begin the formatting;	LD	HL,FMTCYL$	; "Formatting cylinder	@@DSPLY BGNFMT	LD	A,(IY+05H)	; Get cylinder position	CALL	CVDEC		; Convert to decimal	CALL	DSPCYLSECSKEW	LD	BC,0		; Begin of sector tableBFMT1	LD	HL,HITBUF	; Get ptr to ID pos'n table;BFMT2	@@CKBRKC		; Check for break	JP	NZ,BREAK	; Go if it was hit;	LD	E,(HL)		; Get positions having	INC	HL		;   sector & cylinder	LD	D,(HL)		;   info to be stuffed	INC	HL		;   into format data	LD	A,D		; Finished?	OR	E	JR	Z,BFMT4	LD	A,(IY+05H)	; Get cylinder & stuff	LD	(DE),A		;   into format data	INC	DE	LD	A,(IY+03H)	; Stuff the side select	AND	10H		;   bit	RRCA	RRCA	RRCA	RRCA	LD	(DE),A		;   into the format data	INC	DE	LD	A,(BC)		; Get the sector number	OR	A	JP	P,BFMT3		; Go if a good number	ADD	A,C		;   else off the end,	LD	C,A		;   calculate the beginning	JR	C,BFMT3		;   of the sector table	DEC	BBFMT3	LD	A,(BC)		; Get the next sector #	LD	(DE),A		;   and stuff into format data	INC	DE	INC	BC	JR	BFMT2		; Loop until cylinder done;BFMT4	LD	(SECSKEW+1),BC	; Save end of sector table	LD	D,(IY+05H)	; Get current cylinder	LD	HL,FORMAT	; Point to format data	CALL	SELECT		; Drive select	JP	NZ,IOERR	; Go on error	CALL	WRCYL		; Write the cylinder	JP	NZ,IOERR	BIT	5,(IY+04H)	; Double sided?	JR	Z,BFMT5	BIT	4,(IY+03H)	; Flip bit for 2nd side	JR	NZ,BFMT5	;   if not already on it	SET	4,(IY+03H)	;   else go to next	INC	BC		; Bump to start side 2	JR	BFMT1		;   at differetn sector #BFMT5	RES	4,(IY+03H)	; Turn off side 2TRKSKEW	LD	A,00H		; Get the track skew byte	ADD	A,C		; Repoint to beginning	LD	C,A		;   of sector table	ADC	A,B		; Skew start of next track	SUB	C	LD	B,A	LD	(SECSKEW+1),BC	LD	A,(IY+05H)	; Finished?	CP	(IY+06H)	JR	Z,BGNVER	; Begin verify if so	LD	BC,1000/15	; Approx 1ms pause	@@PAUSE 	CALL	STEPIN		; Step head in	JP	NZ,IOERR	; Go on error	LD	BC,BGNFMT	; Place RET addr on stackCKWAIT	CALL	RSELCT		; Wait for idle FDC	JP	NZ,IOERR	; Go on error	PUSH	BC		; Save RET addr;;	WAIT parameter for time delay after STEPIN;WAITPRM	LD	BC,3000/15	; Approx 3 ms delay	LD	A,B		;   after STEPIN	OR	C	RET	Z		; Do next track if no wait	@@PAUSE			;   else wait for count	RET;;	Begin the verification process;BGNVER	LD	C,CR		; Position to next display line	@@DSP	CALL	RESTOR		; Position to cylinder 0	JR	NZ,BVER9	; Go on error	@@DSPLY	VERCYL$		; "verifying ..."	LD	D,00H		; Init track count;BVER1	@@CKBRKC		; Check for break	JP	NZ,BREAK	;   and abort if so;	LD	L,D		; Pt to GAT byte for this	LD	H,GATBUF<-8	;   track & bypass verify	LD	A,(HL)		;   if track not formatted	INC	A	JR	Z,BVER8;	LD	A,D		; Convert cyl # to ASCII	CALL	CVDEC	PUSH	DE	CALL	DSPCYL		; Display current cylinder	POP	DE	XOR	A		; Initialize starting sector	LD	(BVER5+1),A	LD	(BVER4+1),AVERSKEW	LD	BC,0		; Get start of sector tableBVER3	LD	A,(BC)		; Get sector numberBVER4	ADD	A,00H		; Add in a side's sectors	LD	E,A		;   if on side 2	CALL	VERSEC		; Verify the sector	JR	NZ,BVER9	; Go on error	INC	BC		; Bump sector table pointerBVER5	LD	A,00H		; Get sector #	INC	A		; Increment it	LD	(BVER5+1),A	;   and save new #	LD	E,A		; Move it to sector register	LD	A,(SECCYL)	; Is this = a cyl?	CP	E	JR	Z,BVER8		; Go if cyl done	LD	A,(SECTRK)	; Is this a track's worth?	CP	E	JR	NZ,BVER3	; Loop back if not	LD	(BVER4+1),A	; Update the add for side 2	INC	BC	JR	VERSKEW;;	Readjust for end of cylinder;BVER8	LD	A,D		; Get curr cyl position	INC	D		; Bump to next cyl	CP	(IY+06H)	; CP to highest cyl	LD	BC,BVER1	; Go if more to verify	JR	NZ,CKWAIT	;   after checking WAIT;;	Shift the FREE table to the LOCKOUT table;MOVFREE	LD	HL,GATBUF	; Ptr to allocation info	LD	DE,GATBUF+60H	; Lockout table loc'n	LD	B,00H	LD	C,(IY+06H)	; Get high cylinder	INC	C		; Offset from 0	LDIR			; Shift info to lockout table	LD	C,CR		; Print a new line	@@DSP	JR	CALCDIR		; Go finish DIR init;;	Got a verify error;BVER9	CP	05H		; Data record not found?	JR	Z,BVER10	CP	04H		; Parity error?	JP	NZ,IOERR	; Quit on any otherBVER10	PUSH	DE		; Save DE	@@DSPLY	STAR$		; Show the '*' lockout	POP	DE	LD	L,D		; Point to this cyl	LD	H,GATBUF<-8	;  in the GAT	LD	(HL),0FFH	; Lockout this cylinder	JR	BVER8		; Continue verifying;;	Hard drive format - most work done by controller;HRDRV	LD	HL,LASTMSG	; Give one last chance to	BIT	3,(IY+03H)	;   abort before wiping	JR	Z,AFLOP		;   disk unless floppy	CALL	GET3		; Is hard, get response	LD	A,(HL)		; Get 1st char of resp	CP	'Y'		; Must be yes to continue	JP	NZ,FMTABTAFLOP	LD	A,(SYSPRM+1)	; Bypass the formatting	OR	A		;   if system info only	JR	NZ,HRDRV1	@@DSPLY	FMTG$		; "formatting be patient	CALL	FMTHD		; Format the hard drive	JP	NZ,IOERRHRDRV1	LD	A,(IY+07H)	; # of sectors/gran	LD	D,A	AND	1FH	LD	E,A	INC	E		; Bump for 0 offset	XOR	D		; Get # heads into D	RLCA	RLCA	RLCA	INC	A		; Adjust for 0 offset	LD	C,A	@@MUL8			; Multply E * C	BIT	5,(IY+04H)	; 2-sided?	JR	Z,$+3	ADD	A,A		; Twice the number if so	LD	(SECCYL),A	BIT	3,(IY+03H)	; Floppy disk?	JR	Z,MOVFREE	; Form lock table instead;;	Routine to calculate the directory cylinder;CALCDIR	CALL	RESTOR		; Step all the way in	JP	NZ,IOERR	LD	H,GATBUF<-8	LD	L,(IY+06H)	; Get highest # cylinderDIRPARM	LD	BC,0		; Get "DIR=" param	LD	A,C	OR	B	JR	Z,NODIR		; Calc one if not entered	CP	L		; Entered, so check if	JR	NC,NODIR	;   within cylinders	LD	L,A		; It's okay, use it	JR	DIRSETNODIR	INC	L		; Adjust for 0 offset	SRL	L		; Divide by 2 to findDIRSET	LD	C,00H		;   disk midpoint;;	Perform expanding binary search to find;	a cylinder available for the directory.;CALC1	LD	A,(HL)		; Is this cylinder	INC	A		; Available or locked out?	JR	NZ,GENSYS	; Bypass if available	INC	C		; Bump C	LD	A,C	RRCA			; Test if odd or even	LD	A,L		; Get current test position	JR	NC,CALC2	; Jump if C was even	ADD	A,C		; Add to previous position	LD	L,A	CP	(IY+06H)	; Gone over the top?	JR	NZ,CALC1	; Loop if not	JR	CALC3		; Else abortCALC2	SUB	C		; Try a lower cylinder #	LD	L,A	JR	NZ,CALC1	; At cylinder 0?CALC3	LD	HL,NOCYL$	; "No dir space avail...	JP	FMTABT;;	Generate the system information;GENSYS	LD	(IY+09H),L	; Stuff the dir cylinder	LD	A,L	CALL	CVDEC		; Convert reg A to 2 dec digits	LD	(DIRASC$),BC	; Stuff into the message	@@DSPLY	DIRCYL$		; "Dir will be placed on...	@@DSPLY	IPLSYS$		; "Initializing...	LD	HL,GATBUF	LD	A,(HL)		; Get GAT byte for 1st	OR	01H		;   cylinder & show 1st	LD	(HL),A		;   gran in use for BOOTs	LD	A,(IY+09H)	; Dir cyl # into DIR/SYS	LD	(DIRDIR+16H),A	LD	L,A		; Show entire directory	LD	(HL),0FFH	;   cylinder used;;	Update BOOT for DIR and step rate;	LD	A,(IY+09H)	; Dir cyl into boot (redundant load)	LD	(BOOT+2),A	LD	A,(BOOTST$)	; Get offset	LD	L,A	LD	H,BOOT<-8	LD	A,(STEPDFT)	; Get boot step rate	IF	@MOD2	OR	80H		; Create single byte opcode	ENDIF	LD	(HL),A		; Set it into BOOT	LD	DE,0		; Init for cyl 0, sect 0	CALL	VERSEC		; Test if formatted	LD	HL,NOTFMT$	; "Can't, not formatted	JP	NZ,EXTERR	; Error if not	LD	HL,BOOT		; Pt to data disk BOOT	CALL	WRSEC		;   and write it	CALL	Z,WRDIR1	; Verify after write	JP	NZ,IOERR	;   and display '.'	LD	DE,1		; Point to cyl 0, sector 1	LD	HL,BOOT	CALL	WRSEC		; Write 0/1	CALL	Z,WRDIR1	; Verify after write	JP	NZ,IOERR;;	Complete GAT construction;	LD	A,(IY+06H)	; Get highest cylinder	SUB	22H		; Adjust offse from 34	LD	(GATBUF+0CCH),A	; Stuff GAT cyl excess	LD	A,(IY+04H)	; Get number of sides	AND	80H+20H	LD	B,A		; Temporary save	LD	A,(IY+03H)	; Get density	AND	40H		; Mask it	OR	B		;   merge in sides	LD	B,A		;   and save it	LD	A,(IY+08H)	; Get grans/cyl	RLCA			;   to bits 0-2	RLCA	RLCA	AND	07H		; Mask it	LD	(CYLGRN+1),A	OR	B		; Merge the two	OR	88H		; Data disk (80H), new dates (08H)	LD	(GATBUF+0CDH),A	; Put into GAT	LD	DE,GATBUF+255-10 ; Ver 6.2+ Media Data Block	LD	HL,LSIID	; Point to header	LD	BC,4		; Set length	LDIR			;   and move it	PUSH	IY		; Get DCT address	POP	HL		;   into HL	INC	HL		; Bypass the driver vector	INC	HL	INC	HL	LD	C,07H		; bytes to move	LDIR			; Move DCT+3 to MDB	JR	WRGAT1		; Jump around string;LSIID	DB	03H,'631';WRGAT1	LD	HL,GATBUF	; Point to GAT buffer	LD	D,00H		; Write it out to	LD	E,03H		; Cyl 0, sector 3	CALL	WRSEC	CALL	Z,WRDIR1	; Verify after write	JP	NZ,IOERR	; Quit on error;;	Write the system information sector;	LD	HL,HITBUF	; Zero out bufferGSYS1	LD	(HL),00H	INC	L	JR	NZ,GSYS1	; (HL back to HITBUF when done)	LD	(HL),RLS	; Write release at HITBUF	LD	L,20H		; Point to AUTO buffer	LD	(HL),0DH	; Put in terminator	LD	DE,0002H	; Cyl 0, sector 2	LD	L,D		; HL now points to HITBUF again	CALL	WRSEC		; Write the sysinfo sector	CALL	Z,WRDIR1	; Verify after write	LD	L,20H		; Zero this out for use	LD	(HL),00H	;   when writing the HIT;;	Write out the directory GAT;	LD	HL,GATBUF	; Point to GAT sector buff	LD	D,(IY+09H)	; Get the DIR cylinder	LD	E,L		; Set sector 0	CALL	Z,WRDIR		; Write the GAT;;	Construct the HIT;	LD	HL,HITBUF	; Point to HIT buffer	LD	(HL),0A2H	; Stuff BOOT/SYS hash code	INC	HL	LD	(HL),0C4H	; Stuff DIR/SYS hash code	DEC	HL	LD	D,(IY+09H)	; Get the DIR cylinder	LD	E,01H		; Sector 1 is the HIT	CALL	WRDIR		; Write the HIT	JP	NZ,IOERR	LD	DE,HITBUF	; Establish buffer for	LD	HL,BOOTDIR	;   dir records	LD	BC,32		; Move BOOT/SYS dir record	LDIR			;   into 1st slot	LD	D,(IY+09H)	; Get DIR cylinder	LD	E,02H		; This will be sector 2	LD	HL,HITBUF	; Point to the buffer	CALL	WRDIR		;   and write it out	JP	NZ,IOERR	LD	A,(SECCYL)	; Get # of records	OR	A		; Make sure it's in	JR	Z,MAKHIT1	;   the allowed range	CP	34+1	JR	C,MAKHIT2MAKHIT1	LD	A,34		; Max allowed is 34!MAKHIT2	LD	HL,SECCYL	LD	(DIRDIR+14H),A	; Stuff recs into DIR/SYSCYLGRN	LD	A,00H		; Get grans/cyl	BIT	5,(IY+04H)	; Test for 2-sided	JR	Z,$+4	ADD	A,A		; Double count on 2-sided	INC	A		; Plus 1 for 0 offset adj	LD	(DIRDIR+17H),A	; Stuff in DIR/SYS	LD	A,(IY+09H)	; Get DIR cylinder	LD	(DIRDIR+16H),A	;   and stuff in, too	LD	HL,DIRDIR	; Point to start of data	LD	DE,HITBUF	; Move DIR/SYS into buffer	LD	BC,32	LDIR	LD	D,(IY+09H)	; Get DIR cyl again (redundant?)	LD	E,03H		; This is sector 3	LD	HL,HITBUF	; Start of buffer	CALL	WRDIR		; Write the sector	JR	NZ,IOERR	LD	HL,HITBUF	; Zero the 1st 32 bytes	LD	B,32GSYS2	LD	(HL),00H	; Where we stuff the	INC	HL		;    BOOT and DIR entries	DJNZ	GSYS2	LD	D,(IY+09H)	; Get dir cyl	LD	E,04H		; Continue at sector 4GSYS3	LD	HL,HITBUF	; Write the sector	CALL	WRDIR	JR	NZ,IOERR;;	Write the remaining directory;	INC	E		; Bump the sector pointer	LD	A,(SECCYL)	; Get highest sector #	CP	E		; Are we finished yet?	JR	NZ,GSYS3	; Loop if not	CALL	EXIT2		; Get system disk	@@DSPLY	FMTCAO$		; "Format complete	JR	EXIT;;	Exit procedures;IOERR	PUSH	AF		; Save error code	CALL	EXIT2		; Interrupts on if needed	POP	AF		; Recover error code	CP	63		; Extended error?	JR	Z,EXTERR	; Go if it is;M29B1	LD	L,A		; Error code to HL	LD	H,00H	OR	0C0H		; Short msg and return	LD	C,A	@@ERROR			; Show error msg	JR	ERREXIT;BREAK	EQU	$FMTABT	LD	HL,FMTABT$	; "Command abortedEXTERR	@@LOGOT			; some error to abort job	CALL	EXIT2		; Get system disk	LD	HL,-1		; Set abort codeERREXIT	LD	(RETCOD),HLEXIT	LD	HL,0RETCOD	EQU	$-2;	PUSH	HL	PUSH	IY		; Transfer the saved	POP	DE		;   system DCT back	LD	HL,SYSDCT	;   into the system	LD	BC,10		;   DCT slot	LDIR	CALL	RESTOR		; Restore drive to trk 0	POP	HLSPSAV	LD	SP,$-$		; Get original stack	@@CKBRKC	RET;EXIT2	LD	A,(FMTDRV+1)	; Get drive # just fmt'd	INC	A		; If drive never entered	RET	Z		;   just return	DEC	A		; If 0, we need a system	JR	NZ,EXIT4	LD	HL,PMTSYS$	; "Insert system disk	@@DSPLYEXIT3	@@KEY			; Get a key press	CP	0DH		; Enter key?	JR	NZ,EXIT3	; Loop until it isEXIT4	JR	RESTOR;;	Disk I/O requests;DRVNOP	XOR	A	JR	DO_DIOSELECT	LD	A,01H	JR	DO_DIORESTOR	LD	A,04H	JR	DO_DIOSTEPIN	LD	A,05H	JR	DO_DIORSELCT	LD	A,07H	JR	DO_DIOWRCYL	LD	A,0FH	JR	DO_DIOFMTHD	LD	A,0CH	JR	DO_DIOWRSEC	LD	A,0DH	JR	DO_DIOWRSYS	LD	A,0EH	JR	DO_DIORDSEC	LD	A,09H	JR	DO_DIOVERSEC	LD	A,0AHDO_DIO	PUSH	BCFMTDRV	LD	C,0FFH	ADD	A,40	RST	28H	POP	BC	RET;;	Perform a verification to ensure system sector;VERSYS	CALL	VERSEC		; Sector verify	JR	Z,VERS1		; Bypass if not system	SUB	06H		; Test read system retcode	RET	Z		; Go if that's what it was	ADD	A,06H		; Restore original code	RETVERS1	OR	01H		; S/B system, found data	LD	A,00H	RET;WRDIR	CALL	WRSYS		; Write the DIR sectorWRDIR1	CALL	NZ,VERSYS	; Verify after write	RET	NZ	PUSH	DE	LD	C,'.'		; Display a period	@@DSP			;   for every sector written	POP	DE	RET;;	Routine to convert A to 2 decimal digits;CVDEC	LD	C,'0'		; Init MSD to 0CVD1	SUB	0AH		; Sub 10 until underflow	JR	C,CVD2	INC	C		; Inc the count	JR	CVD1CVD2	ADD	A,3AH		; Add back 10 + '0'	LD	B,A		; LSD to B	RET;;	Routine to convert input strings to UC;	HL => prompt string;GET3	@@DSPLY			; Display prompt	LD	BC,3<8		; 3 chars max	JR	$+5GET8	LD	BC,8<8		; 8 chars max	LD	HL,HITBUF	; Buffer areaGET8A	@@KEYIN			; Get user input	JP	C,BREAK		; Quit on BREAK	LD	A,B		; Get lenght of response	OR	A	RET	Z		; Back if just ENTER;;	Routine to convert n-character string to UC;	PUSH	AF		; Save the registers	PUSH	BC	PUSH	HLGETUC	LD	A,(HL)		; Get a char	CP	'a'		; Skip if below 'a'	JR	C,GETUC1	CP	'z'+1		;   or above 'z'	JR	NC,GETUC1	RES	5,(HL)		; Force upper caseGETUC1	INC	HL		; Bump buffer pointer	DJNZ	GETUC		; Loop for all chars	POP	HL		; Get regs back	POP	BC	POP	AF	RET;;	Routine to display the cylinder number;DSPCYL	PUSH	BC		; Save ASCII cyl #	LD	C,08H		; Back up twice &	@@DSP			;   output new position	LD	C,08H	@@DSP	POP	BC		; Recover cyl #	@@DSP			; Display MSD	LD	C,B	@@DSP			; Display LSD	RET;;	Formatting data and tables;BOOTDIR	DB	5EH		; Attributes	DB	0		; Various flags  & month	DB	0		; Day/	DB	0		; EOF Offset byte	DB	0		; Logical record length	DB	'BOOT    SYS'	; Filename & Ext	DW	71F4H		; Owner password	DW	0		; V 6.3 date/time field	DW	5		; Ending record number	DB	00H		; Starting cyl for extent	DB	00H		; Starting & contiguous grans	DW	-1		; 2nd extent unused	DW	-1		; 3rd extent unused	DW	-1		; 4th extent unused	DB	-1		; No FXDE linked to this	DB	-1		;   so no FPDE link;DIRDIR	DB	5DH		; Attribs	DB	00H		; Various flags again	DB	00H		; Date info	DB	00H		; EOF offset	DB	00H		; LRL	DB	'DIR     SYS'	; Filename/ext	DW	71F4H		; Owner password	DW	4296H		; User password (old date style)	DW	10		; Ending record number	DB	11H		; Starting cyl for extent	DB	01H		; Total and contiguous grans	DW	-1		; No more extents!	DW	0		; Remaining info unused	DW	0		;   in the DIR/SYS	DW	0		;   directory record;SYSDCT	DS	10STEPDFT	DB	0		; Boot step rate defaultSECCYL	DS	1		; # sectors per cylSECTRK	DS	1		; # sectors per track;;	Single density 5" format table;S5TBL	DB	10,7	DB	0,5,1,6,2,7,3,8,4,9	DB	-10,-10,-10,-10,-10,-10,-10,-10,14,0FFH	DB	0F1H,6,0,1,0FEH	DB	0F3H,3,0,1,1,1,0F7H,1,0FFH,11,0FFH	DB	6,0,1,0FBH,0,0E5H,1,0F7H,1,0FFH,13,0FFH	DB	0F2H,47H,0FFH	DB	0F4H,0,1,2,3,4,5,6,7,8,9;;	Double density 5" format table;D5TBL	DB	18,10	DB	0,9,1,10,2,11,3,12,4,13,5,14,6,15,7,16,8,17	DB	-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,20H,4EH	DB	0F1H,12,0,3,0F5H,1,0FEH	DB	0F3H,3,0,1,1,1,0F7H,22,4EH,12,0,3,0F5H	DB	1,0FBH,0F5H,128,6DH,0B6H,1,0F7H,1,4EH,23,4EH	DB	0F2H,182,4EH,0F4H	DB	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17;;	Single density 8" format table;S8TBL	DB	10H,02H,0AH,05H,00H,0BH	DB	06H,01H,0CH,07H,02H,0DH	DB	08H,03H,0EH,09H,04H,0FH	DB	0F0H,0F0H,0F0H,28H,0FFH	DB	0F1H,06H,00H,01H,0FEH	DB	0F3H,03H,00H,01H,01H	DB	01H,0F7H,0BH,0FFH,06H	DB	00H,01H,0FBH,00H,0E5H	DB	01H,0F7H,01H,0FFH,14H	DB	0FFH,0F2H,0D0H,0FFH,0F4H	DB	0AH,00H,06H,0CH,02H,08H	DB	0EH,04H,05H,0BH,01H,07H	DB	0DH,03H,09H,0FH;;	Double density 8" format table;D8TBL	DB	1EH,0CH,00H,0AH,14H,01H	DB	0BH,15H,02H,0CH,16H,03H	DB	0DH,17H,04H,0EH,18H,05H	DB	0FH,19H,06H,10H,1AH,07H	DB	11H,1BH,08H,12H,1CH,09H	DB	13H,1DH,0E2H,0E2H,0E2H	DB	0E2H,0E2H,0E2H,0E2H,0E2H	DB	0E2H,0E2H,0E2H,0E2H,0E2H	DB	14H,4EH,0F1H,0CH,00H	DB	03H,0F5H,01H,0FEH,0F3H	DB	03H,00H,01H,01H,01H,0F7H	DB	16H,4EH,0CH,00H,03H,0F5H	DB	01H,0FBH,0F5H,80H,6DH	DB	0B6H,01H,0F7H,01H,0FFH	DB	11H,4EH,0F2H,00H,4EH	DB	3DH,4EH,0F4H,00H,14H	DB	0BH,02H,16H,0DH,04H,18H	DB	0FH,06H,1AH,11H,08H,1CH	DB	13H,0AH,01H,15H,0CH,03H	DB	17H,0EH,05H,19H,10H,07H	DB	1BH,12H,09H,1DH;;;FMTCYL$	DB	1DH,'Formatting cylinder   ',03HVERCYL$	DB	1DH,'Verifying  cylinder   ',03HSTAR$	DB	'*   ',03HFMTG$	DB	'Formatt'M2C71	DB	'ing...',0DHNOCYL$	DB	'No cylinders available for directory',0DHDIRCYL$	DB	'Directory will be placed on cylinder 'DIRASC$	DB	'00',0DHIPLSYS$	DB	0AH,'Initializing DIRECTORY information: ',03HPMTSYS$	DB	0AH,'Load SYSTEM diskette  <ENTER>',0DHFMTCAO$	DB	0AH,0AH,'Formatting complete',0DHFMTABT$	DB	0AH,'Command aborted',0DHNOTFMT$	DB	0AH,'Can',27H,'t, Diskette not formatted',0DH;;	Patch area;	ORG	$<-8+1<+8GATBUF	DS	203	DB	RLS	; OS release formatted underM2ECC	DB	0	; Cylinder excess of 35M2ECD	DB	0	; TypeM2ECE	DW	0	; Master password;	DB	'        '	DB	'MM/DD/YY'	DC	32,0;;;BOOT	EQU	$CORE$	DEFL	$;	ORG	4300H		; Execute at ROM boot	LORG	CORE$		;   but load here;	NOP	CP	00H	IF	@MOD2	DB	83H	ENDIF	IF	@MOD4	DI	ENDIF	DC	12,0	LD	DE,80*11+CRT4+29	; Mod 4 vid loc	LD	HL,DATADSK$		; Xfer error to video	LD	BC,STRLEN	LDIR	LD	DE,64*8+CRT3+21		; Mod 3 vid loc	LD	HL,DATADSK$		; Xfer error to video	LD	BC,STRLEN	LDIRSTOP	JP	STOP;DATADSK$	DB	'Cannot boot, DATA DISK!'STRLEN	EQU	$-DATADSK$	DC	-$&0FFH,0SAFESP	EQU	$	ORG	CORE$+256	LORG	CORE$+256HITBUF	DS	256;	SUBTTL	'<Format Init Code>';*GET	FORMAT2;	END	FORMAT