;SETKI/ASM - Set keyboard parameters	TITLE	SETKI - LS-DOS 6.3;OFFSET	EQU	4		; Length: end of name to data areaDELAY	EQU	OFFSET+2	; Delay valueRPEAT	EQU	OFFSET+3	; Repeat valueDMIN	EQU	10		; Min delay valueRMIN	EQU	1		; Min repeat valueDDFALT	EQU	22		; Default delay valueRDFALT	EQU	2		; Default repeat value;ETX	EQU	03HCR	EQU	0DHLF	EQU	0AHPAR_ERR	EQU	44		; Parameter error code;NUM	EQU	80H		; Numeric parameterFLAG	EQU	40H		; Flag parameterABB	EQU	10H		; Abbreviations allowed;*GET	SVCEQU			; System SVC equates;	ORG	2400H;BEGIN	EQU	$	LD	(SAVESP+1),SP	; Save stack pointer	CALL	PGRM		; Exit via RET;;	Set exit conditions;$EXIT	LD	HL,0		; No errorSAVESP	LD	SP,0		; Get stack ptr back	LD	A,@CKBRKC	; Clear BREAK	RST	28H	RET;$ABORT	LD	HL,-1		; Error!	JR	SAVESP		; and exit;;$DSP	LD	A,@DSP		; Display a character	RST	28H	RET	Z		; Return if no error	JR	IOERR		;   else show error;;$DSPLY	LD	A,@DSPLY	; Display a line	RST	28H	RET	Z		; Return if no error;;	DB	21H		; Skip LD A,##PRMERR	LD	A,PAR_ERRIOERR	LD	H,00H		; Move error code to HL	LD	L,A	OR	0C0H		; Short msg, return	LD	C,A	LD	A,@ERROR	; Display error	RST	28H	JR	SAVESP		; And get out;;	PGRM - Set keyboard parameters;PGRM	PUSH	HL		; Save cmd line ptr	LD	DE,MDNAME	; Name of keyboard driver	LD	A,@GTMOD	; Find module header	RST	28H	LD	A,08H		; Device not available	JP	NZ,IOERR	; Exit if not found	PUSH	DE		; Point to next byte	POP	IX		;   after module name;	POP	HL		; Get cmd line back	CALL	SKSP		; Move to non-space	LD	A,(HL)		; Get cmd line char	CP	'('		; Any params?	JP	Z,GETNEW	; Get/set new values;;	Display old values;	CALL	SETMSG		; Move old values for display	LD	HL,DMSG		; Point to display string	JP	$DSPLY		; Display and exit;;	Set up values in string;SETMSG	LD	A,(IX+DELAY)	; Get old WAIT value	LD	DE,DDELAY	; Buffer to receive	CALL	HEXDEC		; Convert to ASCII decimal	LD	A,(IX+RPEAT)	; Get old RATE value	LD	DE,DRPEAT	; Point to dsply area	JP	HEXDEC		; Convert to ASCII decimal;GETNEW	LD	DE,PRMTBL$	; Point to parameter table	LD	A,@PARAM	; Check on user params	RST	28H	JP	NZ,PRMERR	; Exit on param error;DFPARM	LD	DE,0		; Pick up D param	LD	A,D		; Anything set?	OR	E	JR	Z,SETSTR	; Keep existing if not	LD	(IX+DELAY),DDFALT	; Stuff defaults	LD	(IX+RPEAT),RDFALTSETSTR	CALL	SETMSG		; Put numbers in string;QCHK	LD	DE,0		; Query param used?QPARM	EQU	$-2	LD	A,D		; Test Q param	OR	E	JR	Z,CKPARM	; Go if not spec'd;	LD	A,(WRESP)	; Get WAIT response byte	AND	NUM		; If a "W" number given,	JR	NZ,CKR		;   then ask for R only;GETD	LD	HL,DMSG		; Point to wait prompt msg	CALL	SHOW		; Ask for W time	CALL	GETIT		; Get it (in DE)	JR	Z,CKR		; Don't change if CR only	CALL	DCHECK		; Check if good value	JR	NZ,GETD		; Don't change if not	LD	(IX+DELAY),A	; Store new WAIT value;CKR	LD	A,(RRESP)	; Get RATE response byte	AND	NUM		;   and go if rate was	JR	NZ,CKPARM	;   entered on cmd line	LD	HL,RMSG		; RATE prompt message	CALL	SHOW		; Display prompt	CALL	GETIT		; Get new rate	JR	Z,CKPARM	; Don't change if CR only	CALL	RCHECK		; Check range and don't	JR	NZ,CKR		;   change if out of range	LD	(IX+RPEAT),A	; Store new rate;;	Check entries given on command line;CKPARM	LD	A,(WRESP)	; Get WAIT response byte	AND	NUM		; Number?	JR	Z,CKRP		; Go if not entered	LD	DE,0		; Pick up WAIT parameterWPARM	EQU	$-2	CALL	DCHECK		; Check value	JP	NZ,PRMERR	; Go if value bad	LD	(IX+DELAY),A	;   else store it;CKRP	LD	A,(RRESP)	; Get RATE response byte	AND	NUM		; Number?	RET	Z		; Return if it's not	LD	DE,0RPARM	EQU	$-2		; Pick up RATE parameter	CALL	RCHECK		; Check value	JP	NZ,PRMERR	; Go if value bad	LD	(IX+RPEAT),A	;   else store it	RET			; Done;;SHOW	LD	B,12		; Column positionSH2	LD	C,(HL)		; Get char in C	CALL	$DSP		; Display char from string	DEC	B		; Dec chars to print	INC	HL		; Bump string pointer	LD	A,'='	CP	C	JR	NZ,SH2		; Display up to '='	LD	C,' '		; Then space one	CALL	$DSP	CALL	SKSP		; Move to number	LD	C,'{'		; Display opening brace	CALL	$DSPSH3	LD	C,(HL)		; Pick up character	LD	A,'0'-1		; Check C for numeric value	CP	C	JR	NC,SH4		; Go if not	CALL	$DSP		; Display char	DEC	B		; Dec chars remaining	INC	HL		; Point to next char in string	JR	SH3		; Loop back for more;SH4	LD	C,'}'		; Display closing brace	CALL	$DSP	LD	C,' '		; Tab remaining distanceSH5	CALL	$DSP	DJNZ	SH5	LD	HL,ENDSTR	; Print "?"	JP	$DSPLY;;	Skip spaces in a string;SKSP	LD	A,' '		; Char to skip overSKP2	CP	(HL)		; Same?	RET	NZ		; Return if not	INC	HL		;   else bump pointer	JR	SKP2		;   and loop;;	Data area;DMSG	DB	'Wait   = 'DDELAY	DB	'   , 'RMSG	DB	'Rate   = 'DRPEAT	DB	'   ',CRMDNAME	DB	'$KI',ETXENDSTR	DB	'? ',ETX;;	Parameter Table;PRMTBL$	DB	80H		; Ver 6.x parameter table;	DB	FLAG!ABB!7	DB	'DEFAULT'	DB	00H	DW	DFPARM+1;	DB	NUM!ABB!4	DB	'RATE'RRESP	DB	00H	DW	RPARM;	DB	NUM!ABB!4	DB	'WAIT'WRESP	DB	00H	DW	WPARM;	DB	FLAG!ABB!5	DB	'QUERY'	DB	00H	DW	QPARM	DB	00H		; End of parameter table;;	HEXDEC - Convert hex number to decimal ASCII;	A => 8 bit Hex number to convert;	DE => Destination of ASCII string;HEXDEC	PUSH	BC		; Save registers	PUSH	HL	PUSH	AF	LD	H,00H		; Set HL = #	LD	L,A	LD	B,03H		; Max 3 chars	LD	A,@HDEC		; Convert to ASCII	RST	28H	POP	AF		; Recover registers	POP	HL	POP	BC	RET;;	Check D and R values;RCHECK	LD	D,RMIN		;REPEAT minimum	JR	CHECKDCHECK	LD	D,DMIN		; WAIT minimumCHECK	LD	A,E		; Get number	AND	7FH		; Keep positive	CP	D		; Lowest allowed	RET	C		; Return if too low	CP	A		; Set Z if good value	RET;GETIT	LD	HL,INBUF	LD	BC,3<8		; 3 chars max	LD	A,@KEYIN	; Get user input	RST	28H	JP	C,$ABORT	; Quit if break;INBUF	EQU	$;	END	BEGIN