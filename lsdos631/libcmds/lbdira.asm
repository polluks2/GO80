;LBDIRA/ASM - DIR main processing loop	SUBTTL	'<LBDIRA - Mainline Program>'	PAGE;;	Error processing;NOMEM	LD	HL,NOMEM$	DB	0DDHBADFMT	LD	HL,BADFMT$	@@LOGOT;ABORT	LD	HL,-1	JR	SAVESP;;	I/O Error routine;ERR32	LD	A,32		; Illegal drive numberIOERR	LD	L,A		; Set HL = error #	LD	H,0	OR	0C0H		; Set short error	LD	C,A		; Stuff in C	@@ERROR			; Display error	DB	0DDH		; Mask loading of HL;;	Clear stack and exit;EXIT	LD	HL,0		; Good exitSAVESP	LD	SP,$-$		; Get old SP addressABORT3	@@CKBRKC		; Clear break	RET			; Go home now;;	Init to 4 files/line # drive # in string;DIR4	PUSH	BC		; Save drive #	LD	A,04H		; 4 filespecs/line	LD	(DONAM9+1),A	; Save	LD	B,C		; Get drive #	INC	B		; Adjust	LD	A,3FH		; Make a BIT x,AINSTLP1	ADD	A,8		;   instruction	DJNZ	INSTLP1		;   for the drive	LD	(TSTBIT1+1),A	; Stuff in code for	LD	(TSTBIT2+1),A	;   later use	LD	A,C		; Get drive #	ADD	A,'0'		; Convert to ASCII	LD	(DRIVE),A	; Stuff in message	LD	(NDRIVE),A	; Also in NO DISK;;	Is the starting drive available;	@@GTDCT			; Pt IY to DCT+0	@@CKDRV			; Drive alive?	PUSH	AF		; Save ret condition	CALL	CKPAWS		; Check for BREAK	POP	AF		; NZ - couldn't log drive	JR	Z,GDCKDRV	; Z - Logged drive succ;;	Is this drive enabled?;	LD	A,(IY+00H)	; Get enabled/disabled byte	CP	0C3H		; Is it a jump?	JR	Z,NO_DISK	; Yes - display no disk;;	If this is not global - illegal drive #;	LD	A,(SPECIF+1)	; Specific drive #?	OR	A	JP	Z,ERR32		; Yes - illegal drive #	JR	NEXTDRV		; No - get next drive;;	Enabled drive - display "No disk" string;NO_DISK	LD	(NOTITLE+1),A	; Turn off title	CALL	CKPAGE		; Check for scroll	LD	HL,NODISK	; HL => "No disk" string	CALL	LINOUT		; Display line	CALL	CKPAGE		; Check for scroll	XOR	A		; Turn on title	LD	(NOTITLE+1),A;NEXTDRV	JP	CKHIT4		; Get next drive;;	Calculate quantity of Sectors / Gran;GDCKDRV	PUSH	BC		; Save drive #	LD	A,(IY+08H)	; Get sectors/gran	AND	1FH		; Mask off other stuff	INC	A		; Adjust for 0 offset	LD	(CALCK1+1),A	; Stuff it;;	Get # cylinders from DCT & stuff in string;	LD	L,(IY+06H)	; Grab cyl count	INC	L		; Offset from 0	LD	H,00H	LD	DE,CYLCNT	; Destination	@@HEXDEC		; Convert to ASCII;;	Create "DDEN" string or "HARD" string;	LD	DE,DENSITY	; Destination	LD	HL,DEN	LD	A,'D'	BIT	6,(IY+03H)	; Check density	JR	NZ,DUBDEN	LD	A,'S'DUBDEN	LD	(HL),A	LD	BC,4		; 4 chars to xfer	BIT	3,(IY+03H)	; Hard drive?	JR	Z,DOLDIR	LD	HL,HARD		; HL => "HARD"DOLDIR	LDIR			; Transfer string;;	Drive logged in - read GAT;	POP	BC		; Recover drive #	LD	HL,GAT		; HL => GAT buffer	LD	D,(IY+9)	; D = directory cyl	LD	E,L		; E = GAT sector	@@RDSSC			; Read sector	LD	A,20		; Init "GAT read error"	JP	NZ,IOERR	CALL	CKPAWS		; Break hit?;;;	Calculate the FREE space on the disk;;	LD	DE,0		; DE = gran count	LD	L,0CCH		; HL => GAT + x'CC'	LD	A,(HL)		; Get excess cyl byte	ADD	A,35		; Add in base	LD	B,A		; Set loop counter	LD	L,D		; HL => GAT + 0	PUSH	BC		; Save cyl count in B;;	HL => GAT, B = # cyls, DE = Gran count;FS1	LD	A,(HL)		; Get byte from GAT & setFS2	SCF			; Carry so Bit 7 stays 1;;	Is the granule in use?;	RRA			; Shift gran bit -> carry	JR	C,FS3		; Don't inc if in use;;	Free granule - bump free granule count;	INC	DE		; Another spare granFS3	CP	0FFH		; Fin with this GAT byte?	JR	NZ,FS2		; Loop if not;;	Finished with GAT byte - advance to next;	INC	L		; Bump pointer	DJNZ	FS1		; Loop for # of grans;;	DE = Free grans, Calc # of grans per cyl;	POP	BC		; Get # cyls back in B	LD	A,(IY+8)	; Get DCT+8	RLCA			; Move grans/cyl into	RLCA			;   bits 0-2	RLCA	AND	07H		; Mask off other stuff	INC	A		; A = grans per cyl	BIT	5,(IY+4)	; Double bit set?	JR	Z,NOTDUB	; No, don't double	ADD	A,A		; Double grans/cyl;;	A = # grans/cyl, Calc total # grans;NOTDUB	LD	HL,0		; Init HL = 0	PUSH	DE		; Save free grans	LD	D,H	LD	E,B	LD	B,A		; B = grans / cyl;;	Multiply grans/cyl (B) * # cyls (DE);GPCLOOP	ADD	HL,DE		; Add cyl count	DJNZ	GPCLOOP		; Grans/cyl times;;	HL = # grans/disk.  Is this a hard drive?;	BIT	3,(IY+03H)	; Hard drive?	JR	NZ,SKIPLOC	; Yes - don't check lockout;;	Floppy disk - check for locked out cylinders;	LD	B,E		; B = cyl count	EX	DE,HL		; Save total count in DE	LD	HL,GAT+60H	; HL => Lockout table	LD	C,00H		; C = locked out cyl count	PUSH	AF		; Save grans/cyl in A;;	Loop to count up locked out cylinders in C;LKLOOP	LD	A,01H		; Init cyl checker	AND	(HL)		; Locked out?	JR	Z,GOODCYL	; No, good cylinder	INC	C		; Bump locked out countGOODCYL	INC	L		; Bump pointer	DJNZ	LKLOOP		; Loop for # cylinders;;	Multiply cylinders (BC) * Grans/Cyl;	POP	AF		; Get Grans/cyl back	PUSH	AF		;   and save again	LD	H,B		; Init HL = 0	LD	L,B;GTUSED	ADD	HL,BC		; Add cylinder count	DEC	A		; Grans/cyl times	JR	NZ,GTUSED	POP	AF		; Get grans/cyl again;;	Subtract # grans locked out from total;	OR	A		; Clear carry	EX	DE,HL	SBC	HL,DE		; HL = Grans possibleSKIPLOC	POP	DE		; Recover free grans;;	HL = # Grans possible, DE = Grans free;	PUSH	HL		; Save grans used	LD	HL,KFREE	; Convert grans free	CALL	CALCK		;   to ASCII & stuff	POP	DE		;   into string;;	Calculate # of K used & stuff into header;	LD	HL,KPOSS	; Pt to where to stuff	CALL	CALCK		; Calculate K & stuff;;	Transfer diskette name into string buffer;	LD	HL,GAT+0D0H	; Point to diskette name	LD	DE,NAME		; Move pack name -> header	LD	C,8		; 8 chars to move	LDIR;;	Clear out date buffer;	LD	DE,DATBUF	; DE => start of buffer	LD	A,' '		; Space	LD	B,9		; 9 chars to clearCLRLP	LD	(DE),A		; Stuff in space	INC	DE		; Bump pointer	DJNZ	CLRLP		; Loop;;	HL => Date in mm/dd/yy format - get month;	LD	A,(HL)		; Get month	SUB	'0'		; Convert 10s to binary	LD	C,A		; Save it in C;;	Multiply 1st digit of month by 10;	ADD	A,A		; * 2	ADD	A,A		; * 4	ADD	A,C		; * 5	ADD	A,A		; * 10	LD	C,A		; Stuff in C;;	Pick up 2nd digit of month & add to 10s;	INC	HL		; Bump ptr to ones digit	LD	A,(HL)		; Get ones digit of month	SUB	'1'		; Convert to binary	ADD	A,C		; A = month (0-11)	CP	12		; Legal month?	JR	NC,ILLDATE	; Abort if illegal date;;	Legal Month - Mult by 3 + pt to month string;	LD	C,A		; Xfer month to C	ADD	A,A		; * 2	ADD	A,C		; * 3	LD	C,A		; BC = offset	PUSH	HL		; Save data pointer	LD	HL,MONTBL$	; Point to system month table	ADD	HL,BC		; HL => Month string;;	HL => Month string, stuff into buffer;	LD	A,'-'	LD	DE,DATBUF+3	; DE => Destination	LD	C,03H		; 3 chars to xfer	LDIR			; Do so	LD	(DE),A		; Store dash in buffer;;	Transfer day (00-31) into date buffer;	POP	HL		; Get pointer back	INC	HL		; Bump it to day	INC	HL		; HL => day of month	LD	DE,DATBUF	; DE => destination	LD	C,02H		; 2 chars	LDIR			; Move them	LD	(DE),A		; Stuff dash in again;;	Transfer year into buffer;	INC	HL		; Inc past "/"	LD	C,02H		; 2 chars to move again	LD	DE,DATBUF+7	LDIR			; Move into buffer;;	Display the files in the directory;	Init DIR rec ptr = mem start, count = 0;ILLDATE	LD	A,D		; Set flag	LD	(FILFLAG),A	; Set file alr disp flag	LD	HL,MEMORY	; Init dirptr to start	LD	(DIRPTR),HL	;   of available memory	XOR	A		; Set file display	SBC	HL,HL		; Set HL=0	LD	(TFILES+1),HL	; Total files = 0	LD	(COUNT+1),HL	; Count = 0	LD	(TOTGRNS+1),HL	; Total grans = 0;;	Read in the HIT of the disk;	POP	BC		; Get drive # back in C	LD	D,(IY+9)	; Get dir cyl to D	LD	E,01H		; HIT is sector 1	LD	HL,GAT		; HL => sector buffer	@@RDSSC			; Read system sector	LD	A,16H		; "Hit read error"	JP	NZ,IOERR	; Jump if read error	CALL	CKPAWS		; Break hit?$JP0	JP	CKHIT5		; Jump into middle of loop;;	Loop to process HIT entries;CKHIT	POP	HLCKHIT1	POP	BC		; Recover HIT ptr lo;;	Point HL to last HIT entry;	LD	H,HIT<-8	; Set H = high byte of HIT	LD	L,B		; HL => Last HIT entry;;	Positition to next entry of the record;CKHIT2	LD	A,L		; Get current entry	ADD	A,32		; Add 32 (bytes/entry)	LD	L,A		; HL => Next entry	JR	NC,$JP0		; Go to next record?;;	Position to entry zero of next record;	INC	L		; Posn to next record	BIT	5,L		; Done with drive?	JR	Z,$JP0		; No - process entry;;	Finished with drive - sort data unless (O=N);	LD	A,(SORTPRM+1)	; If sort requested	OR	A		;   then need to output	CALL	NZ,SORTIT	;   the sorted data;;	Were there any files displayed?;	LD	HL,(COUNT+1)	; Get displayed file count	LD	A,H		; Any there?	OR	L	JR	NZ,FILES	; Yes, dsp under if (A);;	Display title & line feed;		LD	HL,DSTRING	; HL => Title	CALL	LINOUT		; Display it	CALL	CKPAGE		; Check for scroll	JR	NOTAP		; Get next drive;;	Get next drive # if the A parm was specified;FILES	LD	A,(APARM+1)	; Don't display if A	OR	A	JR	Z,NOTAP		; Not A, output CR;;	Were there any files shown in directory?;COUNT	LD	HL,0		; Get count	LD	A,H		; Any files shown?	OR	L	JR	Z,TERMDRV	; No - get next drive;;	 Display line of equals signs ("=");	LD	B,79		; Do 79 of themD79EQ	LD	A,'='		; char	CALL	BYTOUT		; Display it	DJNZ	D79EQ		; Loop for the line;;	End of line & check for scroll;	CALL	CR_OUT		; Output a CR & check page;;	Stuff # of files used into footer string;	PUSH	BC		; Save drive #	LD	B,3		; 3 spaces in buffer	LD	DE,FDISP	; Destination	@@HDEC			; Convert to ASCII;;;TFILES	LD	HL,$-$		; Get total files used	LD	DE,FUSED	; Destination	LD	B,3		; 3 bytes	@@HDEC;;	Get total # of grans & stuff into string;TOTGRNS	LD	DE,$-$		; Get total grans	LD	HL,SPUSED	; HL => destination	CALL	CALCK		; Stuff into string	LD	B,13H	CALL	SPCTAB		; Output 19 spaces	POP	BC		; C = drive;;	Display footer string;	LD	HL,FDISP	CALL	LINOUT	CALL	CKPAGE	CALL	CKPAGE	JR	TERMDRV		; Get next drive;;	A parm not spec'd - was  a header displayed?;NOTAP	LD	A,(FILFLAG)	; Was it?	OR	A	JR	NZ,TERMDRV	; No - get next drive;;	Output a C/R if full line wasn't displayed;	LD	A,(DONAM9+1)	; Full line?	CP	04H	CALL	NZ,ENDLINE	; End line	CALL	ENDLINE		; do a blank line;;	Position to next drive, or exit if finished;TERMDRV	LD	A,00H		; Get term drive	INC	C		; Bump current drive	CP	C		; Done?JPDIR4	JP	NC,DIR4		; Loop if in range	JP	EXIT		; Else exit;;	Get next drive unless drivespec specified;CKHIT4	POP	BC		; Get drive into CSPECIF	LD	A,00H		; Get specific flag	OR	A	LD	HL,0		; Init in case exit	RET	Z		; Not global;;	Bump drive number;	LD	A,(TERMDRV+1)	; Get term drive #	INC	C		; Increment curr drive	CP	C		; Finished?	JR	NC,JPDIR4	; Loop if more	RET			;   else return;;	Is the HIT entry in use?;CKHIT5	LD	A,(HL)		; Get HIT entry	OR	A		; In use?	JP	Z,CKHIT2	; No - get next entry;;	HIT entry in use - point HL to that entry;	LD	B,L		; Save DEC in B	PUSH	BC		;   and to stack	LD	A,L		; Point L to entry posn	AND	0E0H	LD	L,A;;	Do we need to read in another sector?;	XOR	B		; Done with 8 entries?CKHIT6	CP	0FFH	JR	Z,CKDIR1	; No - check out entry;;	Read in the next directory sector;	LD	(CKHIT6+1),A	; Stuff in last entry position	@@DIRRD	JP	NZ,IOERR	; Jump on read error	LD	A,H		; Get high byte	LD	(CKDIR1+1),A	;   and save it	LD	(SBUFFER+1),A	;   for later;;	Valid file (Alive and FPDE) ?;CKDIR1	LD	H,00H		; Get high byte	BIT	4,(HL)		; Alive?	JP	Z,CKHIT1	; No - get next entry	BIT	7,(HL)		; FPDE?	JP	NZ,CKHIT1	; No - next entry;;	Alive FPDE - Bump total file counter;	PUSH	HL		; Save ptr	LD	HL,(TFILES+1)	; Point to total files	INC	HL		; Increment it	LD	(TFILES+1),HL	POP	HL;;	Is this a SYStem file?;	BIT	6,(HL)		; SYS file?	JR	Z,CKDIR3	; No, continue;;	SYS file - don't check unless S param entered;SPARM	LD	DE,$-$		; Get S param	LD	A,D		; Specified?	OR	E	JP	Z,CKHIT1	; No - don't check it	JR	CKMOD		; Skip INV check;;	Non-SYS file - is the file visible?;CKDIR3	BIT	3,(HL)		; Check visibility	JR	Z,CKMOD		; Yes, skip I check;;	File is invisible - Was INV (I) specified?;IPARM	LD	DE,$-$		; Get I parameter	LD	A,D	OR	E	JP	Z,CKHIT1	; Ignore if not specified;;	Was the MOD param entered?;CKMOD	LD	DE,$-$		; Get MOD param	LD	A,D	OR	E	JR	Z,CKNAM		; Go if MOD not entered;;	MOD param entered - was this file modified?;	INC	L		; HL => DIR + 1	BIT	6,(HL)		; Check MOD flag	JP	Z,CKHIT1	; No - get next entry	DEC	L		; Adjust back to start;;	Attributes match - check if filespec matches;CKNAM	PUSH	HL		; Save ptr to record	LD	A,L		; Pt to filename in dir	ADD	A,05H	LD	L,A		; HL => filename	LD	DE,BLANKS	LD	B,11		; Ck name/ext (11 chars);;	Loop to check if partspec matches dir name;CKNAM1	LD	A,(DE)		; Get partspec	CP	'$'		; Wild char?	JR	Z,CKNAM2	; Yes - match;;	Does directory char match partspec char?;	CP	(HL)		; Not global - char match?	JR	Z,CKNAM2	; Check more if match;;	Chars don't match - DIR char a space?;	CP	' '		; Blank = end of check	JR	NZ,MFLG		; If not blank, no match;;	Bump Dir & partspec ptr & continue loop;CKNAM2	INC	HL		; Bump pointers	INC	DE	DJNZ	CKNAM1		; Loop for 11 chars;;	Entries match - was the "-" exclude given?;	LD	A,(MFLG+1)	; Get flag	CP	'-'		; Exclude given?	JR	CK2HIT		; Yes - get next entry;;	Entries don't match - was exclude given?;MFLG	LD	A,00H		; Get exclude flag	OR	A		; If no exclude givenCK2HIT	JP	Z,CKHIT		;   then get next entry;;	Recover DIR+0 pointer;CKNAM2A	POP	HL		; Recover ptr to DIR+0	PUSH	HL		; Save it again;;	Unpack date of directory entry;	INC	HL	CALL	UNPACK		; Unpack date;;	Use dates before user specified date?;	LD	A,(FTFLG)	; Grab From/To flag	RLCA			; Test from bit	JR	NC,CKNAM2B	; No - check TO;;	FROM flag set - does file have a date?;	LD	A,D		; Ignore if no date	OR	E		;   in DIR for file	JP	Z,CKHIT;;	Is the specified date >= the files date?;	LD	HL,(FMPAKD)	; Get user date entry	EX	DE,HL	CALL	CPHLDE		; Compare HL to DE	EX	DE,HL		; File date < user date?	JR	C,$JP1		; Yes - get next entry;;	Use dates after user specified date?;CKNAM2B	LD	A,(FTFLG)	; Get FROM/TO flag again	RRCA			; Test the TO bit	JR	NC,SORTPRM	; Go if no TO param;;	TO flag set - does the file have a date?;	LD	A,D		; Check for valid date	OR	E	JP	Z,CKHIT		; No - get next entry;;	File has a date - is specified date less?;	LD	HL,(TOPAKD)	; Get user's packed date	CALL	CPHLDE		; User date < file date?$JP1	JP	C,CKHIT		; Yes - get next entry;;	Was the sort parameter turned off?;SORTPRM	LD	DE,-1		; Get default param	POP	HL		; HL => DIR+0	LD	A,D		; Default to SORT=ON	OR	E	JR	Z,DODSP		; Go display if no sort;;	SORT = ON --- Calculate allocation & extents;	PUSH	HL		; Save DIR+0 pointer	CALL	ALL09A		; Calc alloc & extents	POP	HL		; Recover DIR+0 pointer;;	Overwrite FPDE's 22-25 with # grans & # extents;	PUSH	HL		; Point IX to DIR+22	POP	IX	LD	(IX+22),E	; Stuff in # grans	LD	(IX+23),D	LD	(IX+24),C	; Stuff in # extents	LD	(IX+25),B;;	Transfer record into memory for sort;	LD	DE,(DIRPTR)	; Get last used mem addr	PUSH	HL		; save current DIR ptr	LD	BC,32		; Move record into buffer	LDIR	LD	(DIRPTR),DE	; Update last mem used ptr;;	Is there an overflow of available memory?;	LD	HL,(MAXMEM)	; Get approx hi-mem	SBC	HL,DE		; Did it overflow?	JP	NC,CKHIT	; No - get next entry	JP	NOMEM		; Insuff mem for sort buf;;	Display a filename;DODSP	CALL	MATCH		; Display entry	JP	CKHIT1		; Loop to next dir entry;	END