;LBSETCOM/ASM - Set RS232 Parameters	TITLE	<SETCOM - LS-DOS 6.3>;;	Data area offsets;OFFSET	EQU	4MSMASK	EQU	OFFSET+0UCIMAGE	EQU	OFFSET+1BAUDRT	EQU	OFFSET+2BRK	EQU	OFFSET+3;;	Default Settings;DEFMS	EQU	000HDEFUC	EQU	0A5HDEFBA	EQU	055HDEFBR	EQU	003H;;	ASCII / Init equates;_INIT	EQU	02H		; Ctl value to init driver_ETX	EQU	03H_CR	EQU	0DH_LF	EQU	0AH_APOS	EQU	27H;PAR_ERR	EQU	44		; Parameter error;;	@PARAM evaluation types;NUM	EQU	80H		; Numeric parameterFLAG	EQU	40H		; Flag parameterSTR	EQU	20H		; String parameterABB	EQU	10H		; Abbreviations allowed;*GET	SVCEQU			; System SVC equates;	ORG	2400H;BEGIN	LD	(SAVESP+1),SP	; Save entry stack	CALL	PGRM		; Perform operation	LD	HL,0		; Set no errorSAVESP	LD	SP,0		; Recover stack ptr	LD	A,@CKBRKC	; Clear break flag	RST	28H	RET			; Exit;;	abort program;$ABORT	LD	HL,-1		; Set error code	JR	SAVESP		;   and get out;;	Display char in C;$DSP	LD	A,@DSP	RST	28H	RET	Z		; Return if no error	JR	IOERR		;   else show error;;	Display text at (HL);$DSPLY	LD	A,@DSPLY	RST	28H	RET	Z		; Return if no error;;	I/O Error - display what;IOERR	LD	L,A		; Save error code	OR	0C0H		; Set ret and short msg	LD	C,A	LD	A,@ERROR	; Display error	RST	28HERROR$	LD	H,0	JR	SAVESP		; Exit;;	Module not found;BADMOD	LD	HL,BADDCB	; COM/DVR not installed	LD	A,@LOGOT	RST	28H	LD	L,08H		; 'Device not avail...'	JR	ERROR$		; return error in HL;;	Parameter Error;PRMERR	LD	A,PAR_ERR	JP	IOERR;;	PGRM - Set up RS-232 Parameters;PGRM	EQU	$;	IF	@MOD4	PUSH	HL		; Save cmd line pointer	LD	DE,MDNAME	; $CL name header	LD	A,@GTMOD	; Find module header	RST	28H	JR	NZ,BADMOD	; Exit if not found	PUSH	DE		; Move pointer to IX	POP	IX		; IX => next byte after	POP	HL		; Recover cmd line ptr	ENDIF;;	Check if any parameters entered;	DEC	HL		; Setup for immed incSPLP	INC	HL		; Bump to next char	LD	A,(HL)		; Fetch character	CP	' '		; Space?	JR	Z,SPLP		; Ignore spaces	CP	'('		; Start of params?	JP	NZ,SHOW		; No - show settings;	LD	DE,PRMTBL$	; Parameter table	LD	A,@PARAM	; Parse params	RST	28H	JP	NZ,PRMERR	; Go if parameter error;	IF	@MOD2	LD	A,(PORTP)	; Get port param	OR	A		; Anything input?	LD	DE,MDNAME1	; $CL	JR	Z,PORTF		; Go default	LD	BC,(PORTD)	; Get port value	INC	B		; Test MSB	DEC	B	JR	NZ,PRMERR	; Prm error if > 256	LD	A,C		; Get LSB	OR	A		; Is it 0?	JR	Z,PRMERR	; Error if zero	DEC	A		; 1?	JR	Z,PORTF		; Yes, $CL	DEC	A		; 2?	JR	NZ,PRMERR	; Param error if not	LD	DE,MDNAME2	; $CMPORTF	LD	A,@GTMOD	; Locate module	RST	28H	JR	NZ,BADMOD	; Go if not found	PUSH	DE		;   else move the	POP	IX		;   pointer to IX	ENDIF;;	Check if DEFAULT parameter entered;	LD	DE,(DFPARM)	; Check D param	LD	A,D		; Set??	OR	E	CALL	NZ,DEFALT	; Go if DEFAULT used;	LD	DE,(QPARM)	; QUERY param used?	LD	A,D	OR	E	JP	Z,CKPARM	; Check input if not query;;	Prompt user for input not entered on command line;;	Fetch BAUD rate;ASKBAUD	LD	HL,DMSG2	; BAUD param display	LD	DE,BTYP		; BAUD param	CALL	GETIT		; Get user input	JR	NC,ASKWORD	; Continue on enter	CALL	CKBAUD		; Check if valid response	JR	Z,ASKWORD	; Move on if validBADBAUD	XOR	A		;   else clear	LD	(BRESP),A	;   for re-try	JR	ASKBAUD;;	Fetch WORD length;ASKWORD	LD	HL,DMSG3	; WORD display	LD	DE,WTYP		; Param type	CALL	GETIT		; Get user input	JR	NC,ASKSTOP	; Nil entry, leave it	LD	A,(WORDP)	; Fetch input	CP	05H		; Less than 5?	JR	C,BADWORD	; Bad entry	CP	09H		; More than 8?	JR	C,ASKSTOP	; Bad entryBADWORD	XOR	A		; Clear param	LD	(WRESP),A	; Load flag	JR	ASKWORD;;	Fetch STOP bits;ASKSTOP	LD	HL,DMSG4	; STOP display	LD	DE,STYP		; Type byte	CALL	GETIT		; Get user input	JR	NC,ASKPAR	; Nil, leave it	LD	A,(STOPP)	; Check range	OR	A		; Zero?	JR	Z,BADSTOP	; Invalid if yes	CP	2+1		; More than two?	JR	C,ASKPAR	; Go if okayBADSTOP	XOR	A	LD	(SRESP),A	; Clear input param	JR	ASKSTOP		; Loop back;;	Fetch PARITY;BADPAR	XOR	A		; Load zero	LD	(PRESP),A	; Clear response byteASKPAR	LD	HL,DMSG5	; Parity display	LD	DE,PTYP		; Param type	CALL	GETIT		; Get user input	JR	NC,ASKBRK	; Nil input, leave;;	Check if user entered 'O', or 'E' or ON/OFF;	LD	A,(PRESP)	; Get response byte	LD	DE,(PARITYP)	; Get param pointer	BIT	6,A		; Switch?	JR	NZ,ASKBRK	; Yes, continue;;	Check for ODD/EVEN input;	LD	A,(DE)		; Get input	CALL	UCASE		; Force to upper case	CP	'E'		; 'E'ven parity?	JR	Z,ASKBRK	; Continue if yes	CP	'O'		; 'O'dd parity?	JR	NZ,BADPAR	; Invalid, re-prompt;;	Fetch BREAK;ASKBRK	LD	HL,DMSG6	; BREAK display	LD	DE,BRTYP	; Param type	CALL	GETIT		; Get user input;;	Fetch DTR;ASKDTR	LD	HL,DMSG8	; Display Driver	LD	DE,DTYP		; Param type	CALL	GETIT		; Get user input;;	Fetch RTS;ASKRTS	LD	HL,DMSG9	LD	DE,RTYP	CALL	GETIT;;	Fetch RI;ASKRI	LD	HL,DMSG11	LD	DE,RITYP	CALL	GETIT;;	Fetch DSR;ASKDSR	LD	HL,DMSG12	LD	DE,DSTYP	CALL	GETIT;;	Fetch CD;ASKCD	LD	HL,DMSG13	LD	DE,CDTYP	CALL	GETIT;;	Fetch CTS;ASKCTS	LD	HL,DMSG14	LD	DE,CTTYP	CALL	GETIT;;	Check param and issue INIT to device;CKPARM	CALL	SETPARAM	; Check entered parameters	LD	E,(IX+00H)	; Pick up DCB address	LD	D,(IX+01H)	LD	C,_INIT		; Init code	LD	A,@CTL		; Setup channel for values	RST	28H	RET			; Completed;;	Display drivers for text;DMSG1	LD	HL,MSG1		; RS232 Params:	CALL	$DSPLY		; Display and return	LD	(HL),_LF	RET;DMSG2	LD	HL,MSG2		; BAUD=	CALL	$DSPLY		; Display	LD	A,(IX+BAUDRT)	; Get baud rate	AND	0FH		; Lower 4 bits only	ADD	A,A		; Times two	LD	HL,BAUDTBL	; Baud lookup table	ADD	A,L		; Add to LSB	LD	L,A		;   and update ptr	JR	NC,DMSG2A	; Go if no page cross	INC	H		;   else bump hi orderDMSG2A	LD	A,(HL)		; Get baud LSB	INC	HL		; bump ptr	LD	H,(HL)		; Get baud MSB	LD	L,A		; HL = Baud rate	LD	DE,MSG20	; Text to load	LD	A,@HEXDEC	; Convert to decimal	RST	28H	LD	A,_ETX		; End of text	LD	(DE),A		; Store it;;	Strip leading zeros from display;	LD	HL,MSG20	; Text loaded	LD	A,' '		; Test charSTRIP1	CP	(HL)		; Leading zero?	INC	HL		; Bump pointer	JR	Z,STRIP1	; Loop until non space	DEC	HL		; Adjust pointer	JP	$DSPLY		; Display remainder;DMSG3	LD	HL,MSG3		; WORD=	CALL	$DSPLY	LD	A,(IX+UCIMAGE)	; Get data	RLCA	RLCA	RLCA	AND	03H		; 2 bits only	JP	PE,MSG3A	; Go if set	XOR	03H		; Else reverse 6/7MSG3A	ADD	A,5+'0'		; Correct + ASCII	LD	C,A		; Pass character	JP	$DSP		; Display and return;DMSG4	LD	HL,MSG4		; STOP=	CALL	$DSPLY		; Display header	LD	C,'1'		; Set one bit	BIT	4,(IX+UCIMAGE)	; Get data	JR	Z,DMSG4A	; Go if 1 stop	INC	C		; Else show 2DMSG4A	JP	$DSP		; Display and return;DMSG5	LD	HL,MSG5		; PARITY=	CALL	$DSPLY	LD	HL,MSG16	; OFF	BIT	3,(IX+UCIMAGE)	; Is it off?	JP	NZ,$DSPLY	; Go if it is	LD	HL,MSG17	; ODD	BIT	7,(IX+UCIMAGE)	; Is it odd?	JR	Z,DMSG5A	; Go if it is	LD	HL,MSG18	;  else it's evenDMSG5A	JP	$DSPLY		; Display and return;DMSG6	LD	HL,MSG6		; BREAK=	CALL	$DSPLY		; Display header	LD	C,(IX+BRK)	; Get break char	LD	HL,MSG21A	; Text to load	LD	A,@HEX8		; Convert to ASCII	RST	28H	LD	HL,MSG21	; Text start	JP	$DSPLY		; Display and return;DMSG7	LD	HL,MSG7		; Text start	JP	$DSPLY		; Display and return;DMSG8	LD	HL,MSG8	CALL	$DSPLY		; Display	BIT	1,(IX+UCIMAGE)	; Is on?	JR	DMSG89;DMSG9	LD	HL,MSG9		; RTS=	CALL	$DSPLY		; Display and return	BIT	0,(IX+UCIMAGE)	; Is on?;DMSG89	LD	HL,MSG15	; ON	JR	Z,DMSG89A	LD	HL,MSG16	; OFFDMSG89A	JP	$DSPLY		; Display and return;DMSG10	LD	HL,MSG10	; Output:	JP	$DSPLY		; Display and return;DMSG11	LD	HL,MSG11	; RI=	LD	A,00010001B	; Enable bits	JR	DMSG0		; Go common;DMSG12	LD	HL,MSG12	; DSR=	LD	A,01000100B	; Enable bits	JR	DMSG0		; Go common;DMSG13	LD	HL,MSG13	; CD=	LD	A,00100010B	; Enable bits	JR	DMSG0		; Go common;DMSG14	LD	HL,MSG14	; CTS=	LD	A,10001000B	; Enable bits;DMSG0	PUSH	AF		; Save bits	CALL	$DSPLY		; Display prefix	POP	AF		; Restore bits	AND	(IX+MSMASK)	; AND with mask	LD	HL,MSG19	; IGNORE	JR	Z,DMSG0X	; Go if yes	LD	HL,MSG15	; ON	JP	PO,DMSG0X	; Go if yes	LD	HL,MSG16	; OFFDMSG0X	JP	$DSPLY		; Display and return;DMSG22	LD	HL,MSG22	; CR	JP	$DSPLY		; Display and return;DMSG23	LD	HL,MSG23	; ', '	JP	$DSPLY		; Display and return;;	Display entire parameter set;DSPALL	PUSH	IY		; Save	LD	IY,DSPTBLDSPSET	LD	L,(IY+00H)	; Get LSB vector	LD	H,(IY+01H)	; Get MSB vector	LD	A,H		; Check for term	OR	L		; HL = 0?	JR	Z,DSPDONE	; Yes, go	PUSH	HL		; Save address	LD	HL,DSPRET	; Return vector	EX	(SP),HL		; Leave return, get vector	JP	(HL)		; DisplayDSPRET	INC	IY		; Bump table	INC	IY	JR	DSPSET		; ContinueDSPDONE	POP	IY		; Restore	RET			; Display complete;;	Query for parameter;GETIT	PUSH	HL		; Save display driver	PUSH	DE		; Save type byte	EX	DE,HL		; Type byte to HL	CALL	CKRSP		; Check if response entered	POP	DE		; Get type byte back	POP	HL		; Restore prompt	RET	NZ		; Already have this one;;	Setup for prompt display;	PUSH	HL		; Save for repeat prompt	PUSH	DE	CALL	GETRSP		; Get user response	POP	DE		; Restore data	POP	HL	JR	NZ,GETIT	; Invalid - get again	RET			; Else param loaded;;	Check if correct response entered;CKRSP	LD	(TTYP),HL	; Save type position;MVUP	LD	A,0FH		; Low 4 bits for length	LD	C,(HL)		; Get type byte	AND	C		; Fetch lengthUP	INC	HL		; Bump pointer	DEC	A		; Less length	JR	NZ,UP		; Go for length	INC	HL		; Bump to next	LD	A,(HL)		; Get response byte	AND	NUM!FLAG!STR	; Response type bits	AND	C		; Compare to entered	RET			; Return with status;;	Query on, param not entered, prompt for it;GETRSP	PUSH	HL		; Save driver address	LD	HL,GETRSPR	; Return vector	EX	(SP),HL		; Leave get display driver	JP	(HL)		; Display prompt;GETRSPR	LD	B,04H		; Command get cursor	LD	A,@VDCTL	; Fetch cursor	RST	28H	LD	L,20		; Column to position to	LD	B,03H		; Command set cursor	LD	A,@VDCTL	; Move cursor	RST	28H	LD	HL,PROMPT	; Prompt text	CALL	$DSPLY		; Display it	XOR	A		; Load zero	LD	(FRESP),A	; Clear response byte;	LD	HL,INBUF	; Key input buffer	LD	BC,10<8+0	; Max input length	LD	A,@KEYIN	; Get user input	RST	28H	JP	C,$ABORT	; Terminate on BREAK;;	Evaluate user input;	INC	B		; Check if nil input	DEC	B		; b=0?	RET	Z		; No input, go;	LD	HL,0		; Get param pointerTTYP	EQU	$-2	LD	A,(HL)		; Get response type	AND	0F0H		; Attribute only	OR	01H		; Single byte char	LD	(FTYP),A	; Pass to new block;	LD	HL,FSTR		; Set command pointer	LD	DE,PTBL2	; Mini-param table	LD	A,@PARAM	; Evaluate it	RST	28H	RET	NZ		; Exit if invalid;	LD	HL,(TTYP)	; Get response pointer	CALL	MVUP		; Move to response byte	LD	A,(FRESP)	; Get input response	LD	(HL),A		; To param block	INC	HL		; Bump to word pointer	CALL	GETHL		; Get pointer	LD	BC,(FPARM)	; Get temp param	LD	(HL),C		; Load into param block	INC	HL	LD	(HL),B		; New param loaded	XOR	A		; Set no error	SCF			; Carry flag = input	RET			; Done;;	Init default settings;DEFALT	LD	(IX+MSMASK),DEFMS	LD	(IX+UCIMAGE),DEFUC	LD	(IX+BAUDRT),DEFBA	LD	(IX+BRK),DEFBR	RET;;	Text area;	IF	@MOD4MDNAME	DB	'$CL'	DB	_ETX	ENDIF;	IF	@MOD2MDNAME1	DB	'$CL'	DB	_ETXMDNAME2	DB	'$CM'	DB	_ETX	ENDIF;BADDCB	DB	'COM/DVR not installed',_CRPROMPT	DB	'? ',_ETX;BAUDTBL	DW	50,75,110,135,150,300,600,1200,1800	DW	2000,2400,3600,4800,7200,9600,19200;;	Display driver lookup table;DSPTBL	DW	DMSG1,DMSG2,DMSG23,DMSG3	DW	DMSG23,DMSG4,DMSG23,DMSG5	DW	DMSG23,DMSG6,DMSG7,DMSG8	DW	DMSG23,DMSG9,DMSG10,DMSG11	DW	DMSG23,DMSG12,DMSG23,DMSG13	DW	DMSG23,DMSG14,DMSG22,0;BREAKP	DW	0QPARM	DW	0BAUDP	DW	0WORDP	DW	0STOPP	DW	0PARITYP	DW	0EVENP	DW	0ODDP	DW	0DTRP	DW	0RTSP	DW	0RIP	DW	0CDP	DW	0DSRP	DW	0CTSP	DW	0DFPARM	DW	0PORTD	DW	0FPARM	DW	0MSG1	DB	00H		; Will be LF after 1st DSP	DB	'RS232 parameters: ',_ETXMSG2	DB	'Baud=',_ETXMSG3	DB	'Word=',_ETXMSG4	DB	'Stop=',_ETXMSG5	DB	'Parity=',_ETXMSG6	DB	'Break=',_ETXMSG7	DB	0AH,'Output control: ',_ETXMSG8	DB	'DTR=',_ETXMSG9	DB	'RTS=',_ETXMSG10	DB	0AH,'Input control: ',_ETXMSG11	DB	'RI=',_ETXMSG12	DB	'DSR=',_ETXMSG13	DB	'CD=',_ETXMSG14	DB	'CTS=',_ETXMSG15	DB	'ON',_ETXMSG16	DB	'OFF',_ETXMSG17	DB	'ODD',_ETXMSG18	DB	'EVEN',_ETXMSG19	DB	'IGNORE',_ETXMSG20	DB	'00000',_ETXMSG21	DB	'X',27HMSG21A	DB	'00',27H,_ETXMSG22	DB	_CRMSG23	DB	', ',_ETX;;	Parameter Table;PRMTBL$	DB	80HBRTYP	DB	FLAG!NUM!5,'BREAK'BRRESP	DB	00H	DW	BREAKP;	DB	FLAG!ABB!5,'QUERY'QRESP	DB	00H	DW	QPARM;BTYP	DB	NUM!ABB!4,'BAUD'BRESP	DB	00H	DW	BAUDP;WTYP	DB	NUM!ABB!4,'WORD'WRESP	DB	00H	DW	WORDP;STYP	DB	NUM!ABB!4,'STOP'SRESP	DB	00H	DW	STOPP;PTYP	DB	STR!FLAG!ABB!6,'PARITY'PRESP	DB	00H	DW	PARITYP;ETYP	DB	FLAG!ABB!4,'EVEN'ERESP	DB	00H	DW	EVENP;OTYP	DB	FLAG!ABB!3,'ODD'ORESP	DB	00H	DW	ODDP;DTYP	DB	FLAG!3,'DTR'DTRESP	DB	00H	DW	DTRP;RTYP	DB	FLAG!3,'RTS'RTRESP	DB	00H	DW	RTSP;RITYP	DB	FLAG!2,'RI'RIRESP	DB	00H	DW	RIP;CDTYP	DB	FLAG!2,'CD'CDRESP	DB	00H	DW	CDP;DSTYP	DB	FLAG!3,'DSR'DSRESP	DB	00H	DW	DSRP;CTTYP	DB	FLAG!3,'CTS'CTRESP	DB	00H	DW	CTSP;	DB	FLAG!ABB!7,'DEFAULT'	DB	00H	DW	DFPARM;	DB	00H		; End of table;;	Evaluate and setup user parameters;SETPARAM	LD	HL,PRMERR	; Param error exit vector	PUSH	HL		; Leave for quick exit;;	Evaluate BAUD;SETBAUD	LD	A,(BRESP)	; Get baud response	OR	A		; Anything?	JR	Z,SETWORD	; Nope, go	CALL	CKBAUD		; Get baud setting	RET	NZ		; Go if error	LD	(IX+BAUDRT),A	;   else save new baud;;	Evaluate WORD;SETWORD	LD	C,(IX+UCIMAGE)	; Get current setting	LD	A,(WRESP)	; Get word response	OR	A		; Anything?	JR	Z,SETSTOP	; Nope, continue	LD	DE,(WORDP)	; Get parameter	INC	D		; Check MSB	DEC	D		; D <> 0?	RET	NZ		; > 256?	LD	A,E		; Get LSB	SUB	05H		; Adjust to zero relative	RET	C		; Go if out of range	CP	04H		; 5-8?	RET	NC		; Go if out of range	OR	A		; Clear carry, set PV	JP	PE,SETWRD0	; Go if 5/8	XOR	03H		; Change 6/7/6SETWRD0	RRCA			; Align to bits 5/6	RRCA	RRCA	LD	B,01100000B	; For bit setup	CALL	SETBITS		; Setup in C register;;	Evaulate STOP;SETSTOP	LD	A,(SRESP)	; Get STOP response byte	OR	A		; Anything?	JR	Z,SETPAR	; No, continue	LD	DE,(STOPP)	; Get input	INC	D		; Check for out of range	DEC	D	RET	NZ	LD	A,E		; Get LSB	OR	A		; 0?	RET	Z		; Invalid if it is	CP	03H		; 1 or 2?	RET	NC		; Invalid if not	DEC	A		; Convert 1/2 to 0/1	RLCA			; Align result	RLCA	RLCA	RLCA	LD	B,00010000B	; Init mask bits	CALL	SETBITS		; Setup in C register;;	Evaluate parity;SETPAR	LD	A,(PRESP)	; Get parity response	OR	A		; Anything?	JR	Z,SETPEO	; Nope, check EVEN/ODD;;	Check if input was string or switch;	LD	DE,(PARITYP)	; Get user pointer	BIT	6,A		; Switch?	JR	NZ,SETPOF	; Yes, set ON/OFF;;	Response was string, check 'E'/'O';	LD	A,(DE)		; Get input	CALL	UCASE		; Convert to upper	CP	'O'		; Odd?	JR	Z,SETPO		; Yes, go	CP	'E'		; Even?	RET	NZ		; Return if neither	SET	7,C		; Set even parity	JR	SETPAEO		; ContinueSETPO	RES	7,C		; Set ODD paritySETPAEO	RES	3,C		; Set ON parity	JR	SETBRK;;	Response was switch, check ON/OFF;SETPOF	LD	A,D		; Check input	OR	E		; Was it 0000?	SET	3,C		; Set off	JR	Z,SETBRK	; Continue if yes	RES	3,C		; Else set ON;;	Check for ODD/EVEN params;SETPEO	LD	A,(ORESP)	; Get ODD response	OR	A		; Set?	JR	Z,SETPAE	; No, check EVEN	LD	DE,(ODDP)	; Get user input	LD	A,D		; Check for nil	OR	E		; DE = 0?	SET	7,C		; ODD = off	JR	Z,SETPAE	; Go if so	RES	7,C		; ODD = on;SETPAE	LD	A,(ERESP)	; Get even response	OR	A		; Set?	JR	Z,SETBRK	; Continue if not	LD	DE,(EVENP)	; Get param	LD	A,D		; Test input	OR	E	RES	7,C		; EVEN=off	JR	Z,SETBRK	; Go if done	SET	7,C		; EVEN=on;;	Evaluate BREAK;SETBRK	LD	A,(BRRESP)	; Get response	OR	A		; Anything?	JR	Z,SETDTR	; No, continue	LD	DE,(BREAKP)	; Get input	BIT	6,A		; Switch?	JR	NZ,SETBOF	; Yes, check on/off;;	Value entered, check if in range;	INC	D		; MSB must be	DEC	D		;   zero	RET	NZ		; Return if it's not	JR	UPDBRK;;	Switch entered, check if on/off;SETBOF	LD	A,D		; Anything set?	OR	E	LD	E,80H		; Default	JR	Z,UPDBRK	; Go if off	LD	E,03H		; DefaultUPDBRK	LD	(IX+BRK),E	; Update data;;	Evaluate DTR;SETDTR	LD	A,(DTRESP)	; Get user response	OR	A		; Anything?	JR	Z,SETRTS	LD	DE,(DTRP)	; Get user value	LD	A,D		; Check if anything	OR	E	SET	1,C		; Set OFF	JR	Z,SETRTS	; Continue if OFF	RES	1,C		;   else Set ON;;	Evaluate RTS;SETRTS	LD	A,(RTRESP)	; Get RTS response	OR	A		; Anything?	JR	Z,UPDCI		; Continue if none	LD	DE,(RTSP)	; Get value	LD	A,D		; Test setting	OR	E	SET	0,C		; Default to OFF	JR	Z,UPDCI		; Continue if OFF	RES	0,C		;   else set ONUPDCI	SET	2,C		; Enable transmit	LD	(IX+UCIMAGE),C	; Update new data;;	Evaluate RI;SETRI	LD	HL,RIRESP	; Response byte	LD	C,01H		; Bit to set	CALL	SETIT		; Setup data;;	Evaluate DSR;SETDSR	LD	HL,DSRESP	; Response byte	LD	C,04H		; Bit to set	CALL	SETIT		; Setup data;;	Evaluate CD;SETCD	LD	HL,CDRESP	; Response byte	LD	C,02H		; Bit to set	CALL	SETIT		; Setup data;;	Evaluate CTS;SETCTS	LD	HL,CTRESP	; Response byte	LD	C,08H		; Bit to set	CALL	SETIT		; Setup data;;	Evaluation complete;	POP	AF		; Remove param error vector	RET			; Return from evaluate;;;SETIT	INC	(HL)		; Any reponse?	DEC	(HL)		; (HL) = Zero?	RET	Z		; Back if no change	INC	HL		; Point to response data	CALL	GETHL		; Load HL with (HL)	CALL	GETHL		; Get user response	LD	A,C		; Get response data ON	RLCA			; Align to upper 4 bits	RLCA	RLCA	RLCA	OR	C		; Combine	LD	B,A		; Set response data OFF	CPL			; Reverse bits	AND	(IX+MSMASK)	; Drop desired bits	LD	E,A		; Save new mask	LD	A,H		; Check if off	OR	L		; HL = 0?	LD	A,B		; Get OFF bits	JR	Z,SETIT01	; Go if OFF	LD	A,C		; Get ON bitsSETIT01	OR	E		; Combine with remainder	LD	(IX+MSMASK),A	; Update mask	RET			; Done;;	Set bits in C from A using B as a mask;SETBITS	AND	B		; Mask off others	PUSH	AF		; Save data	LD	A,B		; Get mask	CPL			; Reverse for mask off	AND	C		; Remove undesired bits	POP	BC		; B = new bits	OR	B		; Combine	LD	C,A		; Update	RET			; Return;;	Fetch HL from (HL);GETHL	LD	A,(HL)		; Get LSB	INC	HL		; Bump pointer	LD	H,(HL)		; Get MSB	LD	L,A		; Move LSB	RET			; Done;;	Convert char in A to upper case;UCASE	CP	'a'		; In range?	RET	C		; Return if not	CP	'z'+1		; Still in range?	RET	NC		; Go if not	AND	5FH		; Force upper case	RET			; Done;;	Check for valid baud rate entered;CKBAUD	LD	DE,(BAUDP)	; Get baud param	LD	HL,BAUDTBL	; Point to baud table	LD	BC,16<8+0	; B=Count, C=Position;BLOOP	LD	A,(HL)		; Get Baud table LSB	INC	HL		; Bump table	CP	E		; LSB match?	JR	NZ,NOMAT8	; Next entry if not	LD	A,(HL)		; Get Baud table MSB	CP	D		; MSB match?	JR	Z,MATCHB	; Yes, baud found;NOMAT8	INC	HL		; Bump to next entry	INC	C		; Increment count	DJNZ	BLOOP		; Go for table length	RET			; Param error if here;MATCHB	LD	A,C		; Pick up baud rate code	RLCA			; Align to high bits	RLCA	RLCA	RLCA	OR	C		; User for Xmit and Receive	CP	A		; Set Z flag (good value)	RET			; Return;;	Nil parameters entered, display current settings;SHOW	EQU	$	IF	@MOD2	LD	A,-1		; Set NO flag	LD	(SHOWF),A	; Save flag	LD	DE,MDNAME1	; CL1	LD	A,'A'		; Comm A	LD	(MSG1A),A	; To text	CALL	SHOW1		; Display CL1 info	LD	A,-1		; Get flagSHOWF	EQU	$-1	OR	A		; Anything found?	JP	NZ,BADMOD	; Not installed	RET;SHOW1	LD	A,@GTMOD	; Find module	RST	28H	RET	NZ		; Return if not found	LD	(SHOWF),A	; Set flag	PUSH	DE		; Move to IX	POP	IX	ENDIF;	JP	DSPALL		; Display all settings;;	Mini param block for 'query' evaluation;PTBL2	DB	80H		; Ver 6.x param tableFTYP	DB	FLAG!NUM!1H	DB	'F'FRESP	DB	00H	DW	FPARM	DB	00H;;	Text string pass to @param for query evaluation;FSTR	DB	'(F='INBUF	EQU	$		; Keyboard input buffer;	END	BEGIN