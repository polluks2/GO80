; ***************************************************************; * Filename: COMM/ASM						*; * Revision: 06.03.01						*; * Rev Date: 09 Dec 97						*; ***************************************************************; * Communications Program					*; *								*; ***************************************************************;	TITLE	<COMM - LS-DOS 6.3>;BUFFRD	EQU	-1		; Set TrueBREAK	EQU	80H		; Char from keyboardLF	EQU	10CR	EQU	13XOFF	EQU	'S'&1FH		; Control-S;*GET	SVCMAC			; System SVC macros*GET	COPYCOM			; Copyright messages;BASE	EQU	3000H	ORG	BASE;$EXIT	LD	HL,0		; Init no errorQUIT$	LD	SP,$-$		; Get original stackSTACK	EQU	$-2	@@CKBRKC		; Clear break bit	RET;$ABORT	LD	HL,-1		; Set abort code	JR	QUIT$;$OPEN	PUSH	HL	LD	HL,$-$		; Address of SFLAG$SFLG	EQU	$-2	SET	0,(HL)		; Set open inhibit bit	POP	HL	@@OPEN	RET;$ERROR	PUSH	BC	OR	0C0H		; Set short, return	LD	C,A		; Err code to C	@@ERROR	POP	BC	RET;MAINLP	LD	A,00H		; Test warning flag set	OR	A		;   by OUTPUT on NEXTAP	JR	Z,ENUFPG	; Go if > 2K of space	LD	HL,LILPG$	; Display warning	@@DSPLY	LD	A,XOFF		; Schedule a forced PUTXOFFP2	EQU	$-1	LD	(FRCPUT+1),A	XOR	A	LD	(MAINLP+1),A	; Inhibit until next pageENUFPG	LD	IX,KIVCTR	; Get key from buffer if	CALL	PGMGET		;   available	JR	NZ,SENDITFSSW	LD	A,00H		; FS on/off (XMIT File)	OR	A	JR	Z,FSOFF		; Bypass if not xmittingCKFREPG	LD	A,(FREEPG)	; Don't get from file	CP	12		;   if < 3k buffer space	JP	C,FSOFF		; Go if less	LD	DE,FS_FCB	; Get sending FCBFSSWGO	@@GET			; Get a byte to xmit	JR	Z,SENDIT	; Bypass if got byte	CP	1CH		; EOF encountered?	JR	Z,EOFFS		; Bypass if EOF	CALL	$ERROR		;   else show error msgEOFFS	CALL	FS_OFF		; Turn off XMIT	JP	SKIPREC		;   and ignore this round;SENDIT	LD	C,A		; Transfer byteXLTS1	CP	00H		; Single character send	JR	NZ,DPLXSW	;   translate tableXLTS2	LD	C,00HDPLXSW	LD	B,00H		; Duplex on/off	INC	B	DEC	B		; Display on our devices	CALL	NZ,DEVOUT	;   if duplex on (half)LCMON	LD	A,(TASK8A+2)	; Chk CL on	OR	A	CALL	NZ,SNDOUT	; Send char if onFSOFF	LD	A,(TASK8A+2)	; Test for CL on	OR	A	JP	Z,SKIPREC	; Go if not	LD	IX,CLREC	CALL	PGMGET		; Check for char avail	JP	Z,SKIPREC	; Go if no charDSPCTRL	LD	B,00H		; Chk if display of control	INC	B		;   codes is in effect	DEC	B	JR	Z,SAVCHR	; Go if no ctrl display	CP	20H	JR	NC,SAVCHR	; Go if not control code	PUSH	AF		; Save the char	LD	HL,BRAKET+1	; Point to ctl char msg	LD	C,A	@@HEX8			; Convert & put in buff	LD	HL,BRAKET	@@DSPLY			; Display it	POP	AFSAVCHR	LD	C,A		; Save the characterSHAKE	LD	B,00H		; Handshake on/off	INC	B	DEC	B	JR	Z,ECHOSW	; Go if off	CP	'Q'&1FH		; Ctrl-Q?XONP1	EQU	$-1		; Modify if Param	JR	Z,CTLQ	CP	'S'&1FH		; Ctrl-S?XOFFP1	EQU	$-1	JR	NZ,NOSQ		; Go if neither	LD	B,00H		; Turn offCTLQ	LD	A,B		;   or on	LD	(TASK8B+1),A	; *CL send task	JR	SKIPREC		; Discard ctrl codeNOSQ	CP	'R'&1FH		; Ctrl-R	JR	Z,CTLR		; Go if so	CP	'T'&1FH		; Ctrl-T	JR	NZ,ECHOSW	; Go if neither	LD	B,00H		; Turn offCTLR	LD	A,B		;  or on	LD	(FRSW+1),A	; FR device	JR	SKIPREC		; Discard ctrl code;;	Test for echo after checking for handshake chars;ECHOSW	LD	B,00H		; Echo on/off?	INC	B	DEC	B	CALL	NZ,CLOUT	; Send char back if ON	LD	A,C	CP	CR		; Was it a CR?	JR	NZ,NOTCR	CALL	ECLF1		; Send LF back if needed	LD	HL,CRSW+1	; Flag for CR received;;	Move state of ACCEPT LF switch into CRSW+1 when CR received;ACCLFSW	LD	A,00H		; Show CR found if accept	LD	(HL),A		;  LF switch is on	JR	TAKEREC		; Display CR;;	When LF rec'd, delete if ACCLFSW is off & last char was CR;NOTCR	LD	A,C		; Check charCRSW	LD	B,0FFH		; Get del LF switch	LD	HL,CRSW+1	; Point to switch	LD	(HL),0FFH	; (Flip off switch - not CR)	CP	LF		; Is line feed the char?	JR	NZ,TAKEREC	; Go if not LF	LD	A,(EIGHT+1)	; Also skip if 8 bit	OR	B		;   switch is off	JR	Z,SKIPREC	; Skip LF if so;TAKEREC	CALL	DEVOUT		; Out to active devicesSKIPREC	CALL	TASKS		; Do 3 tasks (incl kbd)	JP	MAINLP		;   & FRIO test then loop;CLOUT	LD	A,C		; Get char	LD	IX,CLSEND	; Set buffer pointers	JP	OUTPGM		; Put in output buffer;SNDOUT	CALL	CLOUT		; Send this char	LD	A,C		; Is it CR?	CP	CR	RET	NZ		; Done if not;ECLF1	LD	A,$-$		; Is linefeed echo on?ECOLF	EQU	$-1	OR	A	RET	Z		; Done if not	LD	A,LF		; Otherwise load a LF	LD	IX,CLSEND	JP	OUTPGM		; Add to buffer/ret to caller;;	Output to video;DEVOUT	LD	A,0FFH		; Is *DO on or off?	OR	A	JR	Z,FRSW		; Bypass if off	LD	A,C		; Get char	CP	0CH		; If formfeed,	LD	C,A		; <-- is this really necessary?	PUSH	BC	JR	NZ,NOTCLS	;   clear the screen	LD	C,1CH		; Cursor home	@@DSP	LD	C,1FH		; Clear to end of framNOTCLS	@@DSP	POP	BC;;	Send char to our disk if FR is on;FRSW	LD	A,00H		; FR on/off - receive file	OR	A	JR	Z,PUTPR		; Bypass if off	LD	A,C	LD	IX,FRVCTR	; Put away into the	CALL	OUTPGM		;   FR buffer;;	Place char into printer buffer if PR on;PUTPR	LD	A,00H		; PR on/off?	OR	A	JR	Z,FRIOSW	; Go if off	LD	A,C	LD	IX,PRVCTR	; Place the char in	CALL	OUTPGM		;   the printer buffer;;	Check if FR to disk is engaged;FRIOSW	LD	A,-1		; Chk for FR-to-disk	OR	A	RET	Z		; Go if not engaged	LD	IX,FRVCTR	; Is a char available	CALL	PGMGET		;   for the disk?	RET	Z		; Go if none for disk	LD	HL,FR_FCB	; Put char to disk	BIT	7,(HL)		; Opened FCB?	RET	Z		; Skip if not	EX	DE,HL	LD	C,A		; Put char in C	@@PUT	RET	Z		; Return if good	CALL	$ERROR	CALL	FRIO_OFF	; Turn FRIO to disk off	JP	FR_OFF		; Turn FR off and return;;	<CLEAR> command function entered - decode it;CMDKEY	LD	BC,0		; Init no device vector	LD	DE,0		; Init no file FCB	LD	HL,DSPCTRL+1	; Pt to ctrl char dsp param	IF	@MOD4	CP	27H!80H		; Display control chars?	ENDIF	IF	@MOD2	CP	'&'+80H		; Display control chars?	ENDIF	JP	Z,QFUNC;	LD	HL,DPLXSW+1	CP	'!'+80H		; Check duplex	JP	Z,QFUNC;	LD	HL,ECHOSW+1	IF	@MOD4	CP	'"'+80H		; Check echo	ENDIF	IF	@MOD2	CP	'@'+80H	ENDIF	JP	Z,QFUNC;	LD	HL,SHAKE+1	; Check handshake	IF	@MOD4	CP	'*'+80H	ENDIF	IF	@MOD2	CP	'_'+80H	ENDIF	JP	Z,QSHAKE;	LD	HL,ECOLF	CP	'#'+80H		; Echo line feed?	JP	Z,QFUNC;	LD	HL,ACCLFSW+1	; Check accept-LF	CP	'$'+80H	JP	Z,QFUNC;	LD	HL,EIGHT+1	; Check eight bit	IF	@MOD4	CP	')'+80H	ENDIF	IF	@MOD2	CP	'('+80H	ENDIF	JP	Z,QFUNC;	LD	BC,KIVCTR	; Init *KI get/put index	LD	HL,KISW+1	CP	'1'+80H		; Check *KI	JP	Z,QFUNC;	LD	BC,0		; No *DO put/get index	LD	HL,DEVOUT+1	CP	'2'+80H		; Check *DO	JR	Z,QFUNC;	LD	BC,PRVCTR	; Init *PR put/get index	LD	HL,PUTPR+1	CP	'3'+80H		; Check *PR	JR	Z,QFUNC;	LD	BC,CLSEND	; Init *CL-S put/get index	LD	HL,TASK8A+2	CP	'4'+80H		; Check *CL	JR	Z,QCL;	LD	BC,FSVCTR	; Init *FS put/get index	LD	DE,FS_FCB	; Init *FS FCB	LD	IX,XMTBUF	; Point to buffer	LD	HL,FSSW+1	CP	'5'+80H		; Check FS	JR	Z,QFUNC;	LD	BC,FRVCTR	; Get *FR put/get index	LD	DE,FR_FCB	; get *FR FCB	LD	IX,RCVBUF	; Point to buffer	LD	HL,FRSW+1	CP	'6'+80H		; Check FR	JR	Z,QFUNC;	LD	HL,FRIOSW+1	LD	DE,0		; No FCB here	CP	'7'!80H		; Check FR IO to disk?	JR	Z,QFUNC;	CP	'8'!80H		; Menu request?	JP	Z,MENU;	IF	@MOD4	CP	'('!80H		; Local clear screen?	ENDIF	IF	@MOD2	CP	'*'+80H	ENDIF	JP	Z,CLS;	IF	@MOD4	CP	20H!80H		; Clr-Shf-0?	ENDIF	IF	@MOD2	CP	')'+80H	ENDIF	JP	Z,DOSCMD	; Do CMDR;	IF	@MOD4	CP	'='+80H		; Check DOS exit	ENDIF	IF	@MOD2	CP	'+'+80H	ENDIF	JP	NZ,CMDERR;;	Exit from LCOMM - Remove task vectors;EXIT	IF	.NOT.BUFFRD	LD	C,8		; Remove comm line scan task	@@RMTSK;	LD	C,9		; Remove printer task if used	@@RMTSK	ENDIF;	IF	BUFFRD	LD	DE,CLDCB	; Turn off wakeup feature	LD	IY,0OLDVEC	EQU	$-2		; Restoring previous state	LD	C,04H	@@CTL	ENDIF;	CALL	FR_OFF		; Turn off any receive file	LD	DE,FR_FCB	LD	A,(DE)	BIT	7,A		; Is it an open file?	JP	Z,$EXIT		; Exit if not, else	@@CLOSE			;   make sure it's closed	JP	Z,$EXIT		; Exit if no error	CALL	$ERROR		;   else show error	JP	$ABORT		;   and abort;;	Query function ON or OFF;QFUNC	CALL	QONOFF		; Get On or Off response	LD	(HL),A		; Save which one	RET;;	Query *CL on or off;QCL	CALL	QONOFF	LD	(HL),A	OR	A		; On or off?	RET	Z		; Quit if off	LD	(TASK8B+1),A	; Force CL-Send on as well	RET;;	Query handshake on or off;QSHAKE	PUSH	DE	@@KEY			; Get one key	POP	DE	AND	A		; Be sure flags are set	JP	M,QSHAKE1	; Go if PF key	LD	(AUTXOFF+1),A	; Save key as auto XOFF	LD	(HL),0FFH	; Turn on handshake	RETQSHAKE1	CALL	QONOFF1		; Parse on or off	LD	(HL),A		; Turn on or off	XOR	A		; Turn off auto XOFF	LD	(AUTXOFF+1),A	RET;QONOFF	PUSH	DE		; Hang on to register	@@KEY			; Get the operand key	POP	DEQONOFF1	EQU	$	IF	@MOD4	CP	'-'+80H		; Check OFF	ENDIF	IF	@MOD2	CP	'='+80H	ENDIF	JR	Z,TURNOF	; Turn off if so	IF	@MOD4	CP	':'+80H		; Check ON	ENDIF	IF	@MOD2	CP	'-'+80H	ENDIF	JR	Z,TURNONPOPERR	EX	(SP),HL		; Discard ret address	POP	HL	CP	'9'+80H		; Check ID	JP	Z,FILID;	CP	'0'+80H		; Check RESET	JP	Z,FILRES;	CP	'%'!80H		; Check REWIND	JP	Z,FILREW;	IF	@MOD4	CP	'&'!80H		; Check PEOF	ENDIF	IF	@MOD2	CP	'^'!80H	ENDIF	JP	Z,FILEOF;CMDERR	LD	HL,CMDERR$	; None of the above, display	@@DSPLY			; "unacceptable command"	RET;;	Process OFF;TURNOF	XOR	A		; Off = 0	RET;;	Process ON;TURNON	EX	DE,HL		; Shift "FCB" to HL	BIT	7,(HL)		; FCB on or non-file?	EX	DE,HL		; If non-file, HL now	LD	A,0FFH		;   points to X'0000'	RET	NZ		;   which contains X'F3'	JR	POPERR;;	Process Clear Screen;CLS	LD	C,1CH		; Cursor home	@@DSP	LD	C,1FH		; Clear to end of frame	@@DSP	RET;;	Process MENU;MENU	EQU	$	LD	HL,STAT1	; Clear top row status	LD	DE,STAT1+1	; 1st char always a space	LD	BC,66	LDIR	LD	HL,STAT2	; Clear bottom row status	LD	DE,STAT2+1	LD	C,38	LDIR	LD	B,15		; Init loop count	LD	HL,STATAB	; Words where status storedSTATLP1	LD	E,(HL)		; Get lo-switch	INC	HL	LD	D,(HL)		; Get hi-switch	INC	HL	LD	A,(HL)		; Get lo-stuff	INC	HL	PUSH	HL		; Save pointer	LD	H,(HL)		; Get hi-stuff	LD	L,A		; Xfer to L	LD	A,(DE)		; Get status	OR	A		; Active or not?	JR	Z,$+4		; Go if not	LD	(HL),'*'	;   else stuff an '*'	POP	HL	INC	HL		; Bump to next pos	DJNZ	STATLP1	LD	A,(DE)		; Get shake again	OR	A	JR	Z,STATLP2	; Go if off	LD	A,(AUTXOFF+1)	; Check if xoff char set	OR	A	JR	Z,STATLP2	; Skip if not special char	LD	HL,STAT1+63	; Auto X-Off char position	LD	C,A	@@HEX8			; Convert to ASCII for dspSTATLP2	LD	HL,MNUMSG	; Point to COMM menu	@@DSPLY	LD	HL,FS_FCB	; FS still open?	BIT	7,(HL)	JR	Z,STATLP3	; Go if closed	LD	DE,DUMMY	; Recover its name without	PUSH	DE		;   changing the FCB	LD	BC,32	LDIR			;   by creating a duplicate	POP	DE		;   open FCB	LD	BC,(DUMMY+6)	PUSH	DE	@@FNAME			; Call for name recover	LD	HL,FSNAME$	; Output "FS-Spec:"	@@DSPLY	POP	HL		; Recover FCB pointer	@@DSPLY			;   and display fnameSTATLP3	LD	HL,FR_FCB	; Is the FR file open?	BIT	7,(HL)	JR	Z,STATLP4	; Go if closed	LD	DE,DUMMY	; Similar to above	PUSH	DE	LD	BC,32		; Create a duplicate FCB	LDIR	POP	DE	LD	BC,(DUMMY+6)	; Get Drive & DEC	PUSH	DE	@@FNAME			; Call for name recover	LD	HL,FRNAME$	; "FR-Spec:"	@@DSPLY	POP	HL		; Get name start back	@@DSPLYSTATLP4	LD	A,(FREEPG)	; How much buffer left	RRCA			; Divide by 4 to show	RRCA			;   value in K	AND	3FH		; No bit 6 or 7	LD	HL,PAGSPR$+10	; Where to stuff it	LD	B,-1		; Init to count 10sCVD1	INC	B	SUB	10		; How many tens	JR	NC,CVD1		; Go if moreCVD2	PUSH	AF		; Save remainder	LD	A,B		; Get tens	OR	A		; Was it zero tens?	LD	B,' '		; Init for space	JR	Z,$+4		; Go if no tens	LD	B,'0'		; Init for ASCII	ADD	A,B		; Conver to ASCII	LD	(HL),A		; Stuff & bump	INC	HL	POP	AF		; Get remainder	ADD	A,3AH		; Adjust units place	LD	(HL),A	LD	HL,PAGSPR$	; "Memory xxK"	@@DSPLY	RET;;	Process a RESET of a "device";FILRES	LD	A,B		; Check if device vector	OR	C		;   was passed	JP	Z,CMDERR	; Go if not - is error	LD	A,D		; Check for a possible	OR	E		;   FCB for disk	JR	NZ,FILR4;;	Reset the page buffer(s) for the device;FILR1	DI			; No interrupts until done	LD	H,B		; Xfer vector table entry	LD	L,C		;   to grap put/get index	LD	C,(HL)		; Get the PUT pointer	INC	HL		;   and make the GET	LD	B,(HL)		;   pointer equal so	INC	HL		;   buffer contents now	LD	(HL),C		;   show as empty	INC	HL	LD	A,(HL)		; Get the GET pointer to	LD	(HL),B		;   check if in same pageFILR2	CP	B		; Is put/get in same page?	JR	Z,FILR3		; Go if it is	LD	H,A		;   else set up to free this	CALL	FNPIU		;   page by finding next	JR	FILR2		; Loop until next = 1stFILR3	EI			; Interrupts back on	RET;;	Reset a file device;FILR4	LD	HL,FR_FCB	; Turn off the FR or FS	XOR	A	SBC	HL,DE		; Is this the FR?	LD	HL,FSSW+1	JR	NZ,OFFS	LD	(FRIOSW+1),A	; Turn off FR IO to disk	LD	HL,FRSW+1	; Turn off FR to bufferOFFS	LD	(HL),A		; Turn off FR or FS	@@CLOSE			; Close the file	CALL	NZ,$ERROR	; Show any close error	RET;;	Process REWIND;FILREW	LD	A,D		; Rewind the specified	OR	E		;   file (FCB given) if	JP	Z,CMDERR	;   it is in use	@@REW	RET;;	Process PEOF;FILEOF	LD	A,D		; Check if a file device	OR	E		;   was specified	JP	Z,CMDERR	; Go if not - is error	@@PEOF			;   else position to end	RET;;	Process ID request;FILID	LD	A,D		; Bad command if not	OR	E		;   FR or FS specified	JP	Z,CMDERR	; Go on error	LD	A,(DE)		; Make sure that it is	RLCA			;   not already open	JR	C,NOTNOW	; CF = already open	PUSH	DE	PUSH	IX		; Save buffer pointer	LD	HL,FILEPMT	; Prompt for filespec	@@DSPLY	POP	HL		; Take file name	LD	BC,31<8		; 31 chars max	@@KEYIN			; Get the filespec	PUSH	AF		; Save flag state	LD	C,0EH		; Turn the cursor back on	@@DSP	POP	AF		; Recover KEYIN exit state	POP	DE	RET	C		; Return if BREAK from KEYIN	PUSH	HL		; Save ptr to buffer	@@FSPEC			; Fetch & parse filespec	LD	HL,FS_FCB	; Check if FILID req from	XOR	A		;   FS or FR	SBC	HL,DE		; What's the FCB?	POP	HL		; Recover buffer	LD	B,00H		; LRL=256	JR	NZ,FILFR	; Go if req from FR	CALL	$OPEN		; Only open a FS	JR	$+5		; Branch around INITFILFR	@@INIT			; Open the receive file	CALL	NZ,$ERROR	; Show any open error	RET;NOTNOW	LD	HL,OPENMSG	; "File already open"	@@DSPLY			; Show why ID failed	RET;;	Routine to turn off file devices;FS_OFF	XOR	A		; File send	LD	(FSSW+1),A	RETFR_OFF	XOR	A		; File receive	LD	(FRSW+1),A	RETFRIO_OFF	XOR	A	; Dump to disk	LD	(FRIOSW+1),A	RET;;	Call various tasks (on each main loop);TASKS	DI;	IF	.NOT.BUFFRD	; W func does this if bfrd	CALL	TASK8A		; Try to receive from *CL	ENDIF;	CALL	TASK8B		; Try to send to *CL	EI	CALL	TASKK		; Allow interrupts here	IF	.NOT.BUFFRD	DI			; If RS232 does not interrupt	ENDIF			; Printer must be task	CALL	TASK9	EI	JP	FRIOSW		; Check on dump to disk;;	INTERRUPT TASK 8;; W/O Buffer	A is done once per main loop + int rate;		B is done once per main loop + int rate;; W buffer	A is done by wakeup feature + int rate;		B is done once per main loop + int rate;	IF	.NOT.BUFFRDTCB8	DW	TASK8TASK8	CALL	TASK8A	JP	TASK8B	ENDIF;TASK8A	DI	LD	A,0FFH		; CL receive ON/OFF	OR	A	RET	Z		; Done if CL recv off;;	@GET handler to keep interrupts off if possible;	LD	DE,CLDCB	; DE => OPEN DCBFNDDVR	LD	H,D		; Xfer to HL	LD	L,E	LD	A,(HL)		; Get DCB type	BIT	5,A		; Is it linked?	JR	NZ,LNKD		; Need CHNIO if so	INC	HL		; => Address field of DCB	LD	E,(HL)		; If routed, address is	INC	HL		;   next DCB to use	LD	D,(HL)		;   else EP of driver	BIT	4,A		; Z = not routed	JR	NZ,FNDDVR	; Loop until not routed	AND	00001000B	; Can't talk to NIL device	RET	NZ	EX	DE,HL		; Address to HL	LD	DE,RETADD	; Put RET addres on stack	PUSH	DE		;	CP	02H		; Set C,NZ for input request	JP	(HL)		; Go to driver;LNKD	@@GET			; Use SVC if linkedRETADD	RET	NZ		; NZ means no char rec'd;EIGHT	LD	B,00H		; Eight bit mode switch	INC	B	DEC	B	JR	NZ,XLTR1	; Go if eight bit	AND	7FH		; Strip bit 7	RET	Z		; Always ignore nulls	CP	7FH		;   & DELETE if not 8-bit	RET	Z;;	Do XLATER after stripping high bit;XLTR1	CP	$-$		; Character to translate?	JR	NZ,TSTNUL	; Go if not a matchXLTR2	LD	A,$-$		; Replace with xlated char;;	NULL parm now only affects 8-bit mode;TSTNUL	OR	A		; Is char a null?	JR	NZ,KEEPCH	; Go if notACCNUL	LD	B,0FFH		; Default to accept nulls	INC	B		; NZ=nulls wanted	DEC	B		; Z=don't accept nulls	RET	Z;KEEPCH	PUSH	IX		; Place in CL input buffer	LD	IX,CLREC	CALL	OUTPUT		; Output to buffer if	POP	IX		;   non-null or want nulls	RET;TASK8B	LD	A,0FFH		; CL send On/Off for	OR	A		;   handshaking	RET	Z	LD	C,00H		; Transmit a CTL0 to	LD	DE,CLDCB	;   check the status of	@@CTL			;   the CL	RET	NZ		; Indicates not ready;FRCPUT	LD	C,00H		; Force a char out?	XOR	A		; Clear it after p/u	LD	(FRCPUT+1),A	OR	C		; Check original status	JR	NZ,FRCIT	; Go if force on	PUSH	IX	LD	IX,CLSEND	; Do we have a char to	CALL	BUFGET		;   send to the CL?	POP	IX	RET	Z		; Return if not	LD	C,A		; Save the charFRCIT	@@PUT			; Put it out;AUTXOFF	LD	A,00H		; Check for auto XOFF	OR	A		; Is it on?	RET	Z		; Return if not	SUB	C		; Matched char?	RET	NZ		; Quit if not	LD	(TASK8B+1),A	; Pause xmit (OFF)	RET;TASKK	@@KBD			; Scan the keyboard	RET	NZ		; Error (or no key depressed)	CP	BREAK		; Check for break first	JR	Z,ISBRK		; Go on break	OR	A		; Then check for high bit set	JP	M,CMDKEY	; Go if FN keyKISW	LD	B,0FFH		; KI on/off	INC	B	DEC	B	RET	Z		; Return if KI is offNOTBRK	PUSH	IX	LD	IX,KIVCTR	;   else put key into	CALL	OUTPGM		;   the output buffer	POP	IX	RET;ISBRK	DI	LD	DE,CLDCB	; Point to *CL	LD	C,01H		; Send CTL 1, a	@@CTL			;   break request	EI	LD	BC,CLSEND	CALL	FILR1		; Reset the CL buffer	CALL	FS_OFF		; Turn off the *FS	LD	BC,2000H	; Time delay	@@PAUSE	@@CKBRKC		; Reset the break bit	LD	C,00H		; Init the character	LD	DE,CLDCB	; Get the CL DCB	DI	@@PUT			; Send the 0	EI	RET;;	INTERRUPT TASK 9;	Only if RS-232 does not interrupt;	IF	.NOT.BUFFRDTCB9	DW	TASK9		Task EPT	ENDIFTASK9	LD	B,03H		; Max chars/passPRLOOP	LD	C,00H		; Test printer status	LD	DE,$-$		; PRDCB$PRDCB	EQU	$-2	@@CTL			; Check the status	RET	NZ		; Return if unavailable	PUSH	IX	LD	IX,PRVCTR	; Get char from printer;	IF	BUFFRD	CALL	PGMGET	ELSE	CALL	BUFGET		; Buffer if available	ENDIF;	POP	IX	RET	Z		; None, go back	LD	C,A	@@PRT			; Output to printer	DJNZ	PRLOOP		; Loop if more	RET;;	Common routine to stuff various buffers;OUTPUT	LD	L,(IX+00H)	; Get pointer to	LD	H,(IX+01H)	;   buffer PUT	LD	(HL),A		; Write char into buffer	INC	(IX+00H)	; Bump buffer pointer	RET	NZ		; Go if still in same page	CALL	NEXTAP		; Find next available page	JR	Z,DUMPCHR	; Go if no pages available	LD	(IX+01H),A	; Set index to new page	LD	HL,FREEPG	; Reduce the amount of free pages	DEC	(HL)	LD	A,07H		; Less than 2k available?	CP	(HL)	RET	C		; Return with NZ	LD	(MAINLP+1),A	; Set flag for warning	OR	A		; Ensure NZ return	RET;;	No more pages available, keep last page;DUMPCHR	DEC	(IX+00H)	; Dump character and	XOR	A		;   return	RET;;	The following code is not executed - as it is too;	slow at rates >= 1200 baud because interrupts are on.;	DE must be loaded with KIVCTR;	DB	0	PUSH	IX		; Dev requesting the output	POP	HL	XOR	A		; The difference will be	SBC	HL,DE		;   the offset into the	LD	DE,DEVICE$	;   name table	ADD	HL,DE	LD	BC,4	LD	DE,OVRRUN$+3	LDIR	LD	HL,OVRRUN$	; Display the buffer	@@DSPLY			;   overrun error	XOR	A		; Reuse current page	RET;;	Check for character available in dynamic buffer;BUFGET	LD	L,(IX+02H)	; Get pointer to next	LD	H,(IX+03H)	;   buffer GET	LD	A,L		; Check on in=out low order	CP	(IX+00H)	JR	NZ,INNEOUT	; Go if in not equal out	LD	A,H		; Now check on hi-order	CP	(IX+01H)	RET	Z		; Return if none to I/O;;	Buffer is not empty - Get next character;INNEOUT	LD	A,(HL)		; Get a char from buffer	INC	(IX+02H)	; Advance lo-order pointer	RET	NZ		; Return if still in same page	PUSH	AF		; Save the character	CALL	FNPIU		; Find next page in use	LD	(IX+03H),A	; Stuff new page index	POP	AF		; Recover the character	DEC	H		; Set NZ return for rec'd	RET;;	Routine to find next available page buffer;NEXTAP	LD	L,H		; Point to page buffer	LD	H,LINKS<-8	;   index	LD	A,(LINKS)	; Get next empty link	PUSH	HL		; Save this index pointer	LD	L,A		; Point to new link	LD	A,(HL)		; Get what it links to	OR	A		; Test if none left	JR	NZ,GOTNAP	; Go if still more	POP	HL		; Restore reg & return	RET			;   with Z-flag for error;;	Found next available page - set the links;GOTNAP	LD	(LINKS),A	; Update new next avail	LD	A,L		; Xfer index of new page	POP	HL		; Recover pointer to index	LD	(HL),A		;   of old & link to new	LD	L,A		; Repoint to new page's	LD	(HL),00H	; index and show it is	RET			;   the last one;;	Find the next page in use;FNPIU	LD	A,(FREEPG)	; Show one additional page	INC	A		;   is free	LD	(FREEPG),A	LD	A,(HIPAGE)	; Get highest page avail	LD	L,A		; Set HL to its index	LD	A,H	LD	H,LINKS<-8	; Show that page links to	LD	(HL),A		;   the one we just emptied	LD	(HIPAGE),A	; Now update the new end	LD	L,A		; Set HL to the emptied	LD	A,(HL)		;   page, get what it	LD	(HL),00H	;   linked to, & show old	RET			;   is end.  Ret A=link;;	Execute a DOS command;DOSCMD	LD	HL,BASE-1	LD	B,01H		; Set LOW$	@@HIGH$	LD	HL,CMDPMT	; Issue prompt	@@DSPLY	LD	BC,80<8		; Max chars	LD	HL,DUMMY	; Input buffer	@@KEYIN			; Get command request	RET	C		; Return on break	INC	B	DEC	B	RET	Z		;   or CR only	EX	DE,HL	LD	HL,$-$		; Point to CFLAG$CFLAG	EQU	$-2	BIT	0,(HL)		; Get current status	PUSH	HL	PUSH	AF		; Save memory freeze status	SET	0,(HL)		; Freeze memory	EX	DE,HL	@@CMNDR			; Do the command	LD	HL,CPMLTD	; Show cmd finished	@@DSPLY	POP	AF		; Get the previous status	POP	HL		;   and CFLAG$ location	RET	NZ		; Back if was set before	RES	0,(HL)		;   else restore it	RET;CMDPMT	DB	LF,LF,'Enter command:',0DHCPMLTD	DB	LF,'Command completed',0DH;;	Messages;BRAKET	DB	'{  }',03H	; Brackets around hex byteFILEPMT	DB	1DH,0AH,'File name: ',03HOPENMSG	DB	1DH,0AH,'File already open',0DHMNUMSG	DB	0AHSTAT1	DC	71,' '	DB	LF	DB	'DUPLX ECHO  ECOLF ACCLF REWND PEOF   DCC   CLS   8-B   CMD  HNDSH  EXIT',0AH	DB	'==1== ==2== ==3== ==4== ==5== ==6== ==7== ==8== ==9== ==0== '	IF	@MOD4	DB	'==:== ==-==',0AH	ENDIF	IF	@MOD2	DB	'==-== =====',0AH	ENDIF	DB	' *KI   *DO   *PR   *CL   *FS   *FR   DTD   ???   ID    RES   ON    OFF',0AHSTAT2	DC	39,' '	DB	0DH;STATAB	DW	KISW+1,STAT2+2,DEVOUT+1,STAT2+8	DW	PUTPR+1,STAT2+14,TASK8B+1,STAT2+19	DW	TASK8A+2,STAT2+21,FSSW+1,STAT2+26	DW	FRSW+1,STAT2+32,FRIOSW+1,STAT2+38	DW	DPLXSW+1,STAT1+2,ECHOSW+1,STAT1+8	DW	ECOLF,STAT1+14,ACCLFSW+1,STAT1+20	DW	DSPCTRL+1,STAT1+38,EIGHT+1,STAT1+50	DW	SHAKE+1,STAT1+61;FSNAME$	DB	'FS-Spec: ',03HFRNAME$	DB	'  FR-Spec: ',03HPAGSPR$	DB	'  Memory:   K',0DHCMDERR$	DB	'** Invalid command sequence **',0DHLILPG$	DB	'Warning! Less than 2K of buffer left  X-OFF transmitted',0DH;;	File control blocks;CLDCB	DS	32FS_FCB	DS	32FR_FCB	DS	32DUMMY	DS	81KIVCTR	DW	0,0PRVCTR	DW	0,0CLREC	DW	0,0CLSEND	DW	0,0FSVCTR	DW	0,0FRVCTR	DW	0,0FREEPG	DS	1;;	Routines to buffer I/O in pgm loop;OUTPGM	DI	CALL	OUTPUT	EI	RET;PGMGET	DI	CALL	BUFGET	EI	RET;;	Page buffer link table;	ORG	$<-8+1<+8	; Next page boundary;LINKS	DS	1		; Link to next availableHIPAGE	DS	1		; Link to last available	DS	1		; Init to 1st available	DS	1		; Init to last available	DS	252		; Space for linkage tables;XMTBUF	DS	256RCVBUF	DS	256;	SUBTTL	<'COMM Initialization Section>';;	Entry point to LCOMM;LCOMM	@@CKBRKC		; Check for break	JR	Z,LCOMMA	; Continue if not	LD	HL,-1		;   else abort	RET;LCOMMA	DI	LD	(QUIT$+1),SP	; Save original stack	PUSH	HL		; Save ptr to cmd line	LD	HL,0	@@BREAK			; Disable break vectoring	EI	LD	HL,HELLO$	; Issue the copyright	@@DSPLY	POP	HL	LD	DE,CLDCB	; Point to FCB	@@FSPEC			; Get the *CL spec	JP	NZ,BADCL	; Go error if none	LD	A,(DE)	CP	'*'		; Check for valid spec	JP	NZ,BADCL	; Go if not a device	LD	DE,PRMTBL$	; Parse the params	@@PARAM	PUSH	AF		; Save status	CALL	NZ,$ERROR	; Display any error	POP	AF	JP	NZ,$ABORT	;   and then quit;	LD	B,00H	LD	DE,CLDCB	; Open the comm line	@@OPEN	PUSH	AF	CALL	NZ,$ERROR	; Show any open error	POP	AF	JP	NZ,$ABORT	;   and then quit	LD	C,02H		; INIT function for hardware	@@CTL	LD	HL,GETMNU$	; How the user gets menu	@@DSPLY	XOR	A	LD	(FS_FCB),A	; Init FCB's to off	LD	(FR_FCB),A	LD	DE,(PRNAME)	; Load 'PR' backwards	@@GTDCB	LD	(PRDCB),HL	; Store address for @CTL	@@FLAGS			; Set up IY	PUSH	IY	POP	DE	LD	HL,'S'-'A'	; Offset to SFLAG$	ADD	HL,DE	LD	(SFLG),HL	; Store for later	LD	HL,'k'-'a'	; Offset to KFLAG$	ADD	HL,DE	RES	0,(HL)		; Be sure BREAK bit is off	LD	HL,'c'-'a'	; CFLAG$	ADD	HL,DE	LD	(CFLAG),HL	BIT	1,(HL)		; Doing CMNDR?	LD	HL,0	LD	B,L	JR	Z,$+3		; Use LOW$ if CMNDR	INC	B	@@HIGH$	INC	HL		; Available for use	DEC	H		;   by page buffers	LD	B,H		; Set B to highest useable	LD	HL,LINKS	LD	A,LCOMM<-8	; Establish 1st usable	LD	(HL),A		; Init to first available	INC	L		;   page buffer	LD	(HL),B		; Init to highest page	INC	L		;  buffer available	LD	(HL),A		; Init to begin & highest	INC	L	LD	(HL),B;;	Establish page buffer linkage table;DOLINKS	LD	L,A		; Init memory begin to	INC	A		;   high bytes for as many	LD	(HL),A		;   bytes as pages to top	CP	B	JR	NZ,DOLINKS	LD	L,A	LD	(HL),00H	; Close out with 0;;	Establish starting page buffers for devices;	LD	H,04H		; Init 1st at links+4	LD	IX,KIVCTR	CALL	INITBUF		; Init *KI page buffer	LD	IX,PRVCTR	CALL	INITBUF		; Init *PR page buffer	LD	IX,CLREC	CALL	INITBUF		; Init *CL-R page buffer	LD	IX,CLSEND	CALL	INITBUF		; Init CL-S page buffer	LD	IX,FSVCTR	CALL	INITBUF		; Init *FS page buffer	LD	IX,FRVCTR	CALL	INITBUF		; Init *FR page buffer;;	Calculate free buffer space;	LD	H,LINKS<-8	; Get hi-order link table	LD	B,00H		; Init count to 0	LD	A,(LINKS)	; Find ptr to 1st spare	LD	L,AFBS1	LD	A,(HL)		; Get pointer to next	OR	A		;  spare & test if last	JR	Z,FBS2		; Exit if no more	INC	B		; Bump counter	LD	L,A		; Show new pointer	JR	FBS1FBS2	LD	A,B		; Transfer the count	LD	(FREEPG),A	;   and save it	JR	SETUPT;;	Routine to establish starting page buffers;INITBUF	LD	(IX+00H),00H	; Show low order PUT/GET	LD	(IX+02H),00H	;   start at 0 reference	PUSH	HL	CALL	NEXTAP		; Find next available page	JP	Z,NOBUFS	; Go if insufficient pages	POP	HL	LD	(IX+01H),A	; Set high-order PUT/GET	LD	(IX+03H),A	;   page index pointers	INC	H		; Bump to next entry in	RET			;   link table & return;;	Routine to set up the task processor;SETUPT	IF	.NOT.BUFFRD	LD	DE,TCB8		; CL task process	LD	C,8	@@ADTSK	LD	DE,TCB9		; Printer output task	LD	C,9		; Only if RS232 does	@@ADTSK			;   not interrupt	ENDIF;	IF	BUFFRD	LD	DE,CLDCB	; Turn on wakeup feature	LD	IY,TASK8A	; Wakeup driver address	LD	C,04H		; Set addr CTL value	DI	@@CTL			; Send to comm driver	EI	LD	(OLDVEC),IY	; Save previous state	ENDIF;	LD	HL,LFEEDS	; Clear most of screen	@@DSPLY;;	Transfer any translation characters;	LD	A,(XLATES+1)	; Transfer the output	LD	(XLTS1+1),A	;   translation character	LD	A,(XLATES)	LD	(XLTS2+1),A;	LD	A,(XLATER+1)	; Transfer the input	LD	(XLTR1+1),A	;   translation character	LD	A,(XLATER)	LD	(XLTR2+1),A;	LD	A,(NULLPRM)	; Transfer the null param	LD	(ACCNUL+1),A	LD	A,(XONP)	; Transfer the XON/XOFF	LD	(XONP1),A	;   parameters	LD	A,(XOFFP)	LD	(XOFFP1),A	LD	(XOFFP2),A	JP	MAINLP;;	Error handling on initialization;NOBUFS	LD	HL,NOBUFS$	; "Not enuf mem for buff...	DB	0DDHBADCL	LD	HL,BADCL$	; "Need RS232 dev name	@@LOGOT	JP	$ABORT;;	Messages;HELLO$	DB	'COMM'*GET	CLIENT;	IF	@MOD4GETMNU$	DB	'Use <CLEAR-8> for menu',LF,CR	ENDIF	IF	@MOD2GETMNU$	DB	'Use <ESC-8> for menu',LF,CR	ENDIFLFEEDS	DC	18,LF	DB	0EH,03H;	DC	32,0		; Patch space;BADCL$	DB	'Comm Line driver not specified',0DHNOBUFS$	DB	'Insufficient memory to establish buffers',0DHDEVICE$	DB	' KI  PR CL-RCL-S FS  FR ????'OVRRUN$	DB	'** xxxx Buffer overrun **',03H;PRNAME	DB	'PR';PRMTBL$	DB	'XLATES'	DW	XLATES	DB	'XS    '	DW	XLATES	DB	'XLATER'	DW	XLATER	DB	'XR    '	DW	XLATER	DB	'NULL  '	DW	NULLPRM	DB	'N     '	DW	NULLPRM	DB	'XON   '	DW	XONP	DB	'XOFF  '	DW	XOFFP	NOPNULLPRM	DW	-1		; Default to accept nullsXONP	DW	'Q'&1FH		; Ctrl-QXOFFP	DW	'S'&1FH		; Ctrl-SXLATES	DW	0XLATER	DW	0;	END	LCOMM