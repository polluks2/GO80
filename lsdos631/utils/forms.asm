; ***************************************************************; * Filename: FORMS/ASM						*; * Revision: 06.03.01						*; * Rev Date: 14 Dec 97						*; ***************************************************************; * Printer Output Formatting Filter				*; *								*; ***************************************************************;	TITLE	<FORMS/FLT - LS-DOS 6.3>;LF	EQU	10CR	EQU	13;*GET	SVCMAC			; System SVC macros*GET	COPYCOM			; Copyright message;	ORG	2400H;BEGIN	@@CKBRKC		; Check for break	JR	Z,BEGINA	LD	HL,-1		; Set abort code	RET			;   and exit;BEGINA	PUSH	DE		; Save DCB address	POP	IX		;   in index reg	LD	(PFDCB),DE	;   and in filter header	@@DSPLY	HELLO$		; Welcome the user;;	Check if entry was from SET commmand;	@@FLAGS	BIT	3,(IY+'C'-'A')	; System request?	JP	Z,VIASET	; Quit if not;;	Check if filter is already resident;	LD	DE,FF$		; Check if filter	@@GTMOD			;   module in memory	EX	DE,HL		; Put DCB ptr in HL	JR	NZ,NOTRES	; Go if not;;	Make sure that the new DCB is same as the old;	LD	C,(HL)		; Get DCB pointer in BC	INC	HL	LD	B,(HL)	LD	HL,6		; Get old DCB name and	ADD	HL,BC		;   put in error message	LD	A,(HL)		;   in case a different	INC	L		;   DCB is referenced.	LD	H,(HL)	LD	L,A	LD	(DCBNAM$),HL	; Stuff message with spec	OR	H	JR	Z,ISRES	LD	HL,(PFDCB)	; Get existing DCB	OR	A		;   pointer	SBC	HL,BC		; Same DCB pointer?	JP	NZ,DCBERR	; Can't install if different	JR	ISRES;;	Module is not resident;NOTRES	LD	DE,'IK'		; Locate low memory pointer	@@GTDCB	JP	NZ,IOERR	; Quit if not found	DEC	L	LD	D,(HL)		; Get pointer to start	DEC	L		;   of free low core	LD	E,(HL)	LD	(LCPTR+1),DE	; Save loc for later	PUSH	HL		; Save low core ptr	LD	HL,PFEND-PFFLT	ADD	HL,DE		; Start + driver length	PUSH	HL	DEC	HL		; Point to last byte	LD	(SVEND+1),HL	LD	BC,1300H	; Max addr + 1	XOR	A	SBC	HL,BC		; Enough room in low mem?	POP	DE		; Recover new LC	POP	HL		; Recover low core ptr	JR	C,PUTLOW	; If room, put it low;;	Check if high memory available;	@@FLAGS			; Get system flags	BIT	0,(IY+'C'-'A')	; Memory frozen?	JP	NZ,NOROOM	; "No memory...	LD	HL,0		; Get HIGH$	LD	B,L	@@HIGH$	LD	(SVEND+1),HL	; Save for relocator	LD	E,L		; Transfer new last	LD	D,H		;   to reg DE	XOR	A	LD	BC,PFEND-PFFLT	; BC = filter length	SBC	HL,BC	LD	B,00H		; Set new HIGH$	@@HIGH$	INC	HL		; Point to new start	EX	DE,HL	PUSH	DE	CALL	RELO		; Relocate internal references	POP	DE	LD	A,0FFH		; Flag to notify user that	LD	(HGHFLG),A	;   high memory was used	JR	MOVMOD		; Jump to move module;;	Room in low core - move driver low;PUTLOW	LD	(HL),E		; Stuff low core pointer	INC	L		;   with new low value	LD	(HL),D	CALL	RELO		; Relocate vectorsLCPTR	LD	DE,$-$		; Low core pointer;;	Move module to memory (high or low);MOVMOD	PUSH	DE		; Save start (destination)	LD	HL,PFFLT	; Source address = driver	LD	BC,PFEND-PFFLT	; Length of driver	LDIR			; Move it into memory	POP	DE		; Get filter start back	SET	5,(IY+'D'-'A')	; Set PF in DFLAG$;ISRES	LD	HL,PFACT$	; "FORMS installed...	LD	(IX),40H!7	; Init DCB type to C/P/G	LD	(IX+01H),E	;   & filter, & stuff the	LD	(IX+02H),D	;   filter address	@@LOGOT			; Display installation	LD	A,$-$HGHFLG	EQU	$-1		; Flag that filter went high	OR	A		; Skip if not set	JR	Z,NTHIGH	LD	HL,HMEM$	; "Filter in hi mem...	@@LOGOTNTHIGH	LD	HL,0		; Init no error code	RET			; Done, back to user;;	Relocate internal references in the driver;RELO	PUSH	IX		; Save IX	LD	IX,RELTAB	; Point to relocation tableSVEND	LD	HL,0		; Find distance to move	LD	(PFFLT+2),HL	; Set last byte used	LD	DE,PFEND-1	OR	A		; Clear carry	SBC	HL,DE		; HL = offset to new location	LD	B,H		; Move that to BC	LD	C,L	LD	A,TABLEN	; Get table lengthRLOOP	LD	L,(IX+00H)	; Get address to change	LD	H,(IX+01H)	LD	E,(HL)		; Get address to DE	INC	HL	LD	D,(HL)	EX	DE,HL	ADD	HL,BC		; Offset it by (BC) bytes	EX	DE,HL	LD	(HL),D		; Put it back into driver	DEC	HL	LD	(HL),E	INC	IX		; Bump table pointer	INC	IX	DEC	A		; Decrement count	JR	NZ,RLOOP	; Loop until done	POP	IX	RET;;	Error exits;VIASET	LD	HL,VIASET$	; "Install with SET	DB	0DDHDCBERR	LD	HL,DCBERR$	; "Filter in use	DB	0DDHNOROOM	LD	HL,NOROOM$	; "No mem avail	@@LOGOT	LD	HL,-1		; Set abort code	RET;IOERR	LD	L,A		; Error # to HL	LD	H,00H	OR	0C0H		; Short msg, return	LD	C,A		; Err code to C for SVC	@@ERROR			; Display error	RET;;	Messages and data tables;FF$	DB	'$FF',03HHELLO$	DB	'FORMS Filter'*GET	CLIENTVIASET$	DB	'Must install via SET',0DHNOROOM$	DB	'No memory space available',0DHDCBERR$	DB	'Filter already attached to *xx',0DHDCBNAM$	EQU	$-3PFACT$	DB	'Forms filter is now resident',0DHHMEM$	DB	0AH,'Note: filter installed in high memory.',0DH;;;	Printer Filter - PF;	Provides hard or soft form feed, line wraparound,;	automatic form feeds between pages, tabs, blank;	lines, 1 byte translation table, left margins,;	and set-top-of-form character;;*MOD;PFBIT	EQU	3		; Position in DFLAG$SPLBIT	EQU	0		; Position in DFLAG$;;	Start of PF filter;PFFLT	JR	PFBGN		; Jump around header	DW	PFEND-1		; Last byte used	DB	3,'$FF'		; Name length, namePFDCB	DW	$-$		; Link to DCB	DW	0;;	Filter data area;PFDATA$	EQU	$PMAX	EQU	$-PFDATA$	DB	66		; Page size (max lines per page)LCOUNT	EQU	$-PFDATA$	DB	0		; Line counterLMAX	EQU	$-PFDATA$	DB	66		; Max lines to printCCOUNT	EQU	$-PFDATA$	DB	0		; Chars per line printedXL1	EQU	$-PFDATA$	DB	00H		; Translate fromXL2	EQU	$-PFDATA$	DB	00H		; Translate toINDENT	EQU	$-PFDATA$	DB	00H		; Indent after line wraparoundADDLF	EQU	$-PFDATA$	DB	04H		; Bit 0 - LF after CR; Bit 1=FFCMAX	EQU	$-PFDATA$	; Bit 2 - TAB expand (1)	DB	00H		; Max CPL before wraparoundMARGIN	EQU	$-PFDATA$	DB	00H		; Left hand margin;;	Start of filter code;PFBGN	JR	Z,FFENTRY	; Go if @PUT	DB	11H		; Ignore next inst if notPFPUT	LD	B,02H		; Init for PUT	PUSH	IX	LD	IX,(PFDCB)	; Get the DCB vectorRX01	EQU	$-2	@@CHNIO			;   and chain to it	POP	IX	RET;;	Perform the tab function;DOTAB	LD	A,(IX+CCOUNT)	; How many spaces to next	AND	07H		;   tab stop?	SUB	08H	NEG	JR	@INDENT		; Space over to itFFENTRY	LD	IX,PFDATA$	; Base registerRX02	EQU	$-2;CKXLAT	LD	A,(IX+XL1)	; Get xlate in	CP	C		; Translate this char?	JR	NZ,CONT		; Go if not xlated char	LD	A,(IX+XL2)	; Get xlate to char	LD	C,A		; Do translation;CONT	LD	A,C		; Get char to test	CP	0CH		; Form feed?	JP	Z,DOTOFRX14	EQU	$-2	CP	06H		; Set TOF?	JP	Z,SETTOFRX03	EQU	$-2	CP	CR		; CR?	JR	Z,DOCRLF	CP	LF		; LF?	JR	Z,DOCRLF	LD	A,(IX+MARGIN)	; Left margin to do?	OR	A	JR	Z,NOMARG	; Go if not	INC	(IX+CCOUNT)	; Check current char count	DEC	(IX+CCOUNT)	; If at newline,	PUSH	BC	CALL	Z,@INDENT	;   need a margin nowRX13	EQU	$-2	POP	BCNOMARG	LD	A,C		; Get character again	BIT	2,(IX+ADDLF)	; Expand tabs?	JR	Z,CONTA	CP	09H		; Tab?	JR	Z,DOTABCONTA	CP	20H		; Other control code?	JR	C,PFPUT		; Pass on unchanged if so;;	Got a character to output;PUTCHAR	PUSH	BC		; Save character	CALL	SETUP		; Setup for next charRX12	EQU	$-2	POP	BC	RET	NZ		; Quit on error	CALL	Z,PFPUT		; Now put the charRX04	EQU	$-2	RET;;	Do the end of line check;SETUP	INC	(IX+CCOUNT)	; Inc char counter	LD	A,(IX+CMAX)	; Wraparound needed?	AND	A	RET	Z		; Quit if feature is off	CP	(IX+CCOUNT)	JR	NC,EXITZ	; Done if not needed	CALL	DOCRLF		; Do carriage returnRX05	EQU	$-2	RET	NZ	INC	(IX+CCOUNT)	; Adjust char counter;;	Check on indent needed;	LD	A,(IX+INDENT)	; Get indent value	ADD	A,(IX+MARGIN)	; Add in the margin	OR	A	RET	Z		; Done if none;@INDENT	PUSH	BC		; In case of recursive	LD	B,A		;   calls	LD	C,' '		; Print spacesSPACES	PUSH	BC		; Save counter	XOR	A	CALL	PUTCHAR		; Put the characterRX06	EQU	$-2	POP	BC		; Recover counter	JR	NZ,$+4	DJNZ	SPACES	POP	BC	RET;LINFEED	BIT	0,(IX+ADDLF)	JR	Z,DOWN1		; Go if hardware auto-LF	LD	C,CR	CALL	PFPUT		; Do CR and LFRX11	EQU	$-2	RET	NZ	JR	DOWNLFDOWN1	LD	A,(IX+CCOUNT)	AND	A		; Line empty?	LD	C,CR	JR	NZ,DOWNCR	; Do CR if notDOWNLF	LD	C,LF		; Do LF if soDOWNCR	CALL	PFPUTRX07	EQU	$-2	LD	(IX+CCOUNT),00H	; Starting new line	RET;DOCRLF	CALL	LINFEED		; CRLF & check if page endRX08	EQU	$-2	RET	NZ;	INC	(IX+LCOUNT)	; Increment line count	LD	A,(IX+LCOUNT)	; Get line count	CP	(IX+LMAX)	; Time to do form feed?	JR	C,EXITZ		; REturn if not;DOTOF	LD	A,(IX+PMAX)	; How many lines to feed?	SUB	(IX+LCOUNT)	JR	Z,SETTOF	; Skip if zero	PUSH	BC		; In case called by DOTAB	LD	B,A	BIT	1,(IX+ADDLF)	; Hardware form feed?	JR	Z,SOFTFF	; Go if not	LD	C,0CH		;   else load up FF char	CALL	PFPUT		;   and send itRX09	EQU	$-2	JR	FFEXIT;SOFTFF	PUSH	BC		; Save count	CALL	LINFEED		; Do LF'sRX10	EQU	$-2	POP	BC		; Get count back	JR	Z,CHRGONE	; Go if okay	POP	BC		;   else clean stack	RET			;   and return errorCHRGONE	DJNZ	SOFTFF		; Loop for # of linesFFEXIT	POP	BC		; Get char back;;	Set the top-of-form;SETTOF	LD	(IX+LCOUNT),00H	; Reset line counterEXITZ	CP	A	RET;PFEND	EQU	$;;	Relocation Table for Filter;RELTAB	DW	RX01,RX02,RX03,RX04,RX05,RX06,RX07	DW	RX08,RX09,RX10,RX11,RX12,RX13,RX14TABLEN	EQU	$-RELTAB/2;	END	BEGIN