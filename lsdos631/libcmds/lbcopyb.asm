; LBCOPYB/ASM - COPY/APPEND Common Routines	SUBTTL	'<LBCOPYB - COPY/APPEND Common Routines>';	PAGE;;	CVRTUC - Transfer partspec & convert to upper case;	HL => Buffer containing characters to parse;	DE => Destination of converted line;CVRTUC	CALL	CVRT		; Convert line	LD	A,CR		; Ensure End-Of-Line	LD	(DE),A		;  with a carriage return	RET;;	Position to first non-space character;CVRT0	INC	HLCVRT	LD	A,(HL)		; Get possible dest char	CP	0DH		; Enter?	RET	Z		; Exit on CR	CP	' '		; Loop on SPACE	JR	Z,CVRT0	DEC	HL		; Backup to first separator;;	HL => Filespec or Devspec, convert to UC;	LD	B,32		; Max is 32 charsCOP1	LD	A,(HL)		; Get char	CP	'a'		; Convert lc to uc	JR	C,COP2	CP	'{'	JR	NC,COP2	RES	5,ACOP2	LD	(DE),A		; Filespec until paren	CP	0DH		; RETurn if terminator	RET	Z	CP	'('		; Parameter?	RET	Z	INC	HL		; Bump pointers	INC	DE	DJNZ	COP1		; Loop for 32 chars max	RET;;	PRSPC - Match source & dest specs for defaults;PRSPC	LD	HL,FCB1		; HL => Source FCB	LD	DE,FCB2		; DE => Dest FCB;;	Abort if first character is illegal;	LD	A,(DE)		; Grab first char of dest	CP	CR		; is it a C/R?	JP	Z,DSTREQ	; "Dest spec required"	CP	'0'		; Numeric?	JR	C,CHKDEST	CP	'9'+1	JP	C,DSTREQ	; Yes - "Dest spec req";CHKDEST	PUSH	DE		; Save dest FCB pointer;;	if no dest filename, xfer source filename;	LD	A,(DE)		; Get dest char	CP	'A'		; Filename present?	CALL	C,PRSPC7	; No - xfer src filename	LD	B,'/'		; With an alpha, init to	CALL	PRSPC2		;  test for extension	LD	B,'.'		; Init to test for pswd	CALL	PRSPC2	POP	DE	RET;;	PRSPC2 - Transfer field to destination;	DE => Start of destination field;	 B =  Delimiter to position on byte after;PRSPC1	INC	DE;;	Finished with field (delimiter hit?);PRSPC2	LD	A,(DE)		; Is the next char the	CP	B		; separator to look for?	JR	Z,PRSPC3;;	Skip over an existing destination field;	CP	'A'		; Alphabetic?	JR	NC,PRSPC1	; Yes - skip it	CP	'0'		; Numeric?	JR	C,PRSPC4	; No - use source field	CP	'9'+1		; Numeric?	JR	C,PRSPC1	; Yes - skip it;	JR	PRSPC4		; Use source field;;	Hit the delimiter - position to next char;PRSPC3	INC	DE		; Posn to next field	RET			; and return;;	Scan source spec & see if it contains field;PRSPC4	PUSH	HL		; Save ptr to sourcePRSPC5	LD	A,(HL)		; Grab a source char	INC	HL		; Position to next char;;	Is the character a terminator?;	CP	ETX		; End of line?	JR	Z,PRSPC6	; If so, not in source	CP	CR		; End of line?	JR	Z,PRSPC6	; If so, not in source;;	Is the character the field delimiter?;	CP	B		; Delimiter?	JR	NZ,PRSPC5	; Nope, continue;;	Transfer source field to destination;	CALL	MVFLD1		; Yes, xfer the SRC field;PRSPC6	POP	HL		; Recover src ptr	RET;;	PRSPC7 - Shoehorn source into destination field;PRSPC7	LD	A,(HL)		; Get source char	CP	'0'		; RET NC if alphanumeric	RET	C		; C - not alpha	CP	'9'+1		; Numeric (0-9)?	JR	C,MVFLD		; Xfer if it is	CP	'A'		; Not numeric -	RET	C		; Must be alphabetic;;	Shoehorn src field byte into dest FCB;MVFLD	INC	HL		; Bump source pointerMVFLD1	PUSH	HL	LD	H,D		; Xfer dest ptr to HL	LD	L,E;;	Get current char & stuff in last char;MVFLD2	LD	C,(HL)		; Get dest char	LD	(HL),A		; Stuff in last character	INC	HL		; Posn to next char;;	Finished with field?;	LD	A,C		; Test dest for	CP	ETX		; End of line?	JR	Z,MVFLD3;	CP	CR		; End of line?	JR	NZ,MVFLD2	; Ripple the destination;;	Done stuffing 1 source byte into dest field;MVFLD3	LD	(HL),A		; Stuff the terminator	POP	HL		; Restore source FCB	INC	DE		; Advance to next pos	JR	PRSPC7		; Go get next source byte;;	DOSVC - Get Filespec/Devspec & issue @OPEN/@INIT;DOSVC	PUSH	AF		; Save svc #	PUSH	HL		; Save buffer ptr	PUSH	DE		; Save FCB;;	Transfer filespec into TEMBUF;	LD	HL,TEMBUFTLP	LD	A,(DE)		; Get byte from FCB	CP	'/'		; Extension?	JR	NZ,STUFCHR	; No - save the char	INC	DE		; Is the next character	LD	A,(DE)		;  valid?	CP	'A'	JR	C,STUFCHR	; No - don't output it	DEC	DE		; Back one	LD	A,(DE)		; Pick up slashSTUFCHR	LD	(HL),A		; Xfer to TEMBUF	INC	HL	INC	DE	CP	CR+1		; Done?	JR	C,DUN	CP	':'	JR	Z,DUN	CP	'.'	JR	NZ,TLP;;	Found valid terminator - Is this a device?;DUN	DEC	HL		; Back up to term	POP	DE		; DE => FCB+0	LD	A,(DE)		; Device?	CP	'*'	JR	Z,DUN2		; Yes - done	LD	(HL),':'	; No, overwrite with ':'	INC	HL		; Bump pointer	LD	(DSPEC+1),HL	; Save drivespec location	INC	HLDUN2	LD	(HL),03H	; End with ETX	POP	HL		; HL => Disk I/O Buffer	POP	AF		; A = SVC #	LD	(SVCNUM+1),A	; Save SVC #;;	Issue supervisory call;	RST	28H		; Do it	PUSH	AF		; Save SVC condition	CALL	GETDRIV		; Get drive (in C) if file	JR	Z,DEVICE	; Z - this is a device;;	This is a file - did we @INIT it?;	LD	A,(SVCNUM+1)	; Get SVC #	CP	@INIT		; Is it @INIT?	JR	NZ,DEVICE	; No - don't worry;;	Was the @INIT successful?;	POP	AF		; Don't perform	PUSH	AF		;  a @CKDRV if you didn't	JR	Z,DO_CKDR	;  successfully @INIT it	CP	42		; LRL Open fault?	JR	NZ,DEVICE	; No - don't @CKDRV;;	@INIT was okay - is this a Write Prot disk?;DO_CKDR	@@CKDRV			; Write protected disk?	LD	A,15		; Init WP disk error code	JP	C,IOERR		; Yes - abort;;	Check status on @INIT we did;DEVICE	POP	AF		; Recover status	JR	Z,CHKPROT	; Check PROTection status;;	Ignore error #42, LRL Open Fault;	CP	42		; Ignore this error	RET	NZ		; NZ - Abort;;	Check if file has proper access;CHKPROT	BIT	7,(IX+00H)	; Is this a filespec?	JR	Z,OKYDOKY	; No - don't check	LD	A,(IX+01H)	; Get protection byte	AND	07H	LD	B,A		; Xfer to BSVCNUM	LD	A,$-$		; Gets SVC number	CP	@INIT		; Was it @INIT?	LD	A,B		; Get prot level back	JR	Z,INIT1		; Z - Must be < 5	CP	06H		; READ access?	JR	C,OKYDOKY	; Yes - Set Z and RETurn;;	Illegal access to protected file;ILLACC	@@CLOSE			; Close file	LD	A,19H		; File Access Denied	JP	IOERR		; Error regardless;INIT1	CP	05H		; Update Access?	JR	NC,ILLACC	; No - Illegal access;OKYDOKY	XOR	A		; Set Z flag	RET			; And RETurn;;	GETDRIV - Get drive # from FCB and converto to ASCII;GETDRIV	PUSH	DE		; Get FCB to	POP	IX		;   IX	LD	A,(DE)		; Device?	BIT	7,A	RET	Z		; Device - RETurn;;	Stuff drive # into buffer;	LD	A,(IX+06H)	LD	C,A		; Xfer to C	ADD	A,'0'		; Convert to ASCIIDSPEC	LD	($-$),A	RET			; RETurn with condition;;	PUTSOUR/PUTDEST - Create Src/Dest File/Dev specs;PUTSOUR	PUSH	HL		; Save HL	LD	HL,FROM		; Xfer there	JR	XBUFFPUTDEST	PUSH	HL		; Save HL	LD	HL,TO2;;	XBUFF - Transfer TEMBUF contents to user buffer;	HL => Destination of Filespec/Devspec;XBUFF	PUSH	DE		; Save FCB ptr	LD	DE,TEMBUF	; DE => Source	EX	DE,HL		; Swap for LDIR	LD	BC,15		; 15 bytes max	LDIR			; Transfer	POP	DE		; Get FCB back	POP	HL		; Recover buffer ptr	RET			; Done;;	CPYFILE - Display Copying/Appending message;CPYFILE	PUSH	HL		; Save registers	PUSH	DE	LD	HL,COPYMS	; "Copying : "APPFLAG	LD	A,$-$+01H	; Append or Copy?	OR	A	JR	NZ,ITSCOPY	LD	HL,APPDMS	; "Appending : "ITSCOPY	CALL	DSPLY	LD	HL,FROM		; Source	CALL	DSPLY	LD	HL,TO		; " to "	CALL	DSPLY	LD	C,CR		; End line	CALL	DISPB		; Display byte	POP	DE		; Restore regs	POP	HL	RET;;	GETLRL - Get LRL from a directory entry;	DE => FCB of filespec;	IX <= FCB of filespec;	A  <= LRL of file;GETLRL	PUSH	DE		; M28D0	POP	IX		; Xfer FCB to IX	LD	A,(IX+07H)	; Get DEC	AND	0E0H		; Calc rec number	ADD	A,04H		; Pt to LRL	LD	L,A	SYSBUF	LD	H,$-$		; Get high byte of SBUFF$	LD	A,(HL)		; Get LRL	RET;;	GETCLON - Recover cloning info from source;GETCLON	PUSH	DE	POP	IX		; Xfer FCB to IX	LD	A,(IX+07H)	; Get source DEC	AND	0E0H		; Point to start of rec	LD	L,A		; Point to core recordSYSBUF2	LD	H,$-$		; Hi byte of SBUFF$	LD	DE,CLONSAV	; Save clone info	LD	BC,3	LDIR	LD	A,13		; Point to password fields	ADD	A,L	LD	L,A	LD	BC,4		; Save them also	LDIR	RET;;	Calculate instruction based on drive #;M28FC	LD	B,A		; Get drive # in B	INC	B		; Increment	LD	A,3FH		; GOW_M2900	ADD	A,08H		; Add something	DJNZ	M2900		; Loop for # of times	RET			; return to caller;;	Calculate high byte of available memory;DOINIT	PUSH	HL		; save HL	@@FLAGS			; IY => System flags	PUSH	IY		; Save flags ptr	POP	DE		; Move it to DE	LD	HL,18H		; Point to YFLAG$	ADD	HL,DE	LD	(YFLAG1+1),HL	; Store in M25A4	LD	(YFLAG2+1),HL	;  and in M260A	LD	HL,0		; Clear HL	LD	B,L	BIT	1,(IY+02H)	; @CMNDR?	JR	Z,USEHI		; No - use HIGH$	INC	B		; Yes - use LOW$USEHI	@@HIGH$			; Get HIGH$/LOW$;;	Stuff high byte into memory check locations;	INC	HL		; 256 byte block	DEC	H	LD	A,H		; Set up test bytes	LD	(RDREC3+1),A	LD	(RDREC5+1),A	LD	(GEOF6+1),A;;	Pick up high byte of System Buffer (SBUFF$);	LD	BC,0		; DEC=0, Drive=0	@@DIRRD			; Read in BOOT/SYS	LD	A,H		; Get high byte of SBUFF$	LD	(SYSBUF+1),A	; Stuff away for LRL	LD	(SYSBUF2+1),A	; Stuff away for CLONE;;	Reset PAUSE and ENTER bits;	CALL	RESKFLG		; Reset bits 1-2	POP	HL	RET;;	GEOF5 - Write out the last sector of destination;GEOF5	LD	A,H		; Get hi-order pointer	CP	BUF1<-8		; Same as start?	RET	Z		; Ret if finished;;	At the end of buffer area?;GEOF6	CP	$-$		; GEOF6+1 = MSB of topM2947	EQU	$-1		;GEOF6+1	RET	Z		; Return if finished;;	Flash "Insert Dest Disk" & write remainder;	CALL	PMTDST		; Prompt destination	LD	B,H		; Save highest used	LD	HL,BUF1		; Pt to start;;	Loop to write out remainder of dest file;GEOF7	LD	(FCB2+3),HL	; Set dest buffer address	LD	DE,FCB2		; DE => Dest FCB	@@WRITE			; Write  a record	JP	NZ,IOERR	; Jump on write error;;	Finished writing?;	INC	H		; Bump buff ptr	LD	A,H	CP	B		; Finished?	JR	NZ,GEOF7	; Loop if not	RET			; Return;;	CKBRK - Check for BREAK;	NZ - <BREAK> key was pressed;CKBRK	@@CKBRKC		; BREAK hit?	RET			; Z=No NZ=Yes;;	PMTSYS - Prompt for a system disk;PMTSYS	LD	A,(XPARM+1)	; X parameter entered?	OR	A	RET	Z		; No - no need to prompt;;	If xfer drive number isn't 0 - don't prompt;XFRDRV	LD	A,$-$		; Contains drive #M296C	EQU	$-1	OR	A		; Is it zero?	RET	NZ		; Return if not SYSTEM drive;;	Flash "Insert system disk" message;	PUSH	HL		; Save HL	LD	HL,PMTSYS$	; "Insert SYSTEM disk"	CALL	FLASH		; Flash and RET if ENTER	POP	HL		; Restore HL	RET;;	PMTSRC - Prompt for source disk;PMTSRC	LD	A,(XPARM+1)	; X parameter entered?	OR	A	RET	Z		; No - don't display it;;	Flash "Insert Source Disk" message;	PUSH	HL		; Save HL	LD	HL,PMTSRC$	; Init for source	CALL	FLASH		; Dsp msg & await reply;;	Read in GAT from the source disk;	LD	A,(XFRDRV+1)	; Get drive	LD	C,A		; Stuff in C	CALL	RDGAT		; Get GAT;;	Is this the correct source disk?;	LD	HL,GAT+0CEH	; HL => Name & Date field	LD	DE,SRCSTR	; DE => Original source	LD	B,12H		; 18 bytes	CALL	CPRHLDE		; Same source disk?	POP	HL		; Restore HL	JR	NZ,PMTSRC	; Re-request if not match	RET			; Okay;;	PMTDST - Prompt for destination disk;PMTDST	LD	A,(XPARM+1)	; X param entered?	OR	A	RET	Z		; Ret if not;;	Flash "Insert Destination Disk" message;	PUSH	HL	LD	HL,PMTDST$	; Pt to msg	CALL	FLASH		; Prompt & wait reply;;	Read in GAT from destination disk;	LD	A,(XFRDRV+1)	; Get drive #	LD	C,A		; Stuff in C	CALL	RDGAT		; Read the GAT;;	Is this the same destination disk?;	LD	HL,GAT+0CEH	; HL => Name & Date field	LD	DE,DSTSTR	; DE => Original source	LD	B,12H		; 18 bytes	CALL	CPRHLDE		; Same dest disk?	POP	HL		; Recover HL	JR	NZ,PMTDST	; Re-request if no match	RET			; Okay;;	CPRHLDE - Compare string at HL to string at DE;	B => Number of characters to compare;	Z - Set if strings match;CPRHLDE	LD	A,(DE)		; Get character at DE	CP	(HL)		; Same?	RET	NZ		; Ret NZ if no match	INC	HL	INC	DE	DJNZ	CPRHLDE		; Check (B) characters	RET			; Matched - return Z;;	FLASH & FLASH0 - Flash a message string;	HL => Message string to flash;FLASH0	CALL	RESKFLG		; Reset Pause and EnterFLASH	LD	BC,16893	; Delay count	@@PAUSE;;	Wait for no Enter or Break;	LD	A,(IY+KFLAG$)	; Get KFLAG$	AND	4!1		; Wait until no ENTER!BRK	JR	NZ,FLASH0	; Still down, go flash	CALL	RESKFLG		; Reset;;	Display the msg and wait 1/4 second;FLS1	CALL	DSPLY		; Display msg	LD	BC,4000H	; Delay 4000H iterations	CALL	FLS2		;  & scan for Break,Enter;;	Erase the message and wait;	LD	C,EL		; Erase line	CALL	DISPB	LD	BC,3333H	; Delay 3333H iterations	CALL	FLS2		;  & scan for Enter,Break	JR	FLS1		; Loop if neither;;	FLS2 - Delay BC loops & scan for ENTER;FLS2	CALL	CKBRK		; Check for BREAK	JP	NZ,ABORT	; Get out if pressed;;	Was ENTER pressed?	BIT	2,(IY+KFLAG$)	; Enter pressed?	JR	NZ,FLS4		; Go on ENTER down;;	Nothing hit - count down;	DEC	BC		; Decrememnt count	LD	A,B		; Done?	OR	C	JR	NZ,FLS2		; No - check again	RET			; Yes - return;;	ENTER hit - Pop ret addr & clear type ahead;FLS4	POP	AF		; Pop return addressCLRTYPE	@@KBD			; Clear type ahead	JR	Z,CLRTYPE	; Good - get another	OR	A		; Okay?	JP	NZ,IOERR	; No - I/O Error;;	Erase message line;	LD	C,EL		; Erase line	CALL	DISPB		; Fall back into RESKFLG;;	RESKFLG - Reset PAUSE and ENTER bits in KFLAG;RESKFLG	@@FLAGS			; IY => Flag Table	LD	A,(IY+KFLAG$)	; Get KFLAG$	AND	0F9H		; Reset bits 2 and 1	LD	(IY+KFLAG$),A	; Stuff back in	RET;;	DISPB - Output a byte to the Video;DISPB	@@DSP			; Output byte	RET	Z		; Good - return	JP	IOERR		; Bad - I/O error;;	DSPLY - display a line to video;DSPLY	@@DSPLY			; Display	RET	Z		; Good - return	JP	IOERR		; Bad - I/O error;;	STOP - Display transfer aborted and abort;STOP	LD	HL,STOP$	@@LOGOT			; Log message	CALL	PMTSYS		; Prompt for SYSTEM disk	JP	ABORT		; Abort;;	GETSYS2 - Bring in SYS2/SYS;GETSYS2	LD	A,84H	RST	28H;;	GETSYS3 - Bring in SYS3/SYS;GETSYS3	LD	A,85H	RST	28H;;	CKDEV - Is the source or destination a device?;	Z - Either is;CKDEV	LD	A,(FCB1)	; Is source a device?	CP	'*'	RET	Z	LD	A,(FCB2)	; Is dest a device?	CP	'*'	RET;;	RDGAT - Read GAT of drive (C);RDGAT	PUSH	DE		; Save registers	PUSH	HL	PUSH	IY;;	Set D = Cyl, E = Sector, HL => Buffer;	@@GTDCT			; Point IY to DCT	LD	D,(IY+09H)	; Get dir cyl in D	LD	E,00H		; GAT is sector 0	LD	HL,GAT		; HL => GAT I/O Buffer	@@RDSSC			; Read dir sector;;	Restore registers;	POP	IY	POP	HL	POP	DE	LD	A,14H		; Else reset to GAT error	RET			; Return with condition;;	OPENDES - Open destination file;OPENDES	LD	HL,BUF2		; HL => Dest I/O buffer	LD	DE,FCB2		; DE => Dest FCB	JR	OPENFIL		; Open the file;;	INITDES - INIT the destination file;INITDES	LD	A,@INIT	JR	INITFIL;;	OPENSRC - Open source file;OPENSRC	LD	DE,FCB1		; DE => Source FCB;;	Set the file OPEN inhibit flag;	@@FLAGS	SET	0,(IY+SFLAG$)	; Set file open inhibit;OPENSR2	LD	HL,BUF1OPENFIL	LD	A,@OPENINITFIL	LD	B,00H;;	OPEN or INIT the file;GETFILE	CALL	DOSVC		; INIT or OPEN the file	RET	Z		; Return with Z set	JP	IOERR		; Otherwise I/O error;;	Error & Informative message strings;COPYMS	DB	'Copying: ',ETXAPPDMS	DB	'Appending: ',ETXDIFLRL$	DB	'Files have different LRLs',CRDSTREQ$	DB	'Destination spec required',CRSTOP$	DB	BL,'Transfer aborted',CRSPCREQ$	DB	'File spec required',CRNOINDO$	DB	'Invalid command during <DO> processing',CRSAMERR$	DB	'Source and destination disks are the same',CRPMTSYS$	DB	BL,EL,' Insert SYSTEM disk <ENTER>',BL,ETXPMTSRC$	DB	BL,EL,' Insert SOURCE disk in drive :'SRC_DR	DB	'0 and press <ENTER>',BL,ETXPMTDST$	DB	BL,EL,' Insert DESTINATION disk in drive :'DEST_DR	DB	'0 and press <ENTER>',BL,ETX;;	APPEND parameter table;APPTBL	DB	80H		; Use new @PARAM;	DB	FLAG!ABB!5,'STRIP',0	DW	SPARM+1;	DB	FLAG!ABB!4,'ECHO',0	DW	EPARM+1;	DB	00H		; End of APPEND parm table;;	COPY parameter table;COPYTBL	DB	80H		; New @PARAM	DB	FLAG!ABB!4,'ECHO',0	DW	EPARM+1	DB	NUM!ABB!3,'LRL',0	DW	LPARM+1	DB	FLAG!ABB!5,'CLONE',0	DW	CPARM+1	DB	FLAG!1,'X',0	DW	XPARM+1;	DB	00H		; End of COPY parm table;;	I/O and Storage buffers;FCB2	DB	00H		; Show closed on LOAD	DS	31TEMBUF	DS	16FROM	DS	16TO	DB	' to 'TO2	DS	16FCB1	DB	0	DS	31SRCSTR	DS	18DSTSTR	DS	18CLONSAV	DS	7;	ORG	$<-8+1<+8;GAT	DS	256BUF1	DS	256BUF2	DS	256;