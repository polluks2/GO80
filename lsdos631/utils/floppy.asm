; ***************************************************************; * Filename: FLOPPY/ASM					*; * Revision: 06.03.01						*; * Rev Date: 10 Dec 97						*; ***************************************************************; * Install a standard DCT into a logical drive slot		*; *								*; ***************************************************************;	TITLE	<FLOPPY/DCT - LS-DOS 6.3>;;	Program installs a standard DCT into a logical;	drive slot as specified by:;	 SYSTEM (DRIVE=d,DRIVER="FLOPPY");;	The default DCT is taken from slot 0 of the;	System Information Sector (70H-79H).;CR	EQU	13LF	EQU	10;*GET	SVCMAC			; System SVC macros*GET	COPYCOM			; Copyright message;	ORG	2400H;BEGIN	@@CKBRKC	JR	Z,BEGINA	; Continue if no break	LD	HL,-1		;   else abort	RET;BEGINA	PUSH	DE		; Save the DCT location	@@DSPLY	HELLO$		; Display the signon	POP	DELDOS	LD	A,D		; Make sure drive #	OR	E		;   was entered	JP	Z,NODRV		; Go if no drive;;	Check if entry from SET;	@@FLAGS	BIT	3,(IY+'C'-'A')	; System request?	JP	Z,VIASET	; Exit if not	LD	A,(DE)	CP	0C9H		; Is drive disabled?	JP	NZ,ACTIVE	; Must be disabled	PUSH	DE		; Save DCT	LD	DE,FDMOD$	; Point to FDD driver name	@@GTMOD			; Is module in memory?	JP	NZ,NOFD		; Go if not!	LD	(SAV$FD),HL	; Save location of $FD	CALL	GETCFG	JP	NZ,IOERR	BIT	4,(IY+'L'-'A')	; Suppress 8" queries?	JR	NZ,LDOS3DRVTYP	LD	HL,DRVTYP$	; "Enter drive code	@@DSPLY	LD	HL,BUF		; Input buffer	LD	BC,1<8		; Allow 1 char only	@@KEYIN			; Get response	JP	C,BREAK		; Quit on break	LD	A,(HL)		; Get user response	SUB	'0'		; Convert to binary	CP	02H		; Make sure requested	JR	NC,DRVTYP	;   type is supported	LD	(LX805+1),A;;	Prompt user for physical drive address;LDOS3	LD	HL,DRVADR$	; "Enter physical...	@@DSPLY	LD	HL,BUF		; Input buffer	LD	BC,1<8		; Allow 1 char	@@KEYIN			; Get user input	JP	C,BREAK		; Quit on break key	LD	A,(HL)		; Get response value	SUB	'1'		; Adjust to binary	CP	3+1		; Make sure in range	JR	NC,LDOS3	; Redo if it's not;;	Convert drive address to select code;	CP	03H		; Convert 3 to 4	CCF	ADC	A,00H	CP	01H		; Convert <0,1,2,4>	RLA			;   to <1,2,4,8>	LD	B,A		; Hang on to request;;	Index the default drive code table;LX805	IF	@MOD2	LD	A,1		; 8"	ENDIF	IF	@MOD4	LD	A,00H		; 5"	ENDIF	LD	C,A	ADD	A,A		; Times 2	ADD	A,C		; Times 3	ADD	A,A		; Times 6	ADD	A,C		; Times 7	LD	HL,DRVTAB$	; Index into 5" or 8"	ADD	A,L		;    default table	LD	L,A	ADC	A,H	SUB	L	LD	H,A	INC	HL	LD	A,(HL)		; Get default DCT+4	AND	0F0H		; Remove drive select	OR	B		; Merge in new one	LD	(HL),A		; Update the DCT	DEC	HL	LD	BC,7		; Init for 7 byte move	POP	DE		; DE => DCT$	PUSH	DE		; Save DCT$ pointer	INC	DE	INC	DE	INC	DE		; Point to DCT+3	LDIR			; Move the new data	POP	DE		; Get DCT back	PUSH	DE		; Save start again	LD	A,0C3H		; Jump code	LD	(DE),A		; Store at DCT+0	INC	DE		; Point to address	LD	HL,$-$		; Get $FD addressSAV$FD	EQU	$-2	EX	DE,HL		; Swap addresses	LD	(HL),E		; Store $FD low byte	INC	HL	LD	(HL),D		; Store $FD high byte	POP	DE	LD	C,00H		; Drive 0	@@GTDCT			; Get DCT	PUSH	IY		; Pass to HL	POP	HL	EX	DE,HL		; HL => start of DCTs	OR	A		; Clear carry	SBC	HL,DE		; HL = offset from start	LD	C,10		; DCT length	@@DIV16			; HL+A = HL/C	LD	C,L		; Result = drive #	@@RSTOR			; Restore drive	LD	HL,0		; Set no error return	RET;;	Routines to read/write the config sector;GETCFG	LD	HL,BUFFER	; Use buffer for I/O	IF	@MOD2	LD	C,L		; Pass drive #	PUSH	IY		; Save IY	@@GTDCT			; Get DCT	LD	A,(IY+3)	; Get data	AND	28H		; Bit 5/3	CP	20H		; 8" floppy?	JR	NZ,SETSYS1	; Go if not	LD	A,(IY+4)	; Fetch data	AND	50H		; Bit 6/4	CP	40H		; DD not alien?	NR	NZ,SETSYS1	; Go if not	LD	D,(IY+9)	; Get dir cyl	LD	E,L		; Sector 0	@@RDSEC			; Read sector	CP	6		; Directory?	JR	NZ,SETSYS2	; Nope, error	LD	A,(BUFFER+0CDH)	; Get GAT data	BIT	7,A		; System disk?SETSYS1	LD	DE,8<8+2	; Normal sysinfo sector	JR	NZ,$+3		; Go if data disk	INC	D		;   else sysinfo on 1	XOR	A		; Set Z for no errorSETSYS2	POP	IY		; Recover DCT	RET	NZ		; Go if error	ENDIF;	IF	@MOD4	LD	DE,0<8+2	; Get config sector	ENDIF	LD	C,L		;   of system drive	@@RDSEC			; Read it into memory	RET;IOERR	LD	L,A		; Error # to HL	LD	H,00H	OR	0C0H		; Short msg, return	LD	C,A	@@ERROR			; Display the error	@@CKBRKC		; Clear any BREAK	RET;;	Internal error display routine;VIASET	LD	HL,VIASET$	; "Install with SYSTEM	DB	0DDHACTIVE	LD	HL,ACTIVE$	; "Drive in use	DB	0DDHBREAK	LD	HL,BREAK$	; "Command aborted	DB	0DDHNODRV	LD	HL,NODRV$	; "Need drive #	DB	0DDHNOFD	LD	HL,NOFD$	; "FD driver not found	@@LOGOT	LD	HL,-1		; Set abort code	@@CKBRKC		; Clear any break	RET;;	Messages and data storage;HELLO$	DB	0AH,'FLOPPY Setup'*GET	CLIENTVIASET$	DB	'Must install via SYSTEM (DRIVER=',0DHACTIVE$	DB	'Drive slot is already enabled',0DHNODRV$	DB	'Logical drive number required',0DHNOFD$	DB	'Floppy driver not present in memory',0DHBREAK$	DB	'Command aborted',0DHFDMOD$	DB	'$FD',00HDRVTYP$	DB	'   Enter drive code (0=5", 1=8") > ',03HDRVADR$	DB	'   Enter drive I/O address <1-4> > ',03H;DRVTAB$;;	5" Drive Table;	DB	01000100B	; 5", 6ms, delay=n	DB	01000000B	; DDEN	DB	0FFH		; Start cylinder	DB	40-1		; 40 track drive	DB	18-1		; 18 sectors/cyl	DB	3-1<5+6-1	; 6 sec/gran, 3 gran/cyl	DB	40/2		; Directory track;;	8" Drive Table;	IF	@MOD4	DB	00100001B	; 8", 6ms step	DB	01000000B	; DDEN	DB	0FFH		; Start cylinder	DB	77-1		; 77 track drive	DB	16-1		; 16 sec/cyl	DB	2-1<5+8-1	; 8 sec/gran, 2 gran/cyl	DB	77/2		; Directory track	ENDIF;	IF	@MOD2	DB	01100010B	; +3 - 8", DD, 10ms, delay	DB	01000000B	; +4 - DDEN capable	DB	4CH		; +5 - Current cyl	DB	77-1		; +6 - High cylinder	DB	0<5+29		; +7 - sides + high sec	DB	2<5+9		; +8 - gran/cyl + sec/grn	DB	77/2		; +9 - Dir cylinder	ENDIF;;BUF	DS	2		;EQU 2670H	ORG	$<-8+1<+8BUFFER	DS	256;	END	BEGIN