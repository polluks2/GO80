;****************************************************************;* Filename: FILPOSN/ASM					*;* Rev Date: 30 Nov 97						*;* Revision: 6.3.1						*;****************************************************************;* File Positioning Subroutines					*;*								*;****************************************************************;;	Entry for byte I/O from @GET and @PUT;BYTEIO	PUSH	IX	POP	DE		;Transfer DCB to DE	CALL	CKOPEN@		;Check file open, save regs	SET	7,(IX+1)	;Denote byte or LRec	LD	A,B		;Get type code and test	CP	2		;  for get/put	LD	A,C	JR	Z,WRCHAR	;Go on Put	JR	NC,IORETZ	;Ignore if CTL;;	Get a byte from a file;RDCHAR	CALL	CKEOF1		;Check for end of file	RET	NZ		;Return if at end	BIT	5,(IX+1)	;If buffer not current,	CALL	NZ,NSEC1	;  read next sector	RET	NZ	CALL	BFRPOS		;Point to byte posn in buff	LD	A,(DE)		;pickup the byte	INC	(IX+5)		;Inc NEXT pointer	CALL	Z,SET5		;Set bit 5 if zero	CP	A		;Set Z flag -- no error	RET;SET5	SET	5,(IX+1)	RET;;	Write a byte to a file;WRCHAR	BIT	6,(IX+0)	;Prot level gives write access?	JP	Z,RWRIT3	;  go if not	PUSH	AF		;Save byte	BIT	5,(IX+1)	;Get next sector if	CALL	NZ,WRCH2	;  buffer is not current	JR	Z,WRCH1		;Skip if read was okay	EX	(SP),HL		;Pop stack but keep	POP	HL		;  error # in AF	RET;WRCH1	CALL	BFRPOS		;Next buffer byte posn	POP	AF	LD	(DE),A		;Stuff the byte	SET	4,(IX+1)	;Buffer contains updated data	INC	(IX+5)		;Inc NEXT byte	PUSH	AF		;Save Z or NZ flag	CALL	Z,SET5		;Set bit 5 if offset 0	CALL	CKEOF1		;Check for EOF	JR	NZ,ATEOFW	;Go if there	BIT	6,(IX+1)	;Jump if EOF set to next	JR	NZ,DNTSET	;  only if at EOFATEOFW	LD	(IX+8),C	;Set EOF	LD	(IX+12),L	LD	(IX+13),HDNTSET	POP	AF		;Restore offset flag	JR	Z,RWRIT1	;Go to write sector if 00IORETZ	XOR	A		;Set Z flag - no error	RET;WRCH2	LD	A,(IX+1)	;Check if UPD bit set	AND	7		;Mask for prot level	CP	4		;Check for UPD	JR	NZ,NSEC1	;Bypass EOF check on > UPDNXTSECT CALL	CKEOF1		;Check for end of file	RET	NZ		;Can't extend in update modeNSEC1	LD	A,(IX+1)	;Read access?	AND	7	CP	6	JR	NC,RWRIT3	;"Illegal access..." if notNSEC2	CALL	IOREC		;Calc cylinder/sector	RET	NZ	RES	5,(IX+1)	;Show buffer current	LD	L,(IX+3)	;Pick up buffer address	LD	H,(IX+4)	CALL	@RDSEC		;Read the sector	JR	Z,BUMPNRN	;Go if no error	CP	6		;Test for prot sector	RET	NZ		;Quit if error not 6BUMPNRN INC	(IX+10)		;Inc the NRN ptr LSB	JR	NZ,ZEROA@	INC	(IX+11)		;  and MSB if necessaryZEROA@	XOR	A	RET;;	Repositioning needs to write out the buffer;RWRIT@	LD	A,(IX+1)	AND	90H		;Test for non-sector I/O and	CP	90H		;  buffer contents changed	JR	Z,RWRIT1	;Go if conditions true	JR	ZEROA@		;  else no need to write@RWRIT	CALL	CKOPEN@		;Check file open, save regsRWRIT1	CALL	GETNRN		;pick up NRN	LD	A,H		;Ignore if rewound	OR	L	RET	Z	DEC	HL		;Dec & reset NRN	LD	(IX+10),L	LD	(IX+11),H;;	Check access protection level;RWRIT2	LD	A,(IX+1)	;Get prot	AND	7	CP	5		;Update access or better?	JR	C,RWRIT4RWRIT3	LD	A,25H		;Illegal access error code	OR	A		;Return NZ	RET;RWRIT4	AND	4		;If UPDATE access, then	JR	Z,RWRIT5	;  can't extend if at EOF	CALL	CKEOF1	JR	NZ,RWRIT3	;  so show "Illegal access...RWRIT5	CALL	IOREC		;Calc cylinder and sector	RET	NZ	LD	L,(IX+3)	;p/u buffer address	LD	H,(IX+4)	RES	4,(IX+1)	;Altered buffer flag off	SET	2,(IX+0)	;Show modification done	CALL	@WRSEC		;  for directory mod flag	RET	NZVEROP	LD	A,0		;Verify operation if set	OR	A	CALL	NZ,@VRSEC	;Verify if no write error	RET	NZ		;Return with Write/Verify error	CALL	BUMPNRN		;Increment NRN;;	Check if ERN to be set to NRN;	Should be done for byte IO, but not random IO;	CALL	CKEOF1		;Returns 0 if not at EOF	DEC	A		;Set bit 6 if retcode=0	AND	(IX+1)		;if IX+1,b6 set, then	AND	40H		;  don't update EOF unless	JR	NZ,ZEROA@	;  at or past the old EOFYESEOF	LD	(IX+12),L	;Update ERN	LD	(IX+13),H	BIT	3,(IX+1)	;Test if ending '!'	JR	NZ,WEOF1	;update dir if so	RET;GETNRN	LD	L,(IX+10)	;Xfer NRN to HL	LD	H,(IX+11)	RET;BFRPOS	LD	A,(IX+5)	;p/u byte offset in buffer	ADD	A,(IX+3)	;Add to buffer LSB	LD	E,A	LD	A,(IX+4)	;  and adjust buffer MSB	ADC	A,0		;  if needed	LD	D,A		;Return DE = posn	RET@DTHDLR CALL	@DATE		; @DATE handler	PUSH	HL		; Points to end of date buffer	DEC	HL		; back up 2	DEC	HL		; Point to 10s of years	LD	A,(HL)		; Get digit	CP	'9'+1		; greater than 9?	JR	C,M142E		; jump if not	SUB	0AH		; Convert back to decimal	LD	(HL),A		; Store in bufferM142E	POP	HL		; Recover date ptr	RET			; Return to caller;;	Entry to write an end-of-file mark;@WEOF	CALL	CKOPEN@	CALL	RWRIT@		;Write buffer if neededWEOF1	LD	B,(IX+7)	;p/u DEC of FPDE	LD	C,(IX+6)	;p/u drive #	CALL	@DIRRD		;Read file's dir record	RET	NZ		;Back if read erro	INC	L		;pt to ERN offset	INC	L	INC	L	LD	A,(IX+8)	;p/u EOF offset	LD	(HL),A		;put in direc	LD	DE,17		;point to EOF in dir	ADD	HL,DE	LD	A,(IX+12)	;p/u low EOF	LD	(HL),A		;put EOF in direc	INC	HL	LD	A,(IX+13)	;p/u high EOF	LD	(HL),A		;put EOF in direc	JP	@DIRWR;;	Entry to Skip record routine;@SKIP	CALL	@LOC		;Locate next record	INC	BC		;Step past it;;	Entry to Position to record routine;@POSN	CALL	CKOPEN@	SET	6,(IX+1)	;UPD EOF only if NRN>EOF	BIT	7,(IX+1)	;Jump if sector I/O only	JR	Z,POSN1	LD	H,B		;Record ptr to HL	LD	L,C	OR	(IX+9)		;p/u LRL	JR	Z,POSN1		;Skip next if lrl=256	CALL	@MUL16		;Calc sector & offset	LD	B,H		;Physical sector -> BC	LD	C,L	LD	(IX+5),A	;Set byte ptr	BIT	5,(IX+1)	;Jump if buffer does not	JR	NZ,POSN2	;  contain current sector	CALL	GETNRN		;P/u the nrn	SCF	SBC	HL,BC	JR	Z,$CKEOF	;Pass on to ckeofPOSN1	LD	(IX+5),A	;Offset in bufferPOSN2	PUSH	BCPOSN2A	CALL	RWRIT@		;Write current if needed	POP	BC		;  before moving	RET	NZ		;Back on write error	LD	(IX+10),C	;NRN	LD	(IX+11),B	CALL	SET5		;Show bfr does not$CKEOF	JP	CKEOF1		;  contain current sector;;	Entry to force a physical read;@RREAD	CALL	CKOPEN@	LD	C,1		;Cause ADJUST to bump;				;  NRN when calledBKSP1	CALL	GETNRN		;Get current record #	LD	A,H		;If file is rewound	OR	L		;  then ignore the req	JR	Z,BKSP0		;  & force offset = 0	DEC	HL		;Back up by one	CALL	ADJ2		;Ret if sector i/o only,				; else bump fwd if rread				; then back up if bit 5=0	PUSH	HL		;Will be popped into bc	JR	POSN2A		;Finish the job;;	Entry to backspace one logical record;@BKSP	CALL	CKOPEN@	LD	C,A		;Keep ADJUST from bumping	LD	B,(IX+9)	;p/u LRL	OR	B		;Is it a 0?	JR	Z,BKSP1		;Go if so	LD	A,(IX+5)	;P/U next byte pointer	SUB	B		;Sub one record lengthBKSP0	LD	(IX+5),A	JR	C,BKSP1		;Go if crossed sec bdry	XOR	A		;  else all done	RET;;	Entry to rewind to beginning;@REW	CALL	CKOPEN@	LD	B,A		;zero NRN	LD	C,A	JR	POSN1		;will also zero offset;;	Entry to position to EOF;@PEOF	CALL	CKOPEN@	LD	C,(IX+12)	;ERN to BC	LD	B,(IX+13)	OR	(IX+8)		;p/u EOF byte	JR	Z,POSN1		;go if full sector	DEC	BC		;point to last rec	JR	POSN1		;use POSN to get end;;	Entry to locate current record number;@LOC	CALL	CKOPEN@	CALL	GETNRN		;pick up nrn	CALL	ADJUST		;get offset and adj nrnLOC1	LD	E,(IX+9)	;p/u lrl	LD	A,E		;test lrl for 0	OR	A		;if zero, then five NRN	JR	Z,LOC3		;LRL=0, NRN is correct	INC	C		;if offset is zero,	DEC	C		; then it's at 256,	JR	Z,LOC2		; and we don't dec nrn	DEC	HL;;	Divide the three byte pointer (HLC) by the LRL;LOC2	CALL	@DIV16		;Divide (nrn-1)/lrl	LD	B,L		;Save high order result	LD	D,H		;Save possible overflow	LD	H,A		;Prepare 2nd dividend	LD	L,C	LD	A,E		;Get lrl divisor again	CALL	@DIV16	LD	H,B		;Xfer high order result	OR	A		;If remainder, we have a	JR	Z,LOC2A		;  partial record to round	INC	HL		;  up to next record #LOC2A	LD	A,D		;Zfer possible overflowLOC3	POP	BC		;Pop RESTREG return address	EX	(SP),HL		;Exchange value with BC	PUSH	BC;	IF	@MOD4ORARET@ EQU	$	ENDIF	OR	A	RET;;	Entry to ocate the end-of-file record;@LOF	CALL	CKOPEN@	LD	L,(IX+12)	;ERN	LD	H,(IX+13)	LD	C,(IX+8)	;EOF byte	JR	LOC1		;handle all LRLs;;	Entry to read a record;@READ	CALL	CKOPEN@	PUSH	HL	CALL	RWRIT@		;Write buffer if needed	POP	HL	RET	NZ		;Back on write error	LD	B,(IX+9)	;p/u LRL	LD	A,B		;if LRL=256, just	OR	A	JP	Z,NXTSECT	;  get the next sectorRDREC	PUSH	HL		;Save buffer posn	PUSH	BC		;Save lrl	CALL	RDCHAR		;Read next byte	POP	BC	POP	HL	RET	NZ		;Back on read error	LD	(HL),A		;Put char in buffer	INC	HL	DJNZ	RDREC		;Loop for entire record	RET;;	Entry to write a record;@WRITE	CALL	CKOPEN@WRIT1	LD	(VEROP+1),A	;Turn on/off verify	LD	B,(IX+9)	;Get LRL	LD	A,B		;Bypass if LRL=256	OR	A	JP	Z,RWRIT2	PUSH	HL		;Save some FCB values	LD	H,(IX+5)	;Get buffer offset loc	LD	L,(IX+8)	;Get eof offset	EX	(SP),HL		;Swap those to stackWRREC	LD	A,(HL)		;Pass the logical record	INC	HL		;  to the writing routine	PUSH	HL		;  BYTE BY BYTE	PUSH	BC	CALL	WRCHAR	POP	BC	POP	HL	JR	NZ,WRERROR	;EXIT AND FIX FCB	DJNZ	WRREC		;LOOP FOR ENTIRE RECORD	EX	(SP),HL		;REMOVE STORED FCB INFO	POP	HL		;RECOVER HL	RETWRERROR EX	(SP),HL		;GET FCB VALUES	LD	(IX+5),H	;  AND PUT THEM BACK	LD	(IX+8),L	POP	HL		;RECOVER HL	RET			;RETURN WITH ERROR;;	Entry to verify after writing a record;@VER	CALL	CKOPEN@	INC	A		;SET VERIFY BYTE	JR	WRIT1LNKFCB@ SCF			;INIT TO FORCE FILE OPEN	DB	0D2H		;  TEST BY JP NC,xxxxCKOPEN@ LD	A,(DE)		;IGNORE IF FROM LNKFCB	RLCA			;TEST HI BIT OF FCB	EX	(SP),HL	LD	(JRET$),HL	;SAVE RET	LD	(JDCB$),DE	;SAVE DCB	EX	(SP),HL	JR	NC,NOTOPEN	;GO IF NOT AN OPEN FCB	POP	AF		;GET RETURN	PUSH	DE		;DCB ADDR TO IX	EX	(SP),IX	PUSH	HL		;SAVE REGS	PUSH	DE	PUSH	BC	PUSH	HL		;ESTABLISH RET ADDR	LD	HL,RESTREG	;  TO RESTORE REGISTERS	EX	(SP),HL	PUSH	AF		;PUT BACK RET ADDR	XOR	A		;FIX A AND FLAGS	RET			;GO BACK;NOTOPEN POP	AF	LD	A,26H		;FILE NOT OPEN	OR	A	RET;RESTREG POP	BC		;POP BACK REGISTERS SAVED	POP	DE		;  IN CKOPEN@	POP	HL	POP	IX	RET;;	Entry to check if at end of file;@CKEOF	CALL	CKOPEN@CKEOF1	CALL	GETNRN		;GET NRN INTO HL	PUSH	HL	CALL	ADJUST		;ADJUST FOR SPECIAL CASES	LD	A,H		;COMPARE HIGH BYTE	CP	(IX+13)	JR	NZ,CKEOF2	;GO IF NOT EQUAL	LD	A,L		;NOW LOW	CP	(IX+12)	JR	NZ,CKEOF2	DEC	C		;ADJUST FOR 0=256	LD	A,(IX+8)	;COMPARE OFFSET	DEC	A	SUB	C	CCF	INC	BC		;RESTORE OLD C VALUECKEOF2	POP	HL		;RESTORE UNADJUSTED NRN	LD	A,1DH		;REC # OUT OF RANGE	JR	NZ,CKEOF3	;GO IF NOT AT EOF	DEC	A		;1C = EOF ENCOUNTERED	RETCKEOF3	RET	NC		;RETURN WITH ERROR	XOR	A		;OTHERWISE NO ERROR	RET;;	File positioning adjustment routines;ADJUST	EQU	$		;ENTRY FROM @CKEOF AND @LOC	LD	C,(IX+5)	;GET OFFSETADJ2	EQU	$		;ENTRY FROM @BKSP/@RREAD	BIT	7,(IX+1)	;SECTOR I/O ONLY?	RET	Z		;NO ADJUSTMENT NECESSARY	LD	A,C		;OFFSET = 0? (OR RREAD)	OR	A	JR	Z,ADJ2A		;GO IF ZERO	INC	HL		;ADJUSTADJ2A	BIT	5,(IX+1)	;CHECK MAGIC BIT	RET	NZ		;GO IF SET	DEC	HL		;ADJUST	RET;;	Calculate the cylinder/sector of needed record;IOREC	CALL	GETNRN		;GET RECORD NUMBER	CALL	@DCTBYT-5	;GET # SECTORS / GRAN	AND	1FH	INC	A	CALL	@DIV16		;BY # SECTORS/GRAN	LD	(CALS5+1),A	;SAVE REMAINDER (SECTOR OFFSET)	PUSH	IX		;XFER FCB TO HL	EX	(SP),HL	LD	BC,14		;POINT TO 1ST EXTENT INFO	ADD	HL,BC	POP	BC		;POP GRAN PTR HL INTO BC	LD	A,5		;INIT TO CHECK 4 EXTENTS	LD	DE,0		;  & EXTENDED FXDE PTRGREC1	PUSH	AF	LD	A,(HL)		;GET STARTING CYL BYTE	INC	HL		;  & BYPASS IF FF	INC	A	JR	Z,GREC2	PUSH	HL		;XFER THE # OF GRANS UP	LD	H,D		;  TO BUT NOT INCLUDING	LD	L,E		;  THIS EXTENT INTO HL	XOR	A		;SUB GRAN POINTER FROM	SBC	HL,BC		;  CUMULATIVE FIGURE & GO	JR	C,GREC3		;  IF NOT IN PREVIOUS EXT	POP	HL	JR	Z,CALCSECGREC2	INC	HL	POP	AF	DEC	A	JR	Z,GREC4		;JUMP WHEN ALL QUADS CHECKED	LD	E,(HL)		;GET CUMULATIVE # OF GRANS	INC	HL		;  UP TO BUT NOT INCLUDING	LD	D,(HL)		;  THIS EXTENT	INC	HL	JR	GREC1GREC3	INC	H		;WITHIN 256 GRANS?	LD	A,L		;XFER LOW ORDER DIFFERENCE	POP	HL		;RECOVER # CONTIGUOUS GRANS;				;  IN THIS EXTENT	JR	NZ,GREC2	;GO IF NOT WITHIN 256	PUSH	DE		;SAVE CUMULATIVE COUNT	LD	E,A		;XFER GRAN DIFF (NEG)	LD	A,(HL)		;GET NUM GRANS	AND	1FH		;  IN THIS EXTENT	ADD	A,E		;ADD TO NEGATIVE DIFF	LD	A,E		;PUT NEG DIFF INTO A	POP	DE	JR	NC,GREC2	;GO IF NOT IN THIS EXTENT	NEG			;IS IN THIS EXTENT, MAKE	JR	CALCSEC		;  DIFF POSITIVE AND USE IT;;	All current quads checked - need directory info;GREC4	CALL	ALLOC		;GET # OF GRANS	RET	NZ		;  INTO THE EXTENT	LD	(CALS4+1),A	;  OR ERROR RET	JR	NC,CALS3	;JP IF RECORD IN 1ST EXT	JR	CALS1		; ELSE JP IF IN ANOTHER;;	Calculate sector in gran;CALCSEC LD	(CALS4+1),A	;STUFF # GRANS INTO	LD	B,(HL)		;  THIS EXTENT	DEC	HL		;GET CONTIG GRANS &	LD	C,(HL)		;  REL START & START CYL	INC	HL	POP	AF		;GET # OF QUAD	CPL	ADD	A,4	JR	NC,CALS2	;JUMP IF NOT 1ST EXT OR QUAD	INC	A		;IF NOT 1ST, SET UP TO MOVE	RLCA			;  MATCHING QUAD TO THE	RLCA			;  FIRST POSITION BY	PUSH	BC		;  SHUFFLING THE OTHERS UP	PUSH	DE	LD	C,A		;GET BYTES TO MOVE	LD	B,0	EX	DE,HL		;DE=TOP OF LAST QUAD	LD	HL,-4	ADD	HL,DE		;HL=TOP OF NEXT QUAD	LDDR			;DO THE SHUFFLE	EX	DE,HL	POP	DE	POP	BCCALS1	LD	(HL),B		;MOVE INFO ON MATCHING QUAD	DEC	HL		;  INTO POSITION	LD	(HL),C	DEC	HL	LD	(HL),D	DEC	HL	LD	(HL),ECALS2	LD	H,B		;XFER START & CONTIG GRANS	LD	L,C		;  AND START CYLCALS3	LD	A,H	RLCA			;GET START GRAN ON TRACK	RLCA	RLCA	AND	7CALS4	ADD	A,0		;GET # OF GRANS INTO EXTENT	CALL	RELCYL		;CALC 1ST RELATIVE CYLINDER	ADD	A,L		;ADD STARTING CYLINDER	LD	D,A	LD	A,B		;RECOVER # SECTORS/GRAN	AND	1FH	INC	A	PUSH	DE		;CALC SECTOR OFFSET	CALL	@MUL8		;  INTO DESIRED CYLINDER	POP	DE		;  FOR THE DESIRED GRANULECALS5	ADD	A,0		;GET # OF EXCESS CYLINDERS	LD	E,A		;  OVER EVEN GRAN AND ADD	XOR	A		;  TO GRANULE SECTOR	RET;;	On entry, gran needed is in BC;ALLOC	CALL	CYL_GRN		;FIND EXT CONTAINING GRAN	RET	NZ		;RETURN ON ERROR	PUSH	HL		;SAVE STARTING CYL & GRAN	LD	H,B		;XFER GRAN NEEDED TO HL	LD	L,C		;  THEN CALCULATE HOW	XOR	A		;  MANY GRANS INTO THIS	SBC	HL,DE		;  EXTENT IS THE DESIRED	LD	A,L		;  GRANLUE	LD	(ALL6+1),A	;STUFF REL GRAN FROM START	POP	HL		;  OF EXTENT	PUSH	DE		;SAVE GRAN COUNT	PUSH	IX		;  TO EXTENT	EX	(SP),HL		;FCB POINTER TO HL	LD	DE,14		;POINT TO 1ST ALLOC IN FCB	ADD	HL,DE	POP	DE		;POP STARTING CYLINDER	LD	B,5		;  TO THIS EXTENTALL1	LD	A,(HL)		;GET A CYL	INC	HL		;DOES STARTING CYL OF	CP	E		;  NEEDED GRAN ALLOC	JR	NZ,ALL2		;  APPEAR IN THIS EXTENT?	LD	A,(HL)		;NOW SEE IF NEEDED GRAN IS	XOR	D		;  IN THIS EXTENT FIELD BY	AND	0E0H		;  CHECKING ITS STARTING GRAN	JR	Z,ALL4ALL2	DEC	B		;DEC THE COUNT DOWN LOOP	JR	Z,ALL3		;DONE IF NO MATCH	INC	HL		;GO TO NEXT EXTENT	INC	HL		;  INFO IN FCB	INC	HL	JR	ALL1ALL3	PUSH	DE		;SAVE NEEDED EXTENT INFO	EX	DE,HL		;SET UP TO SHUFFLE EXTENT	LD	HL,-4		;  INFO	ADD	HL,DE	LD	BC,12	LDDR	EX	DE,HL	POP	BC	XOR	A		;SET Z, NO ERROR	SCF			;SET CF, EXTENT NOT FOUND	JR	ALL5ALL4	LD	(HL),D	EX	DE,HL	XOR	A		;SET Z, NO ERRORALL5	POP	DEALL6	LD	A,0		;# OF GRANS INTO THIS EXT	RET			;WHERE DESIRED GRAN IS;;	Extent is unused - need to allocate more space;CG06	CALL	CG07		;TRY TO ALLOCATE MORE	POP	BC		;GET BACK DESIRED GRAN	RET	NZ		;RETURN ON ERROR				;LOOK FOR GRAN AGAIN;;	Find extent containing desired gran;CYL_GRN PUSH	BC		;SAVE DESIRED GRAN #	LD	DE,0		;INIT GRAN COUNTER	LD	B,(IX+7)	;GET D.E.C. OF FILECG01	LD	A,B	LD	(STUFDEC+1),A	;STUFF	LD	C,(IX+6)	;GRAB DRIVE NUMBER	CALL	@DIRRD		;READ ITS DIRECTORY	LD	BC,22		;POINT TO 1ST EXTENT	ADD	HL,BC		;  OF IT'S DIRECTORY	EX	DE,HL		;GRAN COUNT TO HL	POP	BC		;RESTORE DESIRED GRAN	RET	NZ		;RETURN ON READ ERRORCG02	LD	A,(DE)		;IS THIS EXTENT ALLOCATED	CP	0FEH	JR	NC,CG05		;JUMP IF IT IS NOT	INC	DE		;POINT TO ALLOCATION	LD	A,(DE)		;GET RELATIVE GRAN & #	PUSH	HL		;  OF CONTIGUOUS GRANS	AND	1FH		;KEEP CONTIGUOUS GRANS	INC	A		;  & BUMP FOR 0 OFFSET	ADD	A,L		;ADD TO COUNT IN HL	LD	L,A	JR	NC,CG03	INC	HCG03	PUSH	HL		;SAVE GRAN COUNT TO	DEC	HL		;  END OF EXTENT	XOR	A		;TEST IF EOF IS IN THIS	SBC	HL,BC		;  ALLOCATION	POP	HL	JR	NC,CG04		;EOF NOT > THIS ALLOC	INC	DE		;GET RID OF OLD	POP	AF		;  CURRENT QUANTITY	JR	CG02		;CHECK NEXT EXTENT;;	The EOF is within this allocation.  Recover;	the allocation data and exit;CG04	POP	HL		;GET GRAN COUNT TO EXTENT	EX	DE,HL		;GRAN COUNT TO DE	LD	A,(HL)		;GET GRAN DATA	DEC	HL	LD	L,(HL)		;GET STARTING CYLINDER	LD	H,A	XOR	A	RET;;	This extent is 1) unused, or 2) FXDE pointer;	and the needed gran has not been found yet;CG05	PUSH	BC		;GRAN COUNT TO DE AND	EX	DE,HL		;DIR PTR TO HL	JR	NZ,CG06		;JUMP IF UNUSED	INC	HL		;POINT TO D.E.C. OF FXDE	LD	B,(HL)		;GET THE D.E.C.	JR	CG01		;  AND LOOP;;	see if the drive has enough free space left;CG07	PUSH	BC		;SAVE NEEDED GRAN	LD	C,(IX+6)	;GET FILE'S DRIVE	CALL	@GATRD		;GET GAT	POP	BC	RET	NZ		;RETURN ON GAT ERROR	PUSH	HL	LD	H,B		;XFER REQUESTED GRAN	LD	L,C		; TO HL AND SUBTRACT	XOR	A		; CURRENT GRAN	SBC	HL,DE		;COUNT TO CALCULATE HOW	LD	B,H		;  MANY EXCESS GRANS	LD	C,L		;  ARE NEEDED	INC	BC	POP	DE		;GET DIR BYTE POINTER	INC	DE		;POINT TO NEXT DIR BYTE	LD	H,DIRBUF$<-8	;START LOOKING AT TRACK 1	LD	A,(AFLAG$)	;GET SEARCH START CYL	LD	L,A		;  AND PUT IT IN L	PUSH	BC		;SAVE EXCESS GRANS NEEDED	LD	A,E		;IS THIS EXTENT THE FIRST	AND	1EH		;JUMP IF SO, ELSE WE CAN	CP	16H		;  USE IT FOR ALLOCATION	JR	Z,CG14	DEC	E		;BACKUP TO PREVIOUS EXTENT	DEC	ECG12	LD	A,(DE)		;GET # CONTIG GRANS TO	AND	1FH		;  SEE IF THE LAST GRAN	INC	A		;  USED CAN BE EXTENDED	LD	C,A		;IS CURRENT # THE MAX	CP	20H		;  AN EXTENT CAN HOLD?	JR	Z,CG13		;JUMP IF A FULL EXTENT	LD	A,(DE)		;  (32 GRANS MAX) - ELSE	AND	0E0H		;  GET THE RELATIVE	RLCA			;  GRANULE OFFSET	RLCA	RLCA	ADD	A,C		;ADD THE # OF CONTIGUOUS	PUSH	DE		;  GRANULES	CALL	RELCYL		;CALC RELATIVE CYL NEEDED	LD	B,A		;SAVE OFFSET	LD	C,E	POP	DE	DEC	DE		;BACKUP TO STARTING CYL	LD	A,(DE)	INC	DE		;  & REPOINT TO ALLOC BYTE	ADD	A,B		;ADD CYLS USED TO STARTING	LD	L,A		;  STARTING CYL	LD	H,DIRBUF$<-8	;IS IT LESS THAN MAX	CP	0CBH	JR	NC,CG13		;JUMP IF TOO BIG	LD	A,C	LD	B,(HL)		;GET THE CYL'S GAT	CALL	TSTBIT		;TEST IF GRAN IS FREE	JR	Z,CG21		;BYPASS IF FREE GRAN;;	The next gran cannot be used - get another extent;CG13	INC	E		;ELSE POINT TO NEXT	INC	E		;  EXTENT FIELD	LD	A,E	AND	1EH		;JUMP IF NOT ON THE FXDE	CP	1EH		;  FIELD, ELSE WE HAVE TO	JR	NZ,CG14		;  OBTAIN AN FXDE RECORD;;	Last extent used up, get new dir rec for FXDE;	CALL	CG23		;WRITE CURRENT GAT & HIT	POP	BC	RET	NZ		;RET IF GAT/HIT ERROR	PUSH	BC	CALL	NEWHIT		;GET NEW HIT FOR FXDE	POP	BC	RET	NZ		;LOOP TO PROCESS	JP	CYL_GRN		;  NEW EXTENT;;	Extent is vacant - use it & get new allocation;CG14	CALL	MAXCYL		;GET HIGHEST # CYL	LD	(CG17+1),A	;STUFF IT	LD	B,2CG16	LD	A,L		;TEST LAST CYL USEDCG17	CP	0		;<-- GETS MAX CYL NUMBER	JR	NC,CG18	LD	A,(HL)		;GET GAT BYTE	INC	A	JR	NZ,CG19		;GO IF SPACE IN THIS CYL	INC	L		;  ELSE BUMP TO NEXT ONE	JR	CG16		;  AND LOOPCG18	LD	L,0		;NOW START FROM BEGIN	DJNZ	CG16		;  OF DISK AND RECHECK	POP	BC	CALL	CG23		;WRITE OUT GAT AND HIT	RET	NZ	LD	A,1BH		;"DISK SPACE FULL"	OR	A	RET;;	Found available space on cylinder;CG19	LD	A,0FFH		;SET DIR EXTENT TO FF	LD	(DE),A	LD	C,0	LD	B,(HL)		;GET CURRENT GAT ALLOCATIONCG20	LD	A,C	CALL	TSTBIT		;FIND A FREE GRAN	JR	Z,CG21		;  AND JUMP WHEN FOUND	LD	A,(DE)		;  ELSE ADVANCE STARTING	ADD	A,20H		;  REL GRAN VALUE	LD	(DE),A	INC	C		;BUMP POINTER TO TEST	JR	CG20		;  NEXT GRAN;;	Next gran in line is free - allocate it;CG21	LD	A,C	CALL	SETBIT		;SHOW IT ALLOCATED	OR	(HL)	LD	(HL),A	DEC	E		;BACKUP TO STARTING CYL	LD	A,(DE)		;BUMP BY ONE TO SEE IF	INC	A		;  THIS ALLOC IS THE 1ST	JR	NZ,CG22		;  ONE FOR THE EXTENT AND	LD	A,L		;  WE HAVE TO SET THE				;  STARTING CYLINDER	LD	(DE),A		;STUFF STARTING CYLINDERCG22	INC	E	LD	A,(DE)		;ADD 1 TO # OF CONTIGUOUS	INC	A		;  GRANS	LD	(DE),A	POP	BC		;DECREMENT NEEDED GRAN	DEC	BC		;  COUNT SINCE WE JUST	PUSH	BC		;  ALLOCATED ONE	LD	A,B		;LOOP IF WE NEED MORE	OR	C		;  SPACE ALLOCATED	JP	NZ,CG12	POP	BCCG23	LD	C,(IX+6)	;ELSE GET THE DRIVE #	CALL	@GATWR		;  & WRITE OUT THE GAT	RET	NZSTUFDEC LD	B,0		;GET D.E.C. OF FPDE	JR	@DIRWR;;	Get new HIT for FXDE;NEWHIT	LD	C,(IX+6)	;GET DRIVE	CALL	@HITRD		;READ THE HIT	RET	NZ	LD	A,(IX+7)	;GET FPDE DEC SO 1ST CHECK	AND	1FH		;  WILL BE FOR NEXT IN LINE	CALL	NHIT4@	LD	A,1EH		;INIT "FULL DIRECTORY" ERR	RET	NZ		;RETURN IF NO SPACE	LD	B,L		;SET D.E.C. FOR	LD	A,L		;  DIRECTROY READ	LD	(NHIT3+1),A	;STUFF NEW DEC FROM HIT	LD	D,H	LD	E,(IX+7)	;GET CURRENT DEC	LD	A,(DE)		;GET FILESPEC HASH CODE	LD	(HL),A		;  TO NEW DEC	CALL	@HITWR	CALL	Z,@DIRRD	RET	NZ	LD	(HL),90H	;SHOW DIR REC IN USE AS	INC	L		;  FXDE RECORD	PUSH	BC		;GET DEC OF FPDE AND	LD	A,(STUFDEC+1)	;  STUFF IT INTO FXDE'S	LD	(HL),A		;  DIR+1 TO LINK BACK	INC	L	LD	B,20		;ZERO OUT 20 BYTESNHIT1	LD	(HL),0		;  IN THE FXDE	INC	L	DJNZ	NHIT1	PUSH	HL		;SAVE PTR TO 1ST EXTENT	LD	B,10		;INIT TO FFH, 10 BYTESNHIT2	LD	(HL),0FFH	;  (5 EXTENTS)	INC	L	DJNZ	NHIT2	POP	DE		;GET PTR TO 1ST EXTENT	INC	DE		;POINT TO ALLOC BYTE	POP	BC	CALL	@DIRWR		;WRITE FXDE BACK TO DISK	RET	NZ	LD	A,(STUFDEC+1)	;GET DEC OF FPDE	LD	B,A	CALL	@DIRRD		;GET ITS DIRECTORY	RET	NZ	LD	A,L	ADD	A,1EH		;POINT TO FXDE POSITION	LD	L,A		;  IN FPDE	LD	(HL),0FEH	;SHOW LINK TO FXDE	INC	LNHIT3	LD	(HL),0		;SHOW WHAT THE FXDE D.E.C IS				; AND WRITE THE DIR BACK;;	Routine to write a directory sector;	B -> DEC of FPDE, C-> Logical drive number;	HL <- points to directory record in SBUFF$;@DIRWR	CALL	DIRWR		;PERMIT TWO ATTEMPTS	RET	ZDIRWR	PUSH	DE		;SAVE THE REG	CALL	CALCDIR		;CALC DIR CYL	LD	L,0		;SET BUFFER TO START	CALL	@WRSSC		;WRITE THE SECTOR	CALL	Z,@VRSEC	;VERIFY ON NO ERROR	SUB	6	POP	DE	RET	Z		;BACK ON SYSTEM SECTOR ERROR	CP	0FH-6		;WRITE PROTECT ERROR?	LD	A,18		;SET DIR WRITE ERROR	RET	NZ		;  IF NOT WP	SUB	3	RET;;	Find a spare hit entry;NHIT4@	PUSH	AF	LD	A,7		;GET HIGHEST # SECTOR	CALL	@DCTBYT		;  ON A CYLINDER	PUSH	DE		;  INTO REGISTER E	LD	D,A	AND	1FH	LD	E,A	INC	E		;& GET NUMBER OF HEADS	XOR	D		;  INTO REGISTER A	RLCA	RLCA	RLCA	INC	A	CALL	@MUL8		;TO CALC SECTORS/CYL	CALL	CKDBLBIT	;DOUBLE IF NECESSARY	POP	DE		;TOTAL SECTORS/CYL	SUB	2		;REDUCE FOR GAT AND HIT	LD	(NHIT7+1),A	;SAVE # DIRECTORY SECTORS	POP	AF		;GET D.E.C. INIT ENTRY	LD	L,A	CALL	NHIT6		;CHECK IF HIT SLOT IS SPARE	RET	Z		;RETURN IF SO	LD	L,01HNHIT5	INC	L	JR	NZ,NHIT6	OR	H	RETNHIT6	LD	A,L	AND	1FHNHIT7	CP	0		;DOES VALUE EXCEED NUM	LD	A,L	JR	C,NHIT8	OR	1FH	LD	L,A	JR	NHIT5NHIT8	LD	A,(HL)	OR	A	RET	Z	JR	NHIT5;;	Test if gran is free in GAT;TSTBIT	AND	7		;GET 0 TO 7	RLCA			;SHIFT TO MATCH BIT N, OPCODE	RLCA	RLCA	OR	40H	LD	(TBIT1+1),A	;modify BIT instructionTBIT1	BIT	0,B	RET;;	Set gran to allocated in GAT;SETBIT	RLCA			;SHIFT TO CREAT OPCODE	RLCA			; TO MATCH CURRENT BIT	RLCA	OR	0C7H	LD	(SBIT1+1),A	;Create SET n, opcode	XOR	ASBIT1	SET	0,A	RET;;	routine reads/writes the Granule Allocation Table;@GATRD	DB	0F6H		;SET NZ FOR TEST@GATWR	XOR	A		;SET Z FOR TEST	PUSH	DE	PUSH	HL	PUSH	AF	CALL	@DIRCYL	LD	HL,DIRBUF$	LD	E,L		;SET E TO 0	POP	AF		;RECOVER READ/WRITE FLAG	JR	Z,GATRW1	;GO IF @GATWR	CALL	@RDSSC		;PROTECTED SECTOR READ	LD	A,14H		;INIT "GAT READ ERROR"	JR	GATRW2GATRW1	CALL	@WRSSC		;PROTECTED SECTOR WRITE	CALL	Z,@VRSEC	;VERIFY IF OKAY	CP	6		;PROTECTED SECTOR?	LD	A,15H		;INIT "GAT WRITE ERROR"GATRW2	POP	HL	POP	DE	RET;;	Read or write the hash index table;@HITRD	DB	0F6H		;SET NZ FOR TEST@HITWR	XOR	A		;SET Z FOR TEST	PUSH	BC	PUSH	DE	PUSH	AF	CALL	@DIRCYL		;D -> DIRECTORY CYLINDER	LD	E,1		;E -> HIT SECTOR	LD	HL,SBUFF$	;HL -> HIT BUFFER AREA	POP	AF		;RECOVER READ/WRITE FLAG	JR	Z,HITRW1	;GO IF @HITWR	CALL	@RDSSC		;READ CYL D, SECTOR E	LD	A,22		;INIT HIT READ ERROR	JR	HITRW2HITRW1	CALL	@WRSSC		;PROTECTED SECTOR WRITE	CALL	Z,@VRSEC	;VERIFY IT	CP	6		;PROTECTED?	LD	A,23		;"HIT WRITE ERROR"HITRW2	POP	DE		;MESSAGE FOR OTHER THAN	POP	BC		;  ATTEMPT PROTECTED SECTOR	RET;;	Routine to read a directory sector;	B -> DEC of FPDE, C -> logical drive number;	HL <- points to directory record in SBUFF$;@DIRRD	PUSH	DE	CALL	CALCDIR		;SET HL TO SBUFF$	PUSH	HL	LD	L,0		;START OF BUFFER	CALL	@RDSSC		;READ IT	POP	HL	LD	A,17		;INIT TO DIR READ ERR	POP	DE	RET;;	Routine to get directory access data;	b -> DEC;	DE <- Cylinder and sector needed;	HL <- Pointer to directory record in SBUFF$;CALCDIR CALL	@DIRCYL		;GET DIRECTORY CYL FROM D	LD	A,B		;CALC RECORD START	AND	0E0H		;  FROM THE DEC	LD	L,A	LD	H,SBUFF$<-8	;POINT TO BUFFER START	XOR	B		;CALCULATE DIRECTORY	ADD	A,2		;  SECTOR NEEDED	LD	E,A	RET;;	Read system sector, D=Track, E=Sector, HL=Buffer;@RDSSC	CALL	READIR		;ATTEMPT READ	RET	Z		;RETURN IF SUCCESSFUL	PUSH	DE		;SAVE INFO.	LD	DE,1		;POINT TO TRACK 0, SEC 1	CALL	@RDSEC		;READ BOOT CYL TO FIND DIR	POP	DE	RET	NZ		;RETURN IF AN ERROR	PUSH	HL		;SAVE THIS FOR A MOMENT	INC	HL	INC	HL		;POINT TO DIR TRACK BYTE	LD	D,(HL)		;GET DIR TRACK	LD	H,9		;UPDATE MEMORY TABLE	CALL	DCTFLD@	LD	L,A	LD	(HL),D	POP	HL		;OKAY, TRY IT NOWREADIR	CALL	@RDSEC		;READ DIR SECTOR	SUB	6		;TEST "PROTECTED" ERROR	RET;@DIRCYL LD	A,9		;DRIVER COMMAND	CALL	@DCTBYT		;GET THE DIR CYLINDER	LD	D,A		;STORE IN D	RET;MAXCYL	LD	A,6		;DRIVER COMMAND	PUSH	BC		;DON'T TRASH BC	LD	C,(IX+6)	;POINT TO DRIVE	CALL	@DCTBYT		;GET HIGHEST CYLINDER	INC	A		;ADJUST FOR ZERO OFFSET	POP	BC		;OKAY	RET;;	Multiply register E by register A;@MUL8	PUSH	BC	LD	D,A	XOR	A	LD	B,8MEA1	ADD	A,A	SLA	E	JR	NC,MEA2	ADD	A,DMEA2	DJNZ	MEA1	POP	BC	RET;;	Calculate relative cylinder for granule needed;RELCYL	LD	E,A	CALL	@DCTBYT-5	;GET # OF GRANS PER TRACK	LD	B,A		;HANG ON TO THIS	RLCA	RLCA	RLCA	AND	7	INC	A		;ADJUST FOR 0 OFFSET	CALL	CKDBLBIT	;SEE IF WE NEED TO DOUBLE IT;;	Divide register E by register A;@DIV8	PUSH	BC	LD	C,A	LD	B,8		;DO 8 BITS WORTH	XOR	ADEA1	SLA	E	RLA	CP	C	JR	C,DEA2	SUB	C	INC	EDEA2	DJNZ	DEA1	LD	C,A	LD	A,E	LD	E,C	POP	BC	RET;;	Routine to double the A register if DBL bit is set;CKDBLBIT	LD	D,A		;ADJUST FOR 2 SIDED AND	LD	A,4		;  CALCULATE # OF CYLS	CALL	@DCTBYT	BIT	5,A		;TEST IF 2 SIDED	LD	A,D	JR	Z,DBLCHK1	;DOUBLE THE GRANS IF 2	ADD	A,A		;  AND FALL THROUGH TO DIV 8DBLCHK1 RET