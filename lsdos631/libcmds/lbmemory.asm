;LBMEMORY/ASM - MEMORY command	TITLE	<MEMORY - LS-DOS 6.3>;*GET	SVCEQU			; SVC equates*GET	VALUES			; Misc equates;PAR_ERR	EQU	44		; Parameter errorLOWEST	EQU	2600H;	ORG	2400H;MEMORY	LD	A,@CKBRKC	; Break key down?	RST	28H	JR	Z,BEGINA	LD	HL,-1	RET;BEGINA	LD	(EXIT+1),SP	LD	DE,PRMTBL$	; Point to param table	PUSH	DE		; Save param table start	LD	A,@PARAM	; Process parameters	RST	28H	POP	HL		; HL = Param table startPERR	JP	NZ,PRMERR;;	Legal input - were the entries acceptable?;	CALL	CKPARM		; Valid entries?	JR	NZ,PERR		; No - param error;	LD	A,@FLAGS	; IY => System flags	RST	28H;;	Was the CLEAR (C) parameter entered?;CPARM	LD	BC,0FF00H	; C = clear byte	LD	A,(CRESP)	; Get response byte	OR	A		; Any response?	JR	Z,NEXTPRM	; No - get next param	BIT	0,(IY+CFLAG$)	; If memory frozen,	JP	NZ,NOMEM	;   Can't do it;;	Clear (C) param entered - is this a flag?;	BIT	6,A		; Test if it's a flag	JR	Z,ISNUMER	; No - check if numeric;;	Response is a FLAG - is it NO, OFF or N?;	INC	B		; Yes or no?	JR	NZ,NEXTPRM	; No - get next param	JR	FILLMEM;;	Response is not a flag, check if numeric;ISNUMER	LD	HL,FILLBYT+1	; HL => Byte to fill	BIT	7,A		; Numeric response?	LD	(HL),C		; Stuff byte in LD (HL),nn	JR	NZ,FILLMEM	; Fill mem with byte;;	Response must be a string - is lengt = 1?;	AND	0FH		; Get length	DEC	A		; Better be one	JR	NZ,PERR		; Not - param error;;	Pick up character at address and stuff it;	LD	A,(BC)		; Get character to fill	LD	(HL),A		; Put it in LD (HL),nn;;	Set HL => HIGH$ (if DOS) or LOW$ (@CMNDR);FILLMEM	CALL	GETHILO		; HIGH$(HL), LOW$(DE)	BIT	1,(IY+CFLAG$)	; Executing @CMNDR?	JR	Z,USEHIGH	; No - use HIGH$	EX	DE,HL		; @CMNDR - use LOW$USEHIGH	LD	DE,NEXTPRM	; Start clearing here;;	Calculate amount of memory to fill;	XOR	A		; Clear carry	SBC	HL,DE		; Subtract end from start	LD	B,H		; Xfer to BC	LD	C,L;;	Fill user area - HIGH$/LOW$ with spec'd byte;	LD	H,D		; HL = LOW$	LD	L,E	INC	DE		; DE = LOW$ + 1FILLBYT	LD	(HL),00H	; Put fill byte in	LDIR			; Fill memoryGOODEX	LD	HL,0		; Good exit	RET;;	Was the ADDR (A) parameter specified?;NEXTPRM	LD	A,(ARESP)	; Get address response	OR	A	JP	Z,HICHECK;;	Check for numeric entry;	BIT	7,A		; Number?	JR	NZ,APARM	; Go if set;;	Response must be a string - is length = 1?;	AND	0FH		; Get length	DEC	A		; Was it 1?	JR	NZ,PERR		; No - that's an error;;	Get character representation of "FLAG";	LD	HL,(APARM+1)	; Get pointer to char	LD	A,(HL)		; Get char	RES	5,A		; Force it upper case	SUB	41H		; Normalize for flag #	CP	26		; Check range	JP	NC,RANGER	; Error if too high	PUSH	IY	POP	HL		; Get base of flags	LD	D,00H	LD	E,A		; Put offset in DE	ADD	HL,DE		; Add them together	LD	(APARM+1),HL	; Set value in response word;;	Get addr, cvt to hex ascii & put in string;APARM	LD	DE,0		; Get the address	LD	HL,HEXADD	LD	A,@HEX16	; Convert DE to ASCII @ HL	RST	28H;;	Convert DE to dec ASCII and put in string;	EX	DE,HL		; Set HL = address	PUSH	HL		; Save addr pointer	LD	DE,DECADD	; DE => Destination	LD	A,@HEXDEC	; Cvt HL to ASCII @ DE	RST	28H	POP	HL		; HL = address;;	Get word and byte at that address;	PUSH	HL		; Save ptr	LD	C,(HL)		; Get byte	LD	D,C		; Get word	INC	HL	LD	E,(HL);;	Convert byte to HEX ascii & put in string;	LD	HL,OLDBYTE	; HL => Destination	LD	A,@HEX8		; Convert C to ASCII @ HL	RST	28H;;	Convert word to hex ASCII & put in string;	LD	HL,OLDWORD	; Destination	LD	A,@HEX16	RST	28H	POP	IX		; Recover addr ptr;;	Was WORD or BYTE parameter entered?;	LD	HL,BRESP	; HL => Byte response	LD	DE,WRESP	; DE => Word response	LD	A,(DE)		; Anything entered?	OR	(HL)	JR	NZ,WHICH;;	Neither entered - Modify string;	LD	HL,OLDWORD+5	; End string	LD	(HL),')'	; Don't display new word	INC	HL	LD	(HL),' '	INC	HL	LD	(HL),' '	INC	HL	LD	(HL),ETX	JR	DSPSTR		; Display string;;	One or both was entered - ensure not both;WHICH	LD	A,(DE)		; Word entered?	OR	A	JR	Z,BPARM		; No - get byte;;	Word entered - Make sure byte wasn't entered;	LD	A,(HL)		; Entered?	OR	A	JP	NZ,PRMERR	; Yes - parameter error;;	Pick up word value and stuff in memory;WPARM	LD	DE,0		; Get word	LD	(IX+00H),D	; Stuff LSB	LD	(IX+01H),E	; Stuff MSB;;	Convert word/byte to Hex ASCII and put in string;	LD	HL,NEWWORD	; HL => Destination	LD	A,@HEX16	; DE to hex at (HL)	RST	28H	JR	DSPSTR		; Display string;;	Stuff byte into memory if between 0-255;BPARM	LD	DE,00FFH	; Get byte	LD	A,D		; High order must be 0	OR	A	JP	NZ,PRMERR	; Go if param error	LD	(IX+00H),E	; Stuff LSB into string;;	Convert byte to Hex ASCII and put in string;	LD	C,E		; Set C = new byte	LD	HL,NEWBYTE	; Destination	LD	A,@HEX8		; C to ASCII @ HL	RST	28H;;	Display address string;DSPSTR	LD	HL,ADDMSG	; Point to message	CALL	DSPLY		;   and display it;;	Display word/byte/string;	LD	HL,OLDWORD	; HL => word string	LD	A,(BRESP)	; Byte response	OR	A		;   wpecified?	JR	Z,DSPSTR2	; No - display word	LD	HL,OLDBYTE	; Yes - display byteDSPSTR2	CALL	DSPLY		; Display string;;	HIGH$ and LOW$ check - Was HIGH$ entered?;HICHECK	CALL	GETHILO		; HIGH$ (HL) LOW$ (DE)	LD	(OLDHI),HL	; Put old high$ in header	LD	A,(HRESP)	; HIGH$ = value?	OR	A	JR	Z,LOCHECK	; No - check LOW$	BIT	0,(IY+CFLAG$)	; if memory frozen	JP	NZ,NOMEM	;   we can't do it;;	HIGH$ entered - get value and check range;HPARM	LD	BC,0		; Get new requested HIGH$	SBC	HL,BC		; New > old?	JP	C,RANGER	; Yes - range error;;	Create header string & establish true HIGH$;	PUSH	DE		; Save DE	LD	D,B		; Set DE to HIGH$+1	LD	E,C	INC	DE	LD	HL,HD_ADD	; Convert DE to hex ASCII	LD	A,@HEX16	RST	28H	LD	HL,-HLEN	; Set HL = actual HIGH$	ADD	HL,BC		;   including header size	POP	DE		; Restore LOW$;;	Was LOW$ entered?;LOCHECK	LD	A,(LRESP)	; Get response	OR	A	JR	Z,CHKBOTH	; No - check range	BIT	0,(IY+CFLAG$)	; if memory frozen	JP	NZ,NOMEM	;   can't do it;;	Low$ entered - cannot be below LOWEST;LPARM	LD	DE,0		; Get LOW$ value	LD	BC,LOWEST	; BC = lowest possible	EX	DE,HL		;   memory location	PUSH	HL	SBC	HL,BC		; In range?	POP	HL	EX	DE,HL	JP	C,RANGER	; No - display range error;;	HL=HIGH$, DE=LOW$ - to they overlap?;CHKBOTH	PUSH	HL		; HIGH$ must be greater	OR	A		;   than or equal to	SBC	HL,DE		;   LOW$	POP	HL	JP	C,RANGER	; Yes - range error;;	HIGH$ and LOW$ are both valid - Set LOW$;	EX	DE,HL		; DE => HI$, HL => LOW$	LD	B,1	LD	A,@HIGH$	; Set LOW$	RST	28H;;	Was the HIGH parameter entered?;	LD	A,(HRESP)	; Get response	OR	A	JR	Z,DSPHI		; No - don't alter it;;	Yes - change exit message to include header;	LD	A,LF		; change CR to LF	LD	(HEADMES),A;;	Transfer header into high memory;	PUSH	DE		; Save HIGH$	INC	DE		; Point to dest header	LD	HL,HEADER	; HL => Mem Header	LD	BC,HLEN		; Header length	LDIR			; Move to high mem	POP	HL		; Get HIGH$ (BC=0)	LD	A,@HIGH$	; Set HIGH$	RST	28H;;	Get HIGH$/LOW$, cvt to hex & put in string;DSPHI	CALL	GETHILO		; Get both	PUSH	HL		; Save HIGH$	LD	HL,LOWIS1	LD	A,@HEX16	; Convert to ASCII	RST	28H	POP	DE		; DE = HIGH$	LD	HL,HIGHIS1	; Dest	LD	A,@HEX16	; Convert to ASCII	RST	28H;;	Display HIGH$ = nnnn & LOW$ = nnnn string;	LD	HL,HIGHIS	; Point to string	CALL	DSPLY		; Display it	LD	HL,HEADMES	; Display header message	CALL	DSPLY	CALL	CKPAGE;;	Display memory banks available;	LD	BC,0		; Init to REQ, Bank 0DSPBANK	INC	C		; Inc bank to request	PUSH	BC		; save bank num	LD	A,@BANK		; Request bank	RST	28H	POP	BC		; Get curr bank back	JR	Z,DSPBANK		; Go look for next one;;	Bank doesn't exist - done looking;	PUSH	BC		; Save total banks	LD	C,B		; Go back to bank 0	LD	A,@BANK	RST	28H	POP	BC		; Get total back	LD	E,C		; Put total banks in E	LD	A,C		; and in A	CALL	CVA2BC		; A to ASCII in reg BC	LD	(BANKTOT),BC	; Put total banks in msg;;	Calculate banks in use & show them;	LD	HL,BNKLST$	; Point to <+ msg	LD	BC,00FFH	; Banks avail=0, bank=-1TSTBANK	INC	HL		; Bump msg pointer	INC	C		; Inc bank num	LD	A,C		; Get in A	CP	E		; Tested all banks?	JR	Z,BNKDUN	; Yes - done;	PUSH	BC		; Save bank num	LD	B,02H		; B=2 to check if in use	LD	A,@BANK		; Test to see if bank	RST	28H		;   is in use	POP	BC		; Recover bank;;	Show if bank was in use or not;	LD	(HL),'+'	; Default to in use	JR	NZ,TSTBANK	; Loop back if it was	INC	B		; Increment available banks	LD	(HL),'-'	; Show bank not in use	JR	TSTBANK		; Loop back for more;;	Done with banks - finish up;BNKDUN	LD	(HL),'>'	; End message	INC	HL	LD	(HL),CR	LD	A,B		; Get banks available	CALL	CVA2BC		; Convert to ASCII	LD	(BANKAVA),BC	; Store in message;;	Display memory banks available/used;	LD	HL,BANKMSG	; Message	CALL	DSPLY		; Display it;;	Get low memory module directory;	LD	DE,KI$NAM	; Point to $KI	LD	A,@GTMOD	; Get module addr	RST	28H	JR	NZ,SHOHMEM	; Go if none found				; Which really can't happen;;;	Low memory modules exist - display them;SHOLMEM	LD	(SVMEMP1+1),HL	; Store ptr to mem hdr	PUSH	HL		; Save module pointer	CALL	DSPBLIN		; Display a blank line	CALL	LMEMSTR		; Set mem hdr str for low mem	CALL	DSPMSTR		; Display the string	POP	HL		; Recover mod pointer	JR	DSPMMOD;;	Check for any high memory modules present;SHOHMEM	CALL	GETHILO		; HIGH$ in HL	LD	DE,-1		; Init to X'FFFF'	LD	(SVHIGH1+1),HL	; Save HIGH$ for later	LD	(SVHIGH2+1),HL	EX	DE,HL		; DE=HIGH$, HL=FFFF	SBC	HL,DE		; Subtract HIGH$	JP	Z,GO		; Go if no hi mem modules	PUSH	DE		; Save HIGH$	CALL	DSPBLIN		; Display a blank line	CALL	HMEMSTR		; Set hdr str to high mem	CALL	DSPMSTR		; Display the string	POP	HL		; HIGH$ back to HL	INC	HL		; HL = HIGH$+1;;	Display memory modules;DSPMMOD	LD	(SVMEMP2+1),HL	; Store mem mod ptr;;	Test to see if memory module header is okay;	LD	A,(HL)		; Get 1st byte of module	CP	18H		; Is it a JR xx?	JP	NZ,SCANMOD	; Go if not	INC	HL		; Skip over jump	INC	HL	LD	E,(HL)		; Get last byte used	INC	HL		;   by this module	LD	D,(HL)		;   into DE	LD	(SVMEMP3+1),DE	; Save for later	INC	HL		; Point to length of name	LD	B,(HL)		; Get it into B	INC	HL		; Point to name;;	Make string containing mem module name, etc.;MKMDSTR	LD	DE,MEMORY	; As safe a place as anyMKMDST1	LD	A,(HL)		; Get mem mod name	LD	(DE),A		; Store it in string	INC	HL		; Bump pointers	INC	DE	DJNZ	MKMDST1		; Loop for # of chars;	LD	HL,(SVMEMP2+1)	; Get mem mod start addr	LD	DE,MEMORY+12H	; Start address position	CALL	ADR2ASC		; Put "X'addr' in stringSVMEMP3	LD	HL,$-$		; Pick up last byte used	LD	DE,MEMORY+24H	; End address location	CALL	ADR2ASC		; Put mem addr in string	LD	HL,(SVMEMP3+1)	; Get last byte used againSVMEMP2	LD	DE,$-$		; pick up mem mod ptr	OR	A		; Clear carry	SBC	HL,DE		; Get difference	INC	HL	LD	DE,MEMORY+33H	; Length pos'n in string	LD	A,@HEXDEC	; Show length	RST	28H	CALL	DSPMSTR		; Display the string	LD	HL,(SVMEMP3+1)	; Get mem module addr	INC	HL		; Increment it	LD	A,H		; Looped to zero?	OR	L	JP	Z,GO		; Yes - go	EX	DE,HL		; Move mem ptr to DESVLOWIO	LD	HL,$-$		; Pick up low IO zone ptr	SBC	HL,DE		; Are we done with it?	EX	DE,HL		; Mem ptr back to HL	JP	Z,SHOHMEM	; Go do high mem if done	JP	DSPMMOD		;   else display this module;;	Show the low memory modules;LMEMSTR	LD	HL,LOWIS	; " Low"	LD	DE,STARTS$	; "Start ="	CALL	SETMHDR		; Set mem mod stringSVMEMP1	LD	HL,$-$		; Get mem header ptr	PUSH	HL		; Save it	CALL	SHOMEMA		; Show low memory start address	LD	DE,'IK'		; Get *KI DCB	LD	A,@GTDCB	RST	28H	DEC	L		; Get start of low	LD	A,(HL)		; I/O zone into HL	DEC	L	LD	L,(HL)	LD	H,A	LD	(SVLOWIO+1),HL	; Save low I/O zone	POP	DE		; DE = Mem header pointer	JR	SHOMLEN		; Show the difference;;	Put high mem relates strings into header;HMEMSTR	LD	HL,HIGHIS	; "High"	LD	DE,HISTR$	; "HIGH$ ="	CALL	SETMHDR		; Set into mem mod string;SVHIGH1	LD	HL,$-$		; Pick up HIGH$	CALL	SHOMEMA	LD	HL,-1SVHIGH2	LD	DE,$-$		; Pick up HIGH$;;	Show length of mem from HL to DE as ASCII;SHOMLEN	OR	A		; Clear carry flag	SBC	HL,DE	LD	DE,MEMORY+34H	; Point to string	LD	A,@HEXDEC	; convert to ASCII	RST	28H	LD	A,CR		; Stuff carriage return	LD	(DE),A		;   into string	CALL	DSPMSTR;;	Move memory module header string to destination;MOVMHDR	LD	HL,MODHDR$	; Get mem hdr string	LD	DE,MEMORY	; Get destination	LD	BC,MHDLEN	; Length of string	LDIR			; Move it	RET;;	Scan memory for module headers;SCANMOD	LD	A,H		; Get high byte of pointer	CP	13H		; Still in low mem region?	JP	C,SHOHMEM	; Go check hi mem region if not;;	See if things look reasonable;	PUSH	HL		; Save memory pointer	DEC	HL	LD	DE,-1		; DE = FFFF	EX	DE,HL		; HL = memptr, DE=FFFF	OR	A		; Clear carry	SBC	HL,DE		; Subtract	LD	B,H		; Move result to BC	LD	C,L	POP	HL		; Recover mem ptr	JP	Z,GO		; Go if finished;;	Look for JR instructions;	LD	A,18H	CPIR	JR	NZ,SCANNOM	; Go if none found	DEC	HL		; Back up to possible header	DEC	HL	LD	(SVMEMP3+1),HL	; Save it	INC	HL		; Move up to last mem used	INC	HL		;    address	INC	HL	LD	E,(HL)		; Get last mem used in DE	INC	HL	LD	D,(HL)	LD	HL,(SVMEMP3+1)	; Get mem module addr	EX	DE,HL		; DE=lastused, HL=mem mod	OR	A	SBC	HL,DE		; Does it look okay?	JR	C,SCANSKP	; Jump if it isn't	LD	HL,(SVMEMP3+1)	; Get mem module addr	INC	HL		; Skip JR	INC	HL	INC	HL		; Skip address	INC	HL	INC	HL		; Point to length	LD	A,(HL)		; Get length	CP	10H		; Is it reasonable?	JR	NC,SCANSKP	; Go if it isn't;;	Check through possible module name	LD	B,A		; Get mem mod name lengthSCANM01	INC	HL		; Next char in name	LD	A,(HL)		; Get character	CP	'0'		; Is it numeric?	JR	C,SCANSKP	; Go if less	CP	'{'		;	JR	NC,SCANSKP	DJNZ	SCANM01		; Loop for # chars in HL;;	Say memory module is unknown;UNKNOWN	LD	HL,UNKNW$	; Say it's unknown	LD	B,09H		; Length of unknown string	JP	MKMDSTR;;	Skip this - it isn't a memory module;SCANSKP	LD	HL,(SVMEMP3+1)	; Get mem mod addr again	INC	HL		; Bump past JR instruction	INC	HL	JR	SCANMOD		; Go back to look for more;;;SCANNOM	LD	HL,-1		; Flag we're done	LD	(SVMEMP3+1),HL	; Store it	JR	UNKNOWN		; And jump back;;	Setup module display header and move to memory;;	HL => Ptr to "High" or " Low";	DE => ptr to "HIGH$ =" or "Start =";SETMHDR	PUSH	DE		; Save ptr to string	LD	DE,MEMORY	; Dest for string	LD	BC,4		; 4 bytes to move	LDIR			; Move it	LD	HL,MEMDIR$	LD	C,MDIRLEN	; Length of string	LDIR			; Move it, too	POP	HL		; Get "HIGH$"/"Start" ptr back	LD	DE,MEMORY+19H	; Where "Start" goes	LD	C,07H	LDIR	RET;;	Display address of memory and "Length=" string;SHOMEMA	LD	DE,MEMORY+21H	; Place for start addr or	CALL	ADR2ASC		;   high$ in hex ascii	LD	HL,LNGTH$	; "Length ="	LD	DE,MEMORY+2CH	; Destination	LD	BC,8	LDIR			; Move it	RET			;   and return;;	Convert HL to "X'nnnn'" string string at DE;ADR2ASC	PUSH	DE		; Save string pointer	EX	DE,HL		; Move address to DE	LD	HL,ADDRPOS	; Dest for HEX chars	LD	A,@HEX16	; Convert to hex	RST	28H	POP	DE		; Get destination back	LD	HL,ADDRSTR	; Point to string	LD	BC,7		; 7 bytes long	LDIR			; Move it	RET			; And return;;	Display a blank line;DSPBLIN	LD	A,0DH		; Stuff CR in string	LD	(MEMORY),A	;;;	Display string that we built up;DSPMSTR	LD	HL,MEMORY	CALL	DSPLYFILMSTR	LD	B,39H		; Number of bytes to setFILOOP	LD	(HL),' '	; Fill string buffer	INC	HL		;   with spaces	DJNZ	FILOOP;CKPAGE	LD	A,15H		; Get line counter	DEC	A		; Decrement it	LD	(CKPAGE+1),A	; Save it back	RET	NZ		; Return if lines left	LD	A,@KEY		; Wait for a key	RST	28H	CP	80H		; Was it BREAK?	JP	Z,ABORT		; Go if it was	LD	A,@CLS		; Clear the screen	RST	28H	LD	A,18H		; Set 24 lines left	LD	(CKPAGE+1),A	;   and save in counter	CALL	MOVMHDR		; Move mod hdr string	LD	HL,MEMORY	JR	M280F		; Loop back;;;DSPLY	LD	DE,0		; Pick up (P) param	INC	E	DEC	E	JR	Z,LOGSTR		; Go if not print	LD	A,@PRINT	; Print the string	RST	28H	JR	NZ,IOERR	; Jump on error;;	Log string;LOGSTR	LD	A,@LOGOT	; Display string	RST	28H	RET	Z		; Return if no error	JR	IOERR		;   else jump;;	Convert A to 2 digit decimal in BC register;CVA2BC	LD	C,'0'-1		; Init asciiCVA2B1	INC	C		; Inc ones digit	SUB	0AH	JR	NC,CVA2B1	; loop until carry	ADD	A,'9'+1		; Calc tens	LD	B,A		; Store tens	RET;;	Was a GO parameter entered?;GO	LD	A,(GRESP)	; Go entered?	OR	A	JP	Z,GOODEX	; No - return with HL=0GPARM	JP	$-$;;;	CKPARM - Check if parameter types are legal;	HL => Beginning of parameter table;	Z  <= set if parameters entered are legal;GOODPRM	POP	DE		; Clear stackCKPARM	INC	HL		; Bump past 80H	LD	A,(HL)		; Get type byte	LD	B,A		; Save it in B	AND	0FH		; Get length	RET	Z		; Return if finished;;	Position HL to response byte;	INC	HL		; HL => Param name	PUSH	HL		; Save start of name	LD	E,A		; Set DE = name length	LD	D,00H	ADD	HL,DE;;	Pick up response, masek of junk and xfer to D;	LD	A,(HL)		; Get response	AND	0E0H		; Bits 7-5 = response	LD	D,A		; Save it in D;;	Was the response bit acceptable by type?;	LD	A,B		; Get type byte	AND	D		; Mask off bits 4-0	XOR	D		; Result = 0 if both set;;	Position HL to next parameter entry;	INC	HL		; Go past word	INC	HL	JR	Z,GOODPRM	; Z means good entry;;	Illegal entry - Recover name start and return;	LD	C,E		; Set BC = length	LD	B,00H	POP	HL		; HL = parameter name	RET			; Return with NZ status;;;	Version 6.x memory header;HEADER	JR	MEMSTRT		; JR to start of moduleOLDHI	DW	0		; HIGH$ before this module	DB	5,'&'		; Use '&' to denote addrHD_ADD	DB	'nnnn'		; Hex ASCII addressMEMSTRT	EQU	$		; Length byteHLEN	EQU	$-HEADER	; Length of header;;;	GETHILO - Get HIGH$ in HL, LOW$ in DE;GETHILO	LD	HL,0		; Get LOW$	LD	D,H	LD	E,L	LD	B,01H	LD	A,@HIGH$	; Get LOW$	RST	28H	EX	DE,HL		; Move to DE	LD	B,L	LD	A,@HIGH$	; Get HIGH$	RST	28H	RET			; and return;;	IOERR = Fatal error handler;PRMERR	LD	A,PAR_ERR	; Parameter errorIOERR	LD	L,A		; Error code to HL	LD	H,00H	OR	0C0H		; Short error msg	LD	C,A		; Err in C for SVC	LD	A,@ERROR	; Display the error	RST	28H	JR	EXIT;;	Error message display and abort;NOMEM	LD	HL,NOMEM$	DB	0DDHRANGER	LD	HL,RANGER$;;	Log error message and exit;	LD	A,@LOGOT	RST	28HABORT	LD	HL,-1		; Internal errorEXIT	LD	SP,$-$		; Pick up stack ptr	LD	A,@CKBRKC	; Clear break flag	RST	28H	RET			; Exit;;;M280F	CALL	LOGSTR		; Display the string	JP	FILMSTR		; And jump back;;;NOMEM$	DB	'No memory available',0DHRANGER$	DB	'Range error',0DHKI$NAM	DB	'$KI',03HMEMDIR$	DB	' Memory Directory'MDIRLEN	EQU	$-MEMDIR$HISTR$	DB	'HIGH$ ='STARTS$	DB	'Start ='LNGTH$	DB	'Length ='MODHDR$	DB	'Module         Start Address      End Address      Length'MHDLEN	EQU	$-MODHDR$	DB	0DHUNKNW$	DB	'<unknown>'ADDRSTR	DB	'X',27HADDRPOS	DB	'    ',27H;;	Parameter Table;PRMTBL$	DB	80H;	DB	NUM!ABB!4	DB	'HIGH'HRESP	DB	00H	DW	HPARM+1;	DB	NUM!ABB!3	DB	'LOW'LRESP	DB	00H	DW	LPARM+1;	DB	NUM!STR!ABB!3	DB	'ADD'ARESP	DB	00H	DW	APARM+1;	DB	NUM!ABB!4	DB	'WORD'WRESP	DB	00H	DW	WPARM+1;	DB	NUM!ABB!4	DB	'BYTE'BRESP	DB	00H	DW	BPARM+1;	DB	NUM!ABB!2	DB	'GO'GRESP	DB	00H	DW	GPARM+1;	DB	NUM!STR!FLAG!ABB!5H	DB	'CLEAR'CRESP	DB	00H	DW	CPARM+1;	DB	FLAG!ABB!5	DB	'PRINT'	DB	00H	DW	DSPLY+1	DB	00H;;	Messages;HIGHIS	DB	'High = X',APHIGHIS1	DB	'xxxx',AP,' 'LOWIS	DB	' Low = X',APLOWIS1	DB	'xxxx',AP,ETXADDMSG	DB	'X',APHEXADD	DB	'nnnn',AP,' = 'DECADD	DB	'ddddd (X',AP,ETXOLDWORD	DB	'nnnn',AP	DB	' => X',APNEWWORD	DB	'nnnn',AP,')  ',ETXOLDBYTE	DB	'nn',AP,' => X',APNEWBYTE	DB	'nn',AP,')  ',ETXHEADMES	DB	CR,'Note : Memory Header Inserted',CRBANKMSG	DB	LF,'32K Banks avail = 'BANKAVA	DB	'dd/'BANKTOT	DB	'dd, In use = 'BNKLST$	DB	'<+';	END	MEMORY