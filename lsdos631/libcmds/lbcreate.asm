; LBCREATE/ASM - CREATE command	TITLE	<CREATE - LSDOS 6.3>;*GET	SVCMAC			; System SVC macros*GET	VALUES			; Misc equates;	ORG	2400H;CREATE	LD	(SAVESP+1),SP	; Save SP address	@@CKBRKC		; Check if BREAK pressed	JP	NZ,ABORT	; Jump if so	CALL	CREATCD		; Do the CREATE code;;	Set ERN and offset in FCB = value at @INIT;ERN	LD	HL,0		; Get ERN (Probably 0)	LD	(FCB+12),HL	; Stuff it into FCBOFFSET	LD	A,00H		; Get offset byte	LD	(FCB+8),A	; Put it in FCB too;;	CLOSE the file if possible;	LD	DE,FCB		; Point to FCB	LD	BC,(FCB+6)	@@CLOSE			; Close it	JP	NZ,IOERR	; Go on error;;	Handle "shrink" parameter;SHRPRM	LD	DE,$-$		; Shrink specified?	LD	A,D		; Test that	AND	E	INC	A	CALL	Z,SHRINK	; Do it if so;;	Exit routine;	LD	HL,0		; Successful - HL=0	RET			; Return;;	Parse the filespec given;CREATCD	LD	DE,FCB		; Fetch filespec	@@FSPEC	JP	NZ,SPCREQ	; Quit on bad filename;;	Check out parameter input;	LD	DE,PRMTBL$	; Get parameters	@@PARAM	JP	NZ,IOERR	; Jump on param error;;	Check if REC or LRL were specified;	LD	A,(LRESP)	; Get LRL response	LD	B,A		; Save in B	LD	A,(RRESP)	; Get REC response	OR	B		; Either specified?	JR	Z,RPARM		; No - check # records;;	If size was also specified - parameter error;	LD	A,(SRESP)	; Size can't be used	OR	A		;   with REC or LRL	JP	NZ,PRMERR	; Param error;;	Check record count;RPARM	LD	BC,$-$		; Get # of records	LD	A,B	OR	C	JR	NZ,LPARM;;	Zero records, use size instead;SPARM	LD	HL,$-$		; Get size param	LD	A,H	OR	L	JP	Z,PRMERR	; Err if size not entered;;	Multiply HL by 4 to get # of sectors;	ADD	HL,HL		; x 2	ADD	HL,HL		; x 4	LD	(RPARM+1),HL	; Pretend it's REC input;;	Make sure LRL input is valid;LPARM	LD	BC,$-$		; Get LRL	LD	A,B		; Test for > 256	OR	A		; If hi-order = 0	JR	Z,LP1		;   just use lo-order	DEC	A		; Test hi-order = 1	JP	NZ,PRMERR	; Quit if any other	OR	C		; Get low order	JP	NZ,PRMERR	; Must be zeroLP1	OR	C		; Merge low order;;	Open the file with the LRL specified;	LD	DE,FCB		; Open the file	LD	HL,BUFFER	LD	B,A		; LRL = 256 or user entry	@@INIT	JP	NZ,IOERR	; Jump on INIT error;;	Display "Creating: filespec" string;	LD	DE,FILESP	; DE => filespec	LD	BC,(FCB+6)	; Get drive #, DEC	LD	A,(FCB)		; Get to test device/file	CALL	$FNAME	JP	NZ,IOERR	; Leave on error	LD	HL,CREATE$	; "Creating..."	@@DSPLY			; Display it	JP	NZ,IOERR	; Quit on display error	LD	C,CR		; End line	@@DSP	JP	NZ,IOERR;;	Save ERN & offset from FCB for later;	LD	HL,(FCB+12)	; Get ERN	LD	(ERN+1),HL	LD	A,(FCB+8)	; Get offset byte	LD	(OFFSET+1),A;;	Check if new size > old size;BIGGER	LD	DE,FCB		; DE => FCB+0	@@LOF			; Get length of file	LD	H,B		; Move len to HL	LD	L,C	LD	BC,(RPARM+1)	; Get # of records	XOR	A		; Clear carry	PUSH	HL		; Save the ERN	SBC	HL,BC		; Is new > old?	POP	HL		; Get ERN back	JP	NC,BADSIZ	; Go if not;;	Position FCB to ending record number;	DEC	BC		; Reduce to offset from 0	@@POSN			; Position to new ERN;;	Fill a 256 byte buffer with 'E5' bytes;	LD	HL,BUFFER	; Buffer area	LD	DE,BUFFER+1	; "format" a sector	LD	BC,255	LD	(HL),0E5H	LDIR;;	Write the last record of the file;	LD	DE,FCB		; Write the new ERN sector	DEC	H		; Set HL = buffer start	INC	HL	CALL	WRITE		; Write the last record	@@REW			; Rewind file;;	Read in the directory entry;	LD	BC,(FCB+6)	; Get drive # & DEC	CALL	DODIRRD		; Read in directory;;	Do we have to fill the file?;FILL	LD	BC,0100H	; Get FILL param	DEC	B	RET	Z		; Return if no fill;;	Create a buffer with the FILL bytes;	PUSH	DE		; Save FCB pointer	LD	HL,BUFFER	; I/O buffer	LD	(HL),C		; Byte to xfer	LD	DE,BUFFER+1	LD	BC,255+256	; Hit both buffers	LDIR			; Xfer into buffer;;	Pt HL => user buff, DE => FCB, BC = Last Rec;	POP	DE		; Restore FCB pointer	LD	BC,(RPARM+1)	; Get last record	LD	HL,UBUFF	; User buffer;;	Loop to write logical records;WRLOOP	LD	A,B		; Is rec count = 0?	OR	C	RET	Z		; Yes - done	CALL	WRITE		; Write record	DEC	BC		; Dec one	JR	WRLOOP		; Do until BC = 0;;	Write the buffer contents;WRITE	@@WRITE			; Write buffer	RET	Z		; Good - return	DB	21H		; Skip LD A,## instrPRMERR	LD	A,PAR_ERR	; Parameter error;;	I/O Error display and abort routine;IOERR	LD	L,A		; Save error # in HL	LD	H,00H	OR	0C0H		; Short error messages	LD	C,A		; Move to C for @ERROR	@@ERROR			; Display error messageSAVESP	LD	SP,$-$		; Get original SP	RET			; Done, return;;	Set file to be shrinkable;SHRINK	LD	A,0BEH		; Change SET to RES	LD	(SHR01+1),A	;   by modifying code;;	Read directory and set/clear shrinkable bit;DODIRRD	@@DIRRD			; Read directory	JR	NZ,IOERR	; Go on error	INC	HL		; Point to flagsSHR01	SET	7,(HL)		; Set/clear shrinkable bit	@@DIRWR			; Write it back out	JR	NZ,IOERR	RET			; return to caller;;	Routine to pick up device/file name;$FNAME	BIT	7,A		; Test device/file	JR	Z,FNAME1	; Go if device	@@FNAME	RET;FNAME1	LD	A,'*'		; Stuff device indicator	LD	(DE),A	INC	DE	LD	A,C	LD	(DE),A		; Stuff 1st char	INC	DE	LD	A,B	LD	(DE),A		; Stuff 2nd char	INC	DE	LD	A,ETX	LD	(DE),A		; Stuff ETX	RETSPCREQ	LD	HL,SPCREQ$	DB	0DDHBADSIZ	LD	HL,BADSIZ$	@@LOGOT			; Log error;;;ABORT	LD	HL,-1		; Set abort code	JR	SAVESP		; and exit;;	Messages;SPCREQ$	DB	'File spec required',CRBADSIZ$	DB	'File exists larger',CRCREATE$	DB	'Creating: 'FILESP	DS	15;PRMTBL$	DB	80H;;	SIZE (S) - numeric input only;	DB	NUM!ABB!4,'SIZE'SRESP	DB	00H	DW	SPARM+1;;	REC (R) - numeric input only	DB	NUM!ABB!3,'REC'RRESP	DB	00H	DW	RPARM+1;;	LRL (L) - numeric input only;	DB	NUM!ABB!3,'LRL'LRESP	DB	00H	DW	LPARM+1;;	FILL (F) - numeric or flag input only;	DB	FLAG!NUM!ABB!4,'FILL'FRESP	DB	00H	DW	FILL+1;;	SHRINK - flag input only;	DB	FLAG!6,'SHRINK'SHRSP	DB	00H	DW	SHRPRM+1	DB	00H		; End of table;FCB	DB	00H	DS	31;	ORG	$<-8+1<+8;BUFFER	DS	256UBUFF	DS	256;	END	CREATE