;BACKUP1/ASM - Backup Utility Module	SUBTTL	'<Backup Initialization>';SMALL	EQU	0FMT	EQU	0LF	EQU	10CR	EQU	13LOCK	EQU	60HTKCAP	EQU	0CCHPSWD	EQU	0CEHDAT	EQU	0D8HAUTO	EQU	0E0HFCNT1	EQU	1111HFCNT2	EQU	1555HPASSWORD	EQU	42E0H;*GET	SVCMAC			; System SVC macros*GET	COPYCOM			; Copyright message;	ORG	2600H;	IF	@MOD2BOOTST$ DB	03H	ENDIF;	IF	@MOD4BOOTST$ DB	9DH	ENDIF;FTFLG$	DB	00HSPCFLD$ DC	11,20HMFLG$	DB	00HNEWPRM$ DW	0OLDPRM$ DW	0MODPRM$ DW	0QPARM$	DW	0BUFFER$ DW	0FCB1$	DS	32FCB2$	DS	32FCB3$	DS	32;LILBUF$ EQU	FCB3$DATFLD$ DS	8FMPAKD$ DS	2TOPAKD$ DS	2CLSFLG$	DS	1;	IF	@MOD2	;something that was invisible	ENDIF;;	Normal exit - no errors;EXIT1	LD	HL,BUCAO$	;"Backup complete	PUSH	HL		;Save msg ptr	CALL	EXIT5		;Ck if prompt for sys disk	POP	HL	@@DSPLY	JR	EXIT		;Get on out;;	Error exit;DIRERR	LD	A,11H		;Init "Dir read error	DB	01H		;Ignore next instrEXIT2	LD	A,20H		;Init illegal drive #EXIT3	PUSH	AF	LD	C,CR	@@DSP	CALL	EXIT5	POP	AF		;Get error back	LD	L,A		;Move it to HL	LD	H,00H	OR	0C0H		;Short msg,return	LD	C,A		;In C for SVC	@@ERROR	JR	ERREXIT;;	Abort exit;BREAK	EQU	$ABRTBU	LD	HL,ABRTBU$	;"Backup abortedEXIT4	PUSH	HL		;Save msg ptr	CALL	EXIT5		;Get system disk if needed	POP	HL	@@LOGOT			;Display the message	LD	HL,-1		;Set error return codeERREXIT LD	(RETCOD),HLEXIT	EQU	$SPSAV	LD	SP,$-$		;Pick up stack pointer	LD	HL,0		;Set the return codeRETCOD	EQU	$-2	@@CKBRKC		;Check and clear break	@@EXIT			;Can't RETurn from BACKUP;;	Get system disk if needed and zero memory used;EXIT5	EQU	$XPARM$	LD	DE,0		;Get prompt zero drive	INC	E		;Check for entry	JR	NZ,EXIT5A	XOR	A	LD	(SXORD+1),A	CALL	SYSDRV$		;Force prompt for SYSTEM	JR	EXIT5BEXIT5A	LD	A,(SXORD+1)	;  else if not entered	OR	A		;  ck if source & dest	CALL	Z,NDSYS$	;  are same - we may needEXIT5B	LD	DE,(BUFFER$)	;  a prompt	LD	A,D		;Ck if we did a backup	OR	E	RET	Z		; Ret if buf addr never set	LD	HL,0		;   else calculate how	LD	B,L		;   many bytes in RAM	@@HIGH$			;   to zero	XOR	A		; Clear carry flag	SBC	HL,DE		; Get length to zero	LD	B,H		;   into BC	LD	C,L	LD	H,D		; Move start of buffer	LD	L,E		;   to HL	INC	DE	LD	(HL),00H	; Init 1st byte to 0	DEC	BC		;   and propogate it	LDIR	RET;;	Prompt for a system disk;NDSYS$	LD	A,(SRCDRV$+1)	; On exit, if S = D <> 0	OR	A		;   then no need to prompt	RET	NZSYSDRV$ LD	A,00H		; Get drive 0 indicator	OR	20H		; Set bit 5 for sys test	PUSH	HL	LD	HL,PMTSYS$	; "Insert system...	PUSH	AF	LD	A,(CURDSK+1)	LD	(SAVCDSK+1),A	POP	AF	CALL	CURDSK		; Check if flash needed	LD	A,(CURDSK+1)	; Get curr disk	AND	07H		; Force any other bits off	LD	C,A		; Store in C for SVC	@@GTDCT			; Get drive control table	LD	A,(IY+04H)	; Get DCT flags 2	PUSH	AF		; Save it	AND	7FH		; Force @CKDRV inhibit off	LD	(IY+04H),A	; Store back in DCT	PUSH	IY		; Save DCT	@@CKDRV			; Check drive available	POP	IY		; Get IY back	POP	BC		; Get original DCT+4 back	PUSH	AF	LD	A,B		; Original DCT+4	AND	80H		; Mask off other stuff	OR	(IY+04H)	; Merge back in	LD	(IY+04H),A	; And put DCT back like it was	POP	AF		; Get @CKDRV results back	POP	HL	RET	Z		; Return if okaySAVCDSK LD	A,00H	LD	(CURDSK+1),A	JR	SYSDRV$;SRCDRV$ LD	A,00H		; Source drive	OR	80H		; Set bit 7 on source	PUSH	HL	LD	HL,PMTSRC$	; "Insert source	CALL	CURDSK		; Prompt if needed	POP	HL	RET;;	Prompt source disk if needed to swap;PMTSRC	LD	A,(CURDSK+1)	; Get current drive	BIT	7,A		; Is source the one?	JR	NZ,SRCDRV$	; Jump if it is	CALL	SRCDRV$		;   else prompt for it	LD	A,(SXORD+1)	OR	A	RET	NZ		; Ret if source <> dest	CALL	RESTOR		; Restore to cyl 0	PUSH	BC		; Save registers	PUSH	DE	PUSH	HL	LD	HL,BUF3$	; Use this I/O buffer	LD	DE,0		; Read the BOOT	CALL	RDSEC	POP	HL		; Restore registers	POP	DE	POP	BC	JP	NZ,EXIT3	; Quit on read error	LD	A,(BUF3$)	; Get 1st byte of boot	OR	A		; If source, s/b 0	JR	NZ,PSRC3	; Jump if not this disk	PUSH	BC	PUSH	DE	PUSH	HL	LD	D,(IY+09H)	; Get DIR cyl	LD	E,00H		; Pt to GAT sector	LD	HL,BUF3$	CALL	RDSEC		; Read the GAT	CP	06H	JP	NZ,DIRERR	LD	HL,BUF1$+PSWD	; Check for match with	LD	DE,BUF3$+PSWD	;   original source disk	LD	B,0AH		; Set match countPSRC1	LD	A,(DE)		; Get byte	CP	(HL)		; Compare them	JR	NZ,DIFSRC	; Wrong disk if no match	INC	DE		; Bump pointers	INC	HL	DJNZ	PSRC1		; Loop for 10 bytes	POP	HL	POP	DE	POP	BC	RETDIFSRC	LD	HL,DIFSRC$	; "Wake up!"	@@DSPLY	POP	HL		; Clean the stack	POP	DE	POP	BCPSRC3	XOR	A	LD	(CURDSK+1),A	JR	PMTSRC;;	Destination disk selection;DSTDRV$ LD	A,00H		; Dest drive	OR	40H		; Set dest diskette code	PUSH	HL	LD	HL,PMTDST$	; "Insert dest...	CALL	CURDSK	POP	HL	RET;;	Prompt destination if needed;PMTDST	LD	A,(CURDSK+1)	; Get current disk/drive and	BIT	6,A		;   check if destination disk	JR	NZ,DSTDRV$	; Jump if it is	CALL	DSTDRV$		;   else request swap	LD	A,(SXORD+1)	OR	A	RET	NZ		; Return if source <> dest	CALL	RESTOR		; Restore to cyl 0	PUSH	BC		; Save registers	PUSH	DE	PUSH	HL	LD	HL,BUF3$	; Use this buffer	LD	DE,0		; Boot sector	CALL	RDSEC		; Read it	POP	HL		; Restore registers	POP	DE	POP	BC	JP	NZ,EXIT3	; Quit on read error	LD	A,(BUF3$)	; Get 1st byte of BOOT	CP	76H		; Dest s/b a HALTPMTDST1 RET	Z		; Return if okay	PUSH	HL	PUSH	DE	LD	HL,DIFDST$	; "Not same dest...	@@DSPLY	POP	DE	POP	HL	XOR	A	LD	(CURDSK+1),A	; Show no current diskette	JR	PMTDST		;   and prompt again;;	Force a prompt of the target disk;FRCPMT	LD	A,C		; Get target drive	LD	(CURDSK+1),A	;   with code bit	JR	FLASH;;	Routine to check if flashing prompt is needed;CURDSK	CP	00H		; Pick up current disk	JR	Z,FLSH6		; Match with wanted disk?	LD	(CURDSK+1),A	; No, update currentSXORD	LD	A,0FFH		; 0=src & dest same drive	OR	A	JR	NZ,FLSH6	; Jump if source <> dest;;	Routine to flash the prompt;FLASH	PUSH	BC		; Save registers	PUSH	DE	PUSH	HL	@@FLAGS			; IY -> flag table base	LD	C,0DH		; Write a new line	@@DSP	LD	C,0FH		; Cursor off	@@DSPFLASH0	@@CKBRKC		; Check and clear BREAK	CALL	RESKFLG		; Reset pause, enter, break	LD	BC,41FDH	; 1/4 second delay	@@PAUSE	LD	A,(IY+'K'-'A')	; Get KFLAG$	AND	4!1		; Wait for no ENTER/BREAK	JR	NZ,FLASH0	CALL	RESKFLG		; Reset in case of breakFLS1	@@DSPLY	LD	BC,FCNT2	CALL	FLS2		; Blink start	LD	C,1DH		; Cursor to BOL	@@DSP	LD	C,1EH	@@DSP	LD	BC,FCNT1	; Wait delay count	CALL	FLS2		; Wait and chk enter or break	JR	FLS1;FLS2	@@CKBRKC		; Check for break	JP	NZ,BREAK	;   and abort if so	LD	A,(IY+'K'-'A')	; Get KFLAG$ settings	BIT	2,A		; Enter pressed?	JR	NZ,FLS4		; Go if so	DEC	BC		; Count down	LD	A,B	OR	C	JR	NZ,FLS2		; Loop if more time	RET;FLS4	POP	AF		; Pop return addressFLS5	@@KBD			; Clear type ahead buffer	JR	Z,FLS5		; Loop until clear	LD	C,0DH		; Display a new line	@@DSP	LD	C,0EH		; Cursor on	@@DSP	CALL	RESKFLG		; Reset Break,Enter,Pause	POP	HL		; Restore registers	POP	DE	POP	BCFLSH6	LD	A,(CURDSK+1)	; Get drive #	AND	07H		; Strip off code bits	LD	C,A		; Drive # to C to get	@@GTDCT			;   DCT vector	IF	@MOD4	CALL	RSLCT		; Get drive status in A	ENDIF	IF	@MOD2	CALL	SELECT	ENDIF	RLCA			; Rotate status	RLCA	RET;RESKFLG LD	A,(IY+'K'-'A')	; Get KFLAG$	AND	0F8H		; Erase 3 bits	LD	(IY+'K'-'A'),A	; Save it back	RET;;	Disk drive I/O call setups;TSTDRV	PUSH	BC		; Save BC	XOR	A		; @DCSTAT	JR	DI01		; Test for driveSELECT	PUSH	BC	LD	A,01H		; @SLCT	JR	DI01		; Select new driveRESTOR	PUSH	BC	LD	A,04H		; @RSTOR	JR	DI01		; RestoreRSLCT	PUSH	BC	LD	A,07H		; @RSLCT	JR	DI01		; ReselectWRSEC	PUSH	BC	LD	A,0DH		;@WRSEC	JR	DI01		; Write sectorWRSYS	PUSH	BC	LD	A,0EH		;@WRSSC	JR	DI01		; Write DIR sectorRDSEC	PUSH	BC	LD	A,09H		;@RDSEC	JR	DI01		; Read sector;	IF	@MOD2FMTCYL	PUSH	BC	LD	A,15		; I/O Command	JR	DI01	ENDIF;VERSEC	PUSH	BC	LD	A,0AH		; @VRSECDI01	ADD	A,28H		; Add offset to disk SVCs	LD	B,A		; Save temporarily	LD	A,(CURDSK+1)	; Get drive number	AND	07H		; Mask off type bits	LD	C,A		; Store in C for SVC	LD	A,B		; Get SVC back	IF	@MOD4	DI			; Interrupts off	ENDIF	RST	28H		; Perform disk operation	IF	@MOD4	EI			; Interrupts on again	ENDIF	POP	BC	RET;;	Check for correct disk;CKSWDD	PUSH	DE		; Save DE,BC	PUSH	BC	LD	A,(SRCDRV$+1)	; Get drive	LD	HL,CURDSK+1	LD	C,(HL)		; Get current drive	LD	(HL),A		; Make curdsk our disk	LD	HL,(BUFFER$)	; I/O buffer	LD	DE,2		; Track 0, sector 2PROTSEC EQU	$-2	CALL	RDSEC		; Read SIS sector	JR	NZ,EX2		; Quit on read error	LD	L,0C6H		; Set buffer position	LD	A,$-$		; Get source disk backup limitSVCTR	EQU	$-1	CP	(HL)		; Is it the same as this disk?	JR	NZ,EX1		; NZ = error exit	INC	A		; Was byte FF?	JR	Z,EX1		; Go if it was	DEC	A		; If ID byte = 0	JR	Z,EX1		;   no modifying needed	DEC	A		;  Dec backups remaining	JR	NZ,$+3		; If backups left, don't dec again	DEC	A		; If now 0, make FFh	LD	(HL),A		; Store new backup count	IF	@MOD2	LD	L,0		; Reset the buffer	ENDIF	IF	@MOD4	LD	L,D		; Reset the buffer	ENDIF	CALL	WRSEC		; Write it, check error laterEX1	LD	A,C		; Get original drive #	LD	(CURDSK+1),A	; Store it back	POP	BC	POP	DEEX2	LD	HL,CANTBU$	; "WP'd and prot files"	RET	Z		; Return if okay	JP	EXIT4		;   else display and exit;;	Message area;DSTWP$	DB	0AH,'Destination disk is write protected',0DHSYSV62$ DB	'Can',27H,'t move SYS files from 6.2 or '	DB	'earlier versions to 6.3.x',0DHBADMPW$ DB	'Invalid master password',0DHPMTSYS$ DB	1DH,1EH,'Insert SYSTEM disk  <ENTER>',03HPMTSRC$ DB	1DH,1EH,'Insert SOURCE disk  <ENTER>',03HPMTDST$ DB	1DH,1EH,'Insert DESTINATION disk  <ENTER>',03HDIFSRC$ DB	1DH,1EH,'* A L E R T *  That',27H	DB	's not the same source disk ',0DHDIFDST$ DB	1DH,1EH,'* A L E R T *  That',27H	DB	's not the same destination disk ',0DHCCMOD$	DB	'Source disk is write protected; '	DB	'MOD flags not updated',0DHBUCAO$	DB	 0AH,'Backup complete',0DHABRTBU$ DB	0AH,'Command aborted',0EH,0DHCANTBU$ DB	'Can''t Backup - source disk write protected',0AHPROT$	DB	'Disk contains protected files ',0DHGATCD0	NOPGATCD1	NOPGATCD2	NOP;BUCORE$ DEFL	$	ORG	$<-8+1<+8;BUF1$	DS	256		; Three disk buffersBUF2$	DS	256BUF3$	DS	256;;;	Backup Entry Point;;BACKUP	@@CKBRKC	JR	Z,BACKUPA	LD	HL,-1	RET;BACKUPA LD	(SPSAV+1),SP	; Save current SP	PUSH	HL		; Save cmd buffer	LD	HL,0		; Remove any BREAK vector	@@BREAK	LD	HL,HELLO$	; Welcome	@@DSPLY	@@FLAGS			; Get FLAG table to IY	PUSH	IY	POP	DE	LD	HL,'Y'-'A'	ADD	HL,DE		; Point to YFLAG$	LD	(SVYFLG$),HL	; Save for later	CALL	RESKFLG		; Reset kbd flags	BIT	1,(IY+'C'-'A')	; Check on CMNDR active	LD	HL,LDOS$	JP	NZ,EXIT4	;   and exit if so	POP	HLBCK1	LD	A,(HL)		; Bypass cmdline spaces	INC	HL	CP	' '	JR	Z,BCK1;;	Scan for source partial spec;	LD	DE,SPCFLD$	; Point to filespec field	LD	B,08H		; Init for filename	CP	'-'		; Exclude matches?	JR	NZ,BCK2		; If '-' set flag	LD	(MFLG$),A	LD	A,(HL)		; Get next char	INC	HLBCK2	CALL	PRSPEC	CP	'.'	JR	Z,BCK2A	CP	'/'	JR	NZ,BCK3BCK2A	LD	DE,SPCFLD$+8	; Reposition buffer ptr	LD	B,03H		; 3 chars in extension	LD	A,(HL)	INC	HL		; Bypass the "/"	CALL	PRSPEC		; Parse extension;;	Determine source and destination drives;BCK3	CP	':'		; Drive number coming?	JR	Z,BCK4	CP	')'	JR	C,BCK3A	LD	A,13H	JP	EXIT3BCK3A	DEC	HL	PUSH	HL	LD	HL,SRCNUM$	; Prompt for them	@@DSPLY	LD	HL,LILBUF$	LD	BC,1<8		; 1 char response	@@KEYIN	JP	C,ABRTBU	; Quit on break	LD	A,(HL)		; Get response.	 Restore	POP	HL		;   command buffer	DB	0DAH		; Ignore next 2 with JP C,nnBCK4	LD	A,(HL)		; Get source drive	INC	HL		; Bump pointer	SUB	'0'		; Convert to binary	CP	08H		; In range <0-7>?	JP	NC,EXIT2	; Quit if not	LD	(SRCDRV$+1),A	; Save source driveBCK5	LD	A,(HL)		; Get char or separator	INC	HL		; Bump pointer	CP	':'		; Find dest drive?	JR	Z,BCK6		; Get drive # if ":"	CP	'0'		;  let prepositions thru	JR	NC,BCK5	CP	' '		;   or a space separator	JR	Z,BCK5	DEC	HL		; Save possible params	PUSH	HL	LD	HL,DSTNUM$	; Prompt for dest drive	@@DSPLY	LD	HL,LILBUF$	; Use for keyin buffer	LD	BC,1<8		; 1 char only	@@KEYIN	JP	C,ABRTBU	; Quit on BREAK	LD	A,(HL)		; Get response	POP	HL		; Restore buffer	DB	0DAH		; Ignore next 2 instrBCK6	LD	A,(HL)		; Get dest drive #	INC	HL		; Bump line ptr	SUB	'0'		; Adjust to binary	CP	08H		; Make sure <0-7>	JP	NC,EXIT2	; Quit if out of range	LD	(DSTDRV$+1),A	; Save destination drive;	LD	DE,PRMTBL$	; Pt to Param Table	PUSH	DE		; Also in IX to check	POP	IX		;   responses	@@PARAM			; Parse parameters	LD	HL,PRMERR$	; "Param error	JR	NZ,$EX4		; Quit on param error	LD	A,(IX+DATRSP)	; Date can only be STR	AND	VAL!SW		; This must be string$EX4	JP	NZ,EXIT4	; Quit if not;;	Check on source = destination;	LD	A,(SRCDRV$+1)	; Get source drive	LD	HL,DSTDRV$+1	XOR	(HL)		; Match against dest	LD	(SXORD+1),A	; 0 if S=D, <>0 if S<>D	JR	NZ,DATPRM	; Bypass if src <> dest	@@FLAGS			;   else test if DO active	BIT	5,(IY+'S'-'A')	LD	HL,NOINDO$	; "Can't do single...	JP	NZ,EXIT4	; Abort if from <DO>;;	Check on date entries;DATPRM	LD	HL,0		; Get date from-to	LD	A,H	OR	L	JR	Z,CKCLAS	; Bypass if not entered	LD	A,(HL)		; Check for "-to"	CP	'-'	JR	Z,CKTO		; Go if no from entered	LD	A,80H		; Set from bit	LD	(FTFLG$),A	; Note From entered	CALL	PAKDAT		; Pack the date entry	LD	(FMPAKD$),BC	; Save the packed FROM date	LD	A,(HL)		; Check if more in date param	CP	'"'		; End of string?	JR	Z,FRCDAT	; Go if so	CP	'-'		; Check for "-to"	JR	NZ,CKCLAS	; Done if notCKTO	INC	HL		; Bypass the "-"	LD	A,(HL)		; Chk for end of param	CP	'"'	JR	Z,CKCLAS	; Go if done	CALL	PAKDAT		; Pack the TO dateFRCDAT	LD	A,(FTFLG$)	; Get from/to flag	OR	01H		; Set TO bit	LD	(FTFLG$),A	; Save it back	LD	(TOPAKD$),BC	; Save packed TO date;;	Check on params to force CLASS backup;CKCLAS	LD	B,0		; Init class flagSYSPRM	LD	DE,0		; SYS param used?	LD	A,D	OR	E	JR	Z,INVPRM	SET	6,B;INVPRM	LD	DE,0		; Get INV parm	LD	A,D	OR	E	JR	Z,CKCLA1	; Go if not	SET	3,B		; Set bit 3 if INVCKCLA1	LD	A,B	LD	(CLSFLG$),A	; Store by class flag	LD	A,(SPCFLD$)	; Get 1st char of possible	SUB	' '		;   file name	LD	B,A		; Save test result and	LD	A,(SPCFLD$+8)	;   check if ext used	SUB	' '		; Check for ext	OR	B		; A <> 0 if partspec	LD	B,A		; Hold in reg B;;	Merge all CLASS params together;	LD	A,(IX+SYSRSP)	; System files	OR	(IX+INVRSP)	; Invisible files	OR	(IX+MODRSP)	; Mod flag files	OR	(IX+NEWRSP)	; Files not on dest	OR	(IX+OLDRSP)	; Files on dest	OR	(IX+QRSP)	; Query forces by class	LD	C,A		; Hold value	AND	VAL!STR		; Above params only SWITCH	LD	HL,PRMERR$	; Init "Param error	JP	NZ,EXIT4	; Quit if not only switches	OR	C	OR	B		; Merge with partspec	OR	(IX+DATRSP)	; D="mm/dd/yy-mm/dd/yy");;	Advise backup by class if any class parameter;	LD	(CLSTST+1),A	; Set for all flags	JR	Z,GETDAT	; Z may be mirror image	LD	HL,CLASS$	; Log by class message	@@LOGOT;;	Recover today's date;GETDAT	LD	HL,DATFLD$	; Date storage buffer	@@DATE			; Get system date	LD	A,(DE)		; Check if date in system	OR	A	JR	NZ,GETGM	; Go if it is	LD	HL,NODAT$	; Show "No date.." if none	@@LOGOTGETGM	PUSH	DE		; Save date$	PUSH	HL		;   and date buffer	LD	DE,RES$		; See if SYS modules resident	@@GTMOD			;   in case needed later	JR	NZ,GETDAT1	; Skip if none res'd	LD	(RESLOC+1),DE	; Store the module loc;;	Get SYS2 loaded for password hash;GETDAT1 POP	HL	POP	DE	CALL	GETSYS2		; Get SYS2 and move date;;	Check on (X) param for source/dest swap;	LD	A,(SRCDRV$+1)	; If source is not 0	OR	A		;   then let PMTSRC handle	JR	NZ,SRCDFT	OR	80H		; Set to SRC code	LD	C,A		; Save if needed	LD	A,(XPARM$+1)	; Source is drive 0,	INC	A		;   if (X), then swap	PUSH	AF	LD	HL,PMTSRC$	CALL	Z,FRCPMT	; Force prompt on (X)	POP	AFSRCDFT	CALL	NZ,SRCDRV$	; Prompt for source	CALL	RESTOR		; Get set to see if a	CALL	CKDRV		;   source disk mounted	JR	Z,GOTSRC	; Z=okay	PUSH	AF	LD	HL,PMTSRC$	; "Insert source	CALL	FRCPMT	POP	AF	JR	SRCDFT		; Check again;;	Get source disk attributes;GOTSRC	LD	A,(IY+03H)	; Get 5" or 8" from	AND	20H		;   bit 5 of DCT+3	LD	(TST5_8+1),A	;   and save for later	CALL	TSTDRV		; Check for active DCT	JP	NZ,EXIT3	;   and quit if not	LD	HL,BUF3$	; Disk buffer;	IF	@MOD2	CALL	GETPSPEC	; Get prot sector	JP	NZ,EXIT3	; Go on error	CP	6		; Directory?	JP	NZ,DIRERR	; Nope, go!	ENDIF	LD	DE,0		; Set to track 0, sec 0	CALL	RDSEC		; Read boot	JP	NZ,EXIT3	; Quit on read error	LD	A,(BUF3$+02H)	; Get dir track	LD	(IY+09H),A	; Stuff into DCT	IF	@MOD2	LD	DE,(PROTSEC)	; Get info sector	ENDIF	IF	@MOD4	INC	E		; Point to SYSINFO sector	INC	E	ENDIF	LD	H,BUF1$<-8	; Use this disk buffer	CALL	RDSEC		; Read the info sector	JP	NZ,EXIT3	; Quit on error	LD	A,(BUF1$+0C6H)	; Get backup limit counter byte	LD	(SVCTR),A	; Save the counter	INC	A		; FF -> 0??	JR	Z,CKGAT		; Go if so;;	Check write protect status;	DEC	A		; Need to check?	JR	Z,CKGAT		; Go if not	CALL	RESTOR		; Start the drive	CALL	RSLCT		; Check if WP	OR	(IY+03H)	; Merge in soft WP	RLCA			; Push WP to CF	JR	NC,CKGAT	; Bypass if not WPCANTBU	LD	HL,CANTBU$	; Can't back up!	JP	EXIT4;CKGAT	LD	D,(IY+09H)	; Directory track	LD	E,00H		;    sector 0	LD	HL,BUF1$	; Use this buffer	CALL	RDSEC		; Read GAT	CP	06H		; Ensure directory cyl	JP	NZ,DIRERR	; Quit on any other error	LD	A,(BUF1$+0CDH)	; Get disk configuration byte	AND	08H		; Only keep bit 3	LD	(GATCD1),A	; Save the byte	LD	(GATCD2),A	;   in 3 locations	LD	(GATCD3+1),A	;   for later use	CALL	TSTMPW		; Get/test password;;	Check if destination formatted and not protected;	LD	A,(DSTDRV$+1)	; If dest is not 0	OR	A		;   let DSTDRV handle it	JR	NZ,DSTDFT	OR	40H		; Set DST code	LD	C,A		; Save if needed	LD	A,(XPARM$+1)	; Dest is drive 0	INC	A		; if (X) then swap	PUSH	AF	LD	HL,PMTDST$	CALL	Z,FRCPMT	; Force prompt on (X)	POP	AFDSTDFT	CALL	NZ,DSTDRV$	; Get dest drive	CALL	RESTOR		; Restore destination	CALL	RSLCT		; Test it	JR	NZ,PMTDD	; Might be signal from HD driver	RLCA	OR	(IY+03H)	; Merge in soft WP	BIT	7,A		; Check on WP status	LD	HL,DSTWP$	; "Dest write prot...	JP	NZ,EXIT4	; Jump if write protected	CALL	CKDRV		; Check if disk in place	JR	NZ,PMTDD	LD	A,(CKDRBUF+0CDH)	; Get GAT of whatever	AND	08H		; Check new date format	RRCA			; Rotate right	LD	L,A		; Store it in LGATCD3	LD	A,00H		; Get GAT+0CDH	OR	L		; Merge with other GAT+CD	LD	(GATCD0),A	; Save it	CP	04H		; Is destination new date format?	JR	NZ,M3076	; Go if not	LD	A,(SYSPRM+1)	; Get SYS parameter	OR	A		; Is it set?	LD	HL,SYSV62$	; "Can't move SYS files	JP	NZ,EXIT4	; Go if SYS enteredM3076	BIT	3,(IY+03H)	; If hard drive, don't	JP	NZ,RECON	;   try to test for write	JR	GOTDST;;;PMTDD	PUSH	AF		; Kludge a force of	LD	HL,PMTDST$	;   the destination prompt	CALL	FRCPMT	POP	AF	JR	DSTDFT;;	Check 5" vs 8" for forced reconstruction;GOTDST	LD	A,(IY+03H)	; Get drive size	AND	20H		; See if 5/8 matchTST5_8	XOR	00H	JP	NZ,RECON	; Go if different	LD	DE,0	CALL	VERSEC		; Verify boot sec readable	JR	Z,CKDST;;	Destination not formatted, abort;	LD	HL,NOFMT$	JP	EXIT4;;	Check destination attributes;CKDST	LD	HL,BUF3$	; Use this buffer	LD	DE,0		; Boot sector	CALL	RDSEC		; Read it	JP	NZ,EXIT3	; Quit on error	LD	A,(BUF3$+02H)	; Get dir track	LD	D,A		; Set up in D	LD	HL,BUF2$	; Use BUF2 for GAT	LD	E,L	CALL	RDSEC		; Read sector	CP	06H		; Ensure a DIR cylinder	JP	NZ,DIRERR	; Go if any other error	LD	HL,(BUF1$+TKCAP)	; Get source capacity	LD	DE,(BUF2$+TKCAP)	; Get dest capacity	LD	A,(SVCTR)	; If backup limit counter	INC	A		;   was FFh	JR	Z,SHOPROT	; Show protected	DEC	A		; If counter wasn't 0	JR	NZ,TSTCAP	;   then test sizes	BIT	4,H		; If types differ	JR	Z,TSTCAP	;   force reconstruct;SHOPROT LD	HL,PROT$	; Show has prot files	@@LOGOT	JR	RECON		; Skip next tests;TSTCAP	LD	A,H		; Den/sides match	XOR	D		; Force reconstruct if	AND	60H		;   density or sides	JR	NZ,RECON	;   differ	LD	A,L		; Test # of cylinders	SUB	E	JR	Z,BYCLAS	; Jump if same;;	Cylinder count differs - question mirror;	LD	A,(CLSTST+1)	; But don't question if	OR	A		;   Class params already	JP	NZ,CLSTST	;   entered	CALL	MIRROR		; Attempt mirror?BYCLAS	JP	Z,CLSTST	; Jump if mirror to be triedRECON	LD	HL,RECON$	; "Backup reconst...	@@LOGOT	JP	MVBYCLS		; Go do file backup;;	Different # of tracks - prompt for mirror;MIRROR	LD	HL,MIRROR$	; "Attempt mirror?	@@DSPLY	LD	HL,LILBUF$+1	LD	BC,3<8		; 3 char max	@@KEYIN	JP	C,ABRTBU	; Quit on break	LD	A,(HL)		; Get char	RES	5,A		; Force to upper case	CP	'Y'		; Ret Z if yes	RET;;	Get and check disk master password;TSTMPW	LD	HL,(BUF1$+0CEH) ; Disk pack password	LD	DE,PASSWORD	; Hash for "PASSWORD"	XOR	A		; Clear A	SBC	HL,DE		; Are they the same?	RET	Z		; Return if so;	LD	DE,0		; Get MPW from cmd lineMPWPRM	EQU	$-2	LD	HL,PMTMPW$	; "Enter MPW	CALL	GETMPW		; Get & hash the password	EX	DE,HL		; Put password in DE	LD	HL,(BUF1$+PSWD) ; Disk pack password	XOR	A		; Clear carry	SBC	HL,DE		; Are they the same?	RET	Z		; Return if okay	LD	HL,BADMPW$	; "Bad master...	JP	EXIT4		; Quit;;	Routine to parse partial filespecs & cnvt to UC;PRSPEC	CP	'*'		; Asterisk?	JR	NZ,PRSP02	; Go if not	LD	A,'$'		; Fill field with themPRSP01	LD	(DE),A	DJNZ	PRSP01		; Stuff in dest	LD	A,(HL)		; Get next char	INC	HL		; Inc buffer ptr	RET			;   and return;PRSP02	CP	'$'		; Wild char?	JR	Z,PS1		; Always match	CP	'A'		; Filename entered?	JR	NC,PS1	CP	'9'+1		; Check on 0-9?	RET	NC	CP	'0'	RET	CPS1	CP	'a'		; Convert to UC if needed	JR	C,$+4	RES	5,A		; Convert to upper	LD	(DE),A		; Save in partspec buffer	INC	DE		; Bump buff ptr	LD	A,(HL)		; Get next char	INC	HL		; Bump input ptr	DJNZ	PRSPEC		; Loop for (B) chars	RET;;	Pack user date string;PAKDAT	LD	A,(HL)	LD	C,'/'		; Init separator	CALL	PARSDAT		; Parse entry	JR	NZ,BADFMT	; Jump on format error*LIST	OFF	IFLT	@DOSLVL,'L'	;---> Before changes for 6.3.1L*LIST	ON	EX	DE,HL		; Swap entries	LD	A,(HL)		; Is year < 12?	CP	0CH	JR	NC,NOT2000	; Go if so	ADD	A,100		; Put it in the 2000s	LD	(HL),A		; Save backNOT2000 AND	03H		; Is year a leap year?	LD	HL,MAXDAYS+1	; Set Feb to have 29 days	JR	NZ,$+3	INC	(HL)		; Inc Feb's days	LD	A,(LILBUF$+2)	DEC	A		; Range check	CP	12	JR	NC,BADFMT	; Go if 0 or > 12	DEC	HL		; Point to Jan entry	ADD	A,L		; Index the month	LD	L,A	LD	A,H	ADC	A,00H*LIST	OFF	ELSE			;<--> 6.3.1L*LIST	ON;;	Handle Lev.H+ dates;	INC	DE		; Point to day	LD	A,(DE)		; Get day	DEC	A	CP	31		; Less than 31?	JR	NC,L316F	; Error if no	LD	C,A		; C=Day-1	INC	C		; C=Day	INC	DE		; Point to month	LD	A,(DE)		; Get month	DEC	A		; Month-1	CP	12		; Less than 12?L316F	JR	NC,BADFMT	; Error if no	LD	B,A		; B=Month-1	INC	B		; B=Month	DEC	DE		; Point to year	DEC	DE		;L3175	LD	A,(DE)		; Get year	SUB	80		; Year-80	JR	NC,L317C	; Don't adjust if >= 80	ADD	A,100		; else add 100L317C	JP	PKDAT+CLSBU-BACKUP  ;Jump to Pack Date routine	NOP			; Filler*LIST	OFF	ENDIF			;<--- 6.3.1L*LIST	ON	LD	H,A	LD	A,(LILBUF$+1)	; Get day entry	DEC	A		; Reduce for test (0->FF)	CP	(HL)		; compare	JR	NC,BADFMT	; Go if too large (or 0)	LD	HL,LILBUF$+2	; Point to month	LD	B,(HL)		; Get month in B	LD	C,00H		; Init C	SRL	B		; To bits 0-2 in B	RR	C		; and 7 in C	DEC	HL		; Point to day	LD	A,(HL)		; Get day	RLCA			; Move to bits 2-6	RLCA	OR	C		; Merge in partial month	LD	C,A		; Store in C	DEC	HL		; Point to year	LD	A,(HL)		; Get year value	SUB	80		; Adjust for offset	JR	NC,$+3		; If entry < 1980	XOR	A		;   then use 1980	RLCA			; Move to bits 3-7	RLCA	RLCA	OR	B		; Merge month	LD	B,A		; BC now holds date	EX	DE,HL		; Swap DE back	RET			;   and return;BADFMT	LD	HL,BADFMT$	; "invalid date	JP	EXIT4		; Quit;;	Routine to parse DATE/TIME entry;PARSDAT LD	DE,LILBUF$+2	; Point to buff end	LD	B,03H		; Process 3 fieldsPRSD1	PUSH	DE		; Save pointer	CALL	PRSD2		; Get a digit pair	POP	DE		; Recover pointer	RET	NZ		; Ret if bad digit pair	LD	(DE),A		;    else save the value	DEC	B		; Loop countdown	RET	Z		; Return if done	DEC	DE		; Backup the dest ptr	LD	A,(HL)		; Get separator	INC	HL		; Bump input ptr	CP	C		; Separator match?	JR	Z,PRSD1		; Loop if match	RET			; else ret bad (NZ);;	Routine to parse a digit pair;PRSD2	CALL	PRS4		; Get a digit	JR	NC,PRSD3	; Jump if bad digit	LD	E,A		; Multiply by 10	RLCA	RLCA	ADD	A,E	RLCA	LD	E,A	CALL	PRS4		; Get another digit	JR	NC,PRSD3	; Jump if it's bad	ADD	A,E		; Accumulate new digit	LD	E,A		; Xfer field value	XOR	A		; Clear flags	LD	A,E		; Get digit back	RET;PRSD3	OR	A		; Set NZ	RET;PRS4	LD	A,(HL)		; Get a digit	INC	HL		; Bump pointer	SUB	'0'		; Convert to binary	CP	0AH		; Set CF if good	RET	END