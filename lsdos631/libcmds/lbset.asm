;LBSET/ASM - Set and Filter commands	TITLE	<SET/FILTER - LS-DOS 6.3>;CR	EQU	13;*GET	SVCEQU			; System SVC equates;;CFLAG$	EQU	02HSFLAG$	EQU	12H;;	ORG this up here to allow driver programs to;	load at x'2400' without clobbering this program;	ORG	2C00H;;	FILTER entry point;M2C00	JP	FILTER		; Go to filter part;;	SET entry point;SET	LD	A,@FLAGS	; Get system flags	RST	28H	BIT	0,(IY+CFLAG$)	; Can't use if memory	JP	NZ,CANT		;   is frozen	LD	DE,DEVFCB	; Get filespec	LD	A,@FSPEC	RST	28H	JP	NZ,DEVREQ	; Quit if bad name	LD	A,(DE)		; Check on devicespec	CP	'*'	JP	NZ,DEVREQ	; Must have device	LD	DE,PGMFCB	; Get driver or filter	LD	A,@FSPEC	;   filespec	RST	28H	JP	NZ,SPCREQ	; Must be entered	LD	A,(DE)		; Target cannot be device	CP	'*'		;   since this is SET	JP	Z,SPCREQ	PUSH	HL		; Save INBUF$ pointer	PUSH	DE		;   and FCB start	LD	HL,SAVSPEC	; Save the filter/driver	EX	DE,HL		;   filespec to try /DVR	LD	BC,32		;   if /FLT is not found	LDIR	POP	DE		; Recover the FCB	LD	HL,FLTEXT	; Default extension is FLT	LD	A,@FEXT		; Use default if none	RST	28H	POP	HL		; Recover cmd line position;;	Make sure device is not in the system;	PUSH	HL		; Save INBUF$ pointer	LD	DE,(DEVFCB+1)	; Pick up device name	LD	A,@GTDCB	; Find device DCB address	RST	28H	JR	NZ,NEWDCB	; Go if not found	BIT	3,(HL)		;   else check if NIL	LD	A,27H		; Init "Device in use"	JR	Z,ERRPOP	; Error if not NIL;;	Inhibit SETting any system device;	PUSH	HL		; Save DCB pointer	LD	HL,DEVFCB	; Determine if system	LD	D,H		;   device by attempting	LD	E,L		;   to rename it	LD	A,@RENAM	; The error code will be	RST	28H		;    either 19 or 40	POP	HL	CP	40		; Protected system device?	JR	Z,ERRPOP	JR	GOTDCB		;   else we have it;;	Device not found - Locate a spare DCB;NEWDCB	LD	DE,0		; Find a spare device	LD	A,@GTDCB	RST	28H	LD	A,33		; "No device space avail	JR	NZ,ERRPOP	; Exit on error;;	DCB is available - Load the driver/filter;GOTDCB	PUSH	HL		; Save table address	SET	2,(IY+SFLAG$)	; Allow use with EXEC only	LD	DE,PGMFCB	; Load the target file	LD	A,@LOAD		; Transfer address in HL	RST	28H	JR	Z,LOADOK	; Go if file found	AND	3FH		; Strip flags	CP	1FH		; Program not found?	JR	NZ,LOADERR;;	No FILTER found, check on DRIVER;	LD	DE,SAVSPEC	; Original filename	LD	HL,DVREXT	; Try with /DVR	LD	A,@FEXT	RST	28H	SET	2,(IY+SFLAG$)	; Allow use with EXEC only	LD	A,@LOAD	RST	28H	JR	Z,LOADOK	; Go if file foundLOADERR	POP	HL		; Clean the stackERRPOP	POP	HL	JP	IOERR;;	Move device name into string buffer;LOADOK	POP	DE		; Recover table address	PUSH	DE	DI			; Don't interrupt me	LD	A,08H		; Set up as NIL first	LD	(DE),ANOSET	INC	E		; Transfer device name	INC	E		;   entered in command	INC	E		;   to the device table	LD	A,08H		; Show RESET as NIL	LD	(DE),A	INC	E	INC	E		; Point to name field	INC	E	LD	A,(DEVFCB+1)	; Move name to DCB	LD	(DE),A	INC	E	LD	A,(DEVFCB+2)	LD	(DE),A	EI			; Interrupts back onGODOIT	POP	DE		; Recover DCB address	EX	(SP),HL		; Stack prog's TRAADR	SET	3,(IY+CFLAG$)	; Set system request	RET			;   and go do it;;	FILTER *dev *dev routine;FILTER	LD	DE,DEVFCB	; Get first spec	LD	A,@FSPEC	RST	28H	JP	NZ,DEVREQ	; Quit on bad name	LD	A,(DE)		; Make sure it's a devspec	CP	'*'	JP	NZ,DEVREQ	; Quit if it's not	LD	DE,PGMFCB	; Get filter device spec	LD	A,@FSPEC	RST	28H	JP	NZ,SPCREQ	; Must be entered!	LD	A,(DE)	CP	'*'		; Target must be device	JP	NZ,DEVREQ	; Quit if it isn't	LD	DE,(PGMFCB+1)	; Get filter DCB address	LD	A,@GTDCB	RST	28H	JR	NZ,IOERR	; Quit if not found	BIT	6,(HL)		; Must be a filter	JR	Z,NOTFLT	; Quit if it isn't;;	Filter must be inactive to use it;	LD	D,H		; Move filter DCB pointer	LD	E,L		;   to DE and locate the	INC	L		;   DCB pointer in the	LD	A,(HL)		;   FILTER module	INC	L	LD	H,(HL)	LD	L,A	LD	BC,4		; HL now points to the	ADD	HL,BC		;   entry point.  Get its	LD	C,(HL)		;   DCB address by peeking	INC	C		;   past the name field	ADD	HL,BC	LD	A,(HL)		; Get low order	INC	HL	LD	H,(HL)		; Get high order	LD	L,A				; If DCB is NOT pointing	SBC	HL,DE		;   to itself, then it is	JR	NZ,ACTFLT	;   an active filter;;	The filter DCB points to its DCB (inactive);	PUSH	DE		; Save filter DCB	LD	DE,(DEVFCB+1)	; Find the device DCB	LD	A,@GTDCB	RST	28H	POP	DE	JR	NZ,IOERR	; Quit if not found;;	Swap the first three bytes of DCB and FILT DCB;	LD	B,03H		; Byte countSWAP	LD	C,(HL)	LD	A,(DE)	LD	(HL),A	LD	A,C	LD	(DE),A	INC	L	INC	E	DJNZ	SWAP		; Loop for 3 bytes	JR	EXIT;;	Default extensions for filter and driver;FLTEXT	DB	'FLT'DVREXT	DB	'DVR';;IOERR	LD	L,A		; Error code to HL	LD	H,00H	OR	0C0H		; Abbrev msg & return	LD	C,A		; Err code to C	LD	A,@ERROR	RST	28H	RET;;	Internal error message handling;ACTFLT	LD	HL,ACTFLT$	DB	0DDHNOTFLT	LD	HL,NOTFLT$	DB	0DDHDEVREQ	LD	HL,DEVREQ$	DB	0DDHCANT	LD	HL,CANT$	DB	0DDHSPCREQ	LD	HL,SPCREQ$;	LD	A,@LOGOT	RST	28H	LD	HL,-1	RETEXIT	LD	HL,0	LD	A,@CKBRKC	RST	28H	RET;;	Messages;SPCREQ$	DB	'File spec required',0DHDEVREQ$	DB	'Device spec required',0DHCANT$	DB	'No memory space available',0DHNOTFLT$	DB	'Device is not a filter',0DHACTFLT$	DB	'FILTER module is in use',0DH;SAVSPEC	DS	32DEVFCB	DS	32PGMFCB	DS	32;	END	SET