;LBAUTO/ASM - AUTO command	TITLE	<AUTO - LS-DOS 6.3>;;*GET	SVCMAC			; System SVC macros*GET	VALUES			; Misc equates;SECTOR	EQU	0<8+2OFFSET	EQU	20H		; Offset to Auto bufferRST28	EQU	28H		; SVC restart@CMNDR	EQU	25		; Execute & return@RDSEC	EQU	49		; Read a sector SVC@WRSEC	EQU	53		; Write a sector SVC;	ORG	2400H;AUTO	LD	(SAVESP+1),SP	; Save SP address	CALL	PARSE		; Do AUTO command	LD	HL,0		; Set no error;;	Reinstall SP and return;SAVESP	LD	SP,$-$		; Get old SP	RET;;	Skip any leading spaces;PARSE	DEC	HL		; Back onePARSE2	INC	HL		; Bump buff ptr	LD	A,(HL)		; Get char	CP	' '		; Space?	JR	Z,PARSE2	; Go until non space;;	Display auto buffer on drive :d?;	CP	'?'		; Display auto buffer?	JR	Z,DISAUTO;;	Execute AUTO buffer on drive :d?;	CP	'='		; Execute auto buffer?	JR	Z,EXAUTO;;	Install the command in the auto buffer;	CALL	GETDRV		; Get drive #	JR	WRBUF		; Write new auto and return;;	Display the command in auto buffer;DISAUTO	CALL	GETAUTO		; Get drive #	@@LOGOT			; Display it	JP	NZ,IOERR	; NZ - I/O error	RET			; Z  - done;;	Execute command in auto buffer;EXAUTO	CALL	GETAUTO		; Get drive #	@@FLAGS	LD	A,(HL)		; Get 1st char	CP	'*'		; Non-breakable AUTO?	JR	NZ,DOAUTO	; No, do it;;	Non-breakable AUTO - skip the '*';	INC	HL		; Bump to next character	SET	4,(IY+SFLAG$)	; Disable <BREAK>;;	Exit via CMNDI or CMNDR if requested;DOAUTO	BIT	1,(IY+CFLAG$)	; If CMNDR executing, then	LD	A,@CMNDR	;   exit via CMNDR	JP	NZ,RST28	DEC	A		; Else readjust to	RST	28H		;   CMNDI and exit;;	GETAUTO - Get auto command from boot sector;;	Advance to next byte in line;GETAUTO	INC	HL		; Bump to next char	LD	A,(HL)		; Get 1st char of drvspc	CALL	GETDRV		; Get drive #	CALL	RDBOOT		; Read boot sector	EX	DE,HL		; Point HL to auto buffer	RET			;   and return;;	GETDRV - Check if (HL) contains a legal drive #;GETDRV	CP	CR+1		; No drivespec?	RET	C		; Use drive 0 as default;;	Drivespec indicator entered?;	CP	':'		; Drivespec indicator?	RET	NZ		; No - use drive 0;;	Drivespec ':' entered, so get drive #;	INC	HL		; Position to drive #	LD	B,(HL)		; Get it into B;;	Position to command following drivespec;	INC	HL		; Position to command	LD	A,(HL)		; C/R following spec?	CP	CR+1	JR	C,SKIPINC	; Yes - don't INC	INC	HL;;	Is drive # in legal range?;SKIPINC	LD	A,B		; Get drive #	SUB	'0'		; Less than '0'?	LD	(DRIVE+1),A	; Stuff away drive #	CP	08H		; In 0-7 range?	RET	C		; Return if so	LD	A,32		; Illegal drive	JR	IOERR;;	WRBUFF - Write auto command to boot;WRBUF	CALL	RDBOOT		; Read in BOOT;;	Skip leading spaces;	DEC	HL		; Skip leading spacesSKPSPCS	INC	HL	LD	A,(HL)		; Get char	CP	' '		; Space?	JR	Z,SKPSPCS	; Yes - skip it;;	Transfer command into buffer;XFLP	LD	A,(HL)		; Get byte	LDI			; Move and increment	CP	CR+1		; End of line?	JR	NC,XFLP		; Loop if not;;	RDBOOT/WRBOOT - Read or write boot sector;;	Set A=@WRSEC supervisory call #;WRBOOT	LD	A,@WRSEC	; Write sector SVC	JR	BOOTIO		; Go to I/O routine;;	RDBOOT - Check if drive is there;RDBOOT	LD	A,(DRIVE+1)	; Get drive #	LD	C,A		; Xfer to C for @CKDRV	@@CKDRV			; Drive alive	LD	A,32		; Init illegal drive	JR	NZ,IOERR	; Abort if bad drive;;	Read GAT from directory if Model II;	IF	@MOD2	PUSH	IY		; Save	@@GTDCT			; Get the DCT	LD	D,(IY+9)	; Dir cyl	LD	A,(IY+3)	; Get DCT data	LD	E,(IY+4)	POP	IY		; Restore IY	AND	28H		; 8" floppy?	CP	20H		; Yes?	JR	NZ,SETSYS1	; Nope, sysinfo on 0	LD	A,E		; Get +4	AND	50H		; Bit 6/4	CP	40H		; DD not alien?	JR	NZ,SETSYS1	; Go if alien;	PUSH	HL		; Save HL	LD	HL,BUFF		; Pt to buffer	LD	E,0		; GAT table	@@RDSSC			; Read directory	LD	DE,(BUFF+0CDH)	; Get GAT info byte	POP	HL		; Restore buffer	JR	NZ,IOERR	; Go on disk error	BIT	7,E		; System disk?SETSYS1	LD	DE,SECTOR	; Sysinfo sector	JR	NZ,$+3		; Go if data disk	INC	D		; Sysinfo on cyl 1	LD	(SYSINFO),DE	; Save sysinfo sector	ENDIF	LD	A,@RDSEC;;	Pt HL => Buffer, DE = T/S, C = :d, A = SVC #;BOOTIO	PUSH	HL		; Save command ptr	LD	HL,BUFF		; Pt HL to I/O bufferDRIVE	LD	C,$-$		; Get drive # into C	LD	DE,SECTOR	; DE = Track 0, sector 2SYSINFO	EQU	$-2;;	Issue SVC & point DE to auto cmd buffer;	RST	28H		; Read or write sector	POP	HL		; Get command pointer	LD	DE,BUFF+OFFSET	; DE -> auto command buff	RET	Z		; Return if successful;;	I/O Error handler - clean up stack and abort;IOERR	LD	L,A		; Set HL = Error #	LD	H,0	OR	0C0H		; Short error message	LD	C,A		; Xfer to C for @ERROR	@@ERROR			; Display error	JP	SAVESP		; Exit;BUFF	EQU	$<-8+1<+8	; Next page boundary;	END	AUTO