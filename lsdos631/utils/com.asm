; ***************************************************************; * Filename: COM/ASM						*; * Revision: 06.03.01						*; * Rev Date: 08 Dec 97						*; ***************************************************************; * RS-232 Driver for LS-DOS					*; *								*; ***************************************************************;	TITLE	<COM/DVR - LS-DOS 6.3>;LF	EQU	10CR	EQU	13;*GET	COPYCOM			; Copyright message*GET	SVCMAC			; System SVC Macros;	ORG	2400H;BEGIN	@@CKBRKC	JR	Z,BEGINA	; Continue if no BREAK	LD	HL,-1	RET			; Return with abort code;BEGINA	PUSH	DE		; Save DCB address	POP	IX		;   in index reg	LD	(CLDCB),DE	;   and in driver header	LD	HL,HELLO$	; Welcome the user	@@DSPLY;;	Check if entry from SET command;	@@FLAGS			; IY => flag table base	BIT	3,(IY+'C'-'A')	; System request?	JP	Z,VIASET	; "Install with set...;;	Grab system dependent vectors;	PUSH	IY		; Set DE to flag base	POP	DE	LD	HL,'K'-'A'	; KFLAG$	ADD	HL,DE	LD	(KFLAG),HL	; Save keyboard flag location	LD	HL,'S'-'A'	; SFLAG$	ADD	HL,DE	LD	(SFLAG),HL	; Save system flag location	LD	HL,'W'-'A'	; WRINT$	ADD	HL,DE	LD	(WRINT),HL	; Save Int mask	LD	(INIT+1),HL	LD	HL,10-44	; INTVC$+10	ADD	HL,DE	LD	(INTVC),HL	; Save for receive int vector	LD	A,(IY+28)	; Get current opcode	LD	(LINK),A	; Save in driver	LD	L,(IY+29)	; Get curent address	LD	H,(IY+30)	LD	(LINK+1),HL	; Put in driver;;	Check if driver is already resident;	LD	DE,CL$		; Check if driver is	@@GTMOD			;   already resident	EX	DE,HL		; Put DCB in HL	JR	NZ,NOTRES;;	Make sure that the new DCB is same as the old;	LD	C,(HL)		; Get DCB pointer LSB	INC	HL	LD	B,(HL)		; Get DCB pointer MSB	LD	HL,6		; Get old DCB name &	ADD	HL,BC		;   stuff into error	LD	A,(HL)		;   message in case	INC	L		;   a different DCB	LD	H,(HL)		;   is referenced	LD	L,A	LD	(DCBNAM$),HL	; Stuff message with spec	LD	HL,(CLDCB)	; Get DCB existing DCB	OR	A		;   pointer	SBC	HL,BC		; Same pointer?	JP	NZ,DCBERR	; Can't install if different	JP	ISRES;;;NOTRES	LD	DE,'IK'	@@GTDCB			; Locate low memory ptr	JP	NZ,IOERR	; Go if not found	DEC	L	LD	D,(HL)		; Get pointer to the	DEC	L		;   start of free	LD	E,(HL)		;   low core	LD	(LCPTR+1),HL	; Save for later	LD	HL,CLEND-CLDVR-1	ADD	HL,DE		; Start + driver length	LD	(SVEND+1),HL	LD	BC,1300H	; Max addr + 1	XOR	A	SBC	HL,BC		; See if room low	JR	C,PUTLOW	;   and install there if so;;	Check if high memory is available;	BIT	0,(IY+'C'-'A')	; Memory frozen?	JP	NZ,NOROOM	; Can't install if so	LD	HL,0	LD	B,L		; Get HIGH$	@@HIGH$	LD	(SVEND+1),HL	; Top of driver	OR	A	LD	BC,CLEND-CLDVR	; Minus length	SBC	HL,BC	LD	B,00H	PUSH	HL	@@HIGH$			; Is new HIGH$	POP	HL	INC	HL		; Plus one is start	LD	(HCPTR),HL	; Save it	LD	HL,HCPTR	;   and point to it	LD	(LCPTR+1),HL	LD	A,0FFH		; Flag Himem used	LD	(HGHFLG),A;;	Relocate internal references in driver;PUTLOW	PUSH	IX		; Save the DCB	LD	IX,RELTAB	; Point to relocation tableSVEND	LD	HL,$-$		; Find distance to move	LD	(CLDVR+2),HL	; Set last byte used	LD	DE,CLEND-1	OR	A		; Clear carry	SBC	HL,DE	LD	B,H		; Move to BC	LD	C,L	LD	A,TABLEN	; Get table length;RLOOP	LD	L,(IX+00H)	; Get address to change	LD	H,(IX+01H)	LD	E,(HL)		; Get addres	INC	HL	LD	D,(HL)	EX	DE,HL		; Offset it	ADD	HL,BC	EX	DE,HL	LD	(HL),D		; Put it back	DEC	HL	LD	(HL),E	INC	IX	INC	IX	DEC	A	JR	NZ,RLOOP	; Loop until done	POP	IX		; Get the DCB back;;	Set up @ICNFG for boot up configuration;	LD	HL,INIT		; Get (relocated)RX01	EQU	$-2	LD	(IY+29),L	;   init address & put	LD	(IY+30),H	;   into system ICNFG area	LD	A,0C3H		; Get JP instruction	LD	(IY+28),A	; Turn on ICNFG;;	Move the driver into position;LCPTR	LD	HL,$-$		; Low core or himem pointer	LD	E,(HL)	INC	L	LD	D,(HL)	PUSH	DE		; Save start	LD	HL,CLDVR	LD	BC,CLEND-CLDVR	; Calc driver length	LDIR			; Move into place	LD	HL,(LCPTR+1)	; If driver went low,	LD	(HL),E		;   need to update new	INC	L		;   driver zone pointer	LD	(HL),D	LD	HL,LINKRX14	EQU	$-2	LD	E,(HL)		; Save what's there now	LD	(HL),0C9H	; Stuff a return	PUSH	HL		; Save address for later;;	Initialize the driver;	DI	LD	HL,RECVINTRX02	EQU	$-2	LD	($-$),HLINTVC	EQU	$-2	LD	HL,$-$WRINT	EQU	$-2	SET	5,(HL)	CALL	INITRX11	EQU	$-2	EI;	POP	HL		; Get Link back	LD	(HL),E		; Replace our RET inst;	POP	DE		; Pop filter start;ISRES	LD	HL,CLACT$	; Advise COM/DVR installed	LD	(IX+00H),07H	; Init DCB type to "C/P/G"	LD	(IX+01H),E	;   & stuff the driver	LD	(IX+02H),D	;   address	@@LOGOT	LD	A,$-$		; Did it use high memory?HGHFLG	EQU	$-1	OR	A		; NZ if high	JR	Z,NTHGH	LD	HL,HMEM$	; "Driver in himem...	@@LOGOTNTHGH	LD	HL,0		; Init no error code	RET			;   and return;;	Error exits;VIASET	LD	HL,VIASET$	; "Install with SET	DB	0DDHDCBERR	LD	HL,DCBERR$	; "Driver being used already	DB	0DDHNOROOM	LD	HL,NOROOM$	; "Memory frozen	@@LOGOT	LD	HL,-1		; Set abort code	@@CKBRKC		; Clear any BREAK	RET;;	I/O Error handler;IOERR	LD	L,A		; Error code to HL	LD	H,00H	OR	0C0H		; Short msg, return	LD	C,A	@@ERROR			; Show error	@@CKBRKC		; Clear any BREAK	RET;;	Messages and data tables;HCPTR	DW	0		; Save start if going to HIGH$CL$	DB	'$CL',03HHELLO$	DB	'RS-232 Driver'*GET	CLIENT;NOROOM$	DB	'No memory space available',0DHDCBERR$	DB	'Driver already attached to *'DCBNAM$	DB	'xx',0DHCLACT$	DB	'COM driver is now resident',0DHVIASET$	DB	'Must install via SET',0DHHMEM$	DB	0AH,'Note: driver installed in high memory',0DH;;@WRINT	EQU	0E0HWRINT$	EQU	80H;MASRES	EQU	0E8H		; RS-232 PortsMODSTAT	EQU	0E8HBAUDSET	EQU	0E9HUARTCTL	EQU	0EAHUARTST	EQU	0EAHDATAREG	EQU	0EBH;;	The actual driver;CLDVR	EQU	$	JR	CLBGN		; Branch around linkage	DW	CLEND		; Last byte used	DB	03H,'$CL'CLDCB	DW	$-$	DW	0CLDATA$	EQU	$MSMASK	EQU	$-CLDATA$CLDATA$	DB	0;;	UART Control Port image;;	Bit 7:	1 = Even parity, 0 = Odd parity;	Bit 6,5: Word length (00=5,10=6,01=7,11=8);	Bit 4:	1 = 2 stop bits, 0 = 1 stop bit;	Bit 3:	1 = disable parity, 0 = enable parity;	Bit 2:	1 = enable TX data, 0 = break;	Bit 1:	0 = Data Terminal Ready;	Bit 0:	0 = Request To Send;UCIMAGE	EQU	$-CLDATA$	DB	0A5H		; 10100101 = 7E1;BAUDRT	DB	55H		; Init 300 baud;LOGBRK	EQU	$-CLDATA$	DB	03H		; Default is Ctl-CCLFLG	EQU	$-CLDATA$	DB	00H		; Init no char in bufCLBUF	EQU	$-CLDATA$	DB	00H		; One-char buffer;;	CL initialization routine.  Set up DR interrupt;	vector and initialize the hardware;INIT	LD	A,($-$)		; Get WRINT	OUT	(@WRINT),A	CALL	CTL2RX03	EQU	$-2LINK	RET	DB	0,0;;	Initialize the UART and BRG;CTL2	LD	BC,(CLDATA$+UCIMAGE)	; Vals from DCBRX04	EQU	$-2	OUT	(MASRES),A	; Reprime UART	LD	A,C	OUT	(UARTCTL),A	LD	A,B	OUT	(BAUDSET),A	RET;CLBGN	LD	IX,CLDATA$	; Point to data areaRX05	EQU	$-2	JR	C,RECV		; Go if @GET	JR	Z,SEND		; Go if @PUT	LD	A,C		; Get @CTL byte	OR	A		; @CTL 00?	JR	Z,CANISND	; Go if so	DEC	A	JR	Z,CTL1		; Go if CTL 01	DEC	A	JR	Z,CTL2		; CTL 02 "init uart"	CP	4-2		; Wakeup feature?	JR	Z,CTL4		; Go if wakeup	XOR	A	RET;CTL4	PUSH	IY		; Xfer pointer to DE	POP	DE	LD	A,D		; Test if set or reset	OR	E	LD	A,0C9H		; Init disable reset	LD	HL,(WAKEADR+1)	; Get old valueRX06	EQU	$-2	JR	Z,SETWAK	; Jump if disable	LD	A,0C3H		; Make enableSETWAK	LD	(WAKEADR),A	; Load the opcodeRX07	EQU	$-2	LD	(WAKEADR+1),DE	; Then the addressRX08	EQU	$-2	PUSH	HL		; Transfer pointer to IY	POP	IY	RET;;	Check if ready to send;CANISND	IN	A,(UARTST)	; Look at TX empty bit	CPL			; Flip it	AND	40H		; Mask out all else	IN	A,(MODSTAT)	; Get modem status reg	RET	NZ		; Return if can't send	LD	B,A		; Save modem status	XOR	(IX+MSMASK)	; Mask for which to flip	RRA			; Move into bits 0-3	RRA	RRA	RRA	AND	(IX+MSMASK)	; Mask for which to check	AND	0FH		; Mask off garbage	LD	A,B		; Get reg back	RET			; Ret with Z or NZ;;	Send a character;SEND	LD	A,(IX+UCIMAGE)	; Get UART ctl reg	OUT	(UARTCTL),A	; Put it (clears BREAK)SWAIT	CALL	CANISND		; PollRX09	EQU	$-2	JR	NZ,SWAIT	;   until ready	LD	A,C		; Get byte to send	OUT	(DATAREG),A	; Send it with Z-flag	RET			;   unchanged for return;;	Receive character - get from buffer if available;RECV1	CALL	CKINP		; Chk if avail from portRX10	EQU	$-2	RET	NZ		; Back if noneRECV	SLA	(IX+CLFLG)	; Check if avail from buf	JR	NC,RECV1	; Go if none avail	LD	A,(IX+CLBUF)	; Get the char	CP	A		; Set Z flag & exit	RET;;	Break request;CTL1	LD	A,(IX+UCIMAGE)	; Pick up UART ctl image	RES	2,A		; Show BREAK bit	OUT	(UARTCTL),A	RET			; With Z-flag;;	Data received interrupt handler;RECVINT	LD	IX,CLDATA$	; Base of data areaRX13	EQU	$-2	CALL	CKINP		; See if available from portRX12	EQU	$-2	LD	A,BWAKEADR	RET			; Wakeup if enabled	DW	0		; Space for address;;	Routine to check on a received character;CKINP	IN	A,(UARTST)	; Check if actually RX	LD	B,A		; Save status	CPL			; Mask Data Received bit	AND	80H	LD	A,00H		; Set "No error"	RET	NZ		; Return if none;	IN	A,(DATAREG)	; Get character	LD	C,A		; Save it in C;;	Break, Pause and Enter handler routine;	LD	HL,$-$		; KFLAG$KFLAG	EQU	$-2	CP	CR		; ENTER char received?	JR	NZ,PAWSCK	; Go if not	SET	2,(HL)		; Set ENTER bit	JR	RECVEX;PAWSCK	CP	60H		; Pause char received?	JR	NZ,BRKCHK	; Go if not	SET	1,(HL)		; Set pause bit	JR	RECVEX;BRKCHK	LD	A,(IX+LOGBRK)	; Break char received?	OR	A		; Check if LOGBRK=0	JR	Z,RECVEX	; No valid break if =0	CP	C		; Check if a valid break	JR	Z,BRKRECD	; Go if so	IN	A,(UARTST)	; Check for framing error	AND	10H	JR	Z,RECVEX	; Quit if none;;	A break was received, check system's BREAK disable;BRKRECD	LD	A,($-$)		; Check if break keySFLAG	EQU	$-2	AND	10H		;   is disabled	LD	A,00H		; Ret NZ & A=0 if	RET	NZ		;   the BREAK is disabled	SET	0,(HL)		; Else set break bit	LD	C,80H		;   & reset BREAK codeRECVEX	LD	(IX+CLBUF),C	; Put char in 1 char buf	LD	(IX+CLFLG),80H	; Set char available	XOR	A		; Set Z flag	RETCLEND	EQU	$;;;RELTAB	DW	RX01,RX02,RX03,RX04	DW	RX05,RX06,RX07,RX08	DW	RX09,RX10,RX11,RX12	DW	RX13,RX14;TABLEN	EQU	$-RELTAB/2;	END	BEGIN