; ***************************************************************; * Filename: CLICK/ASM						*; * Revision: 06.03.01						*; * Rev Date: 20 Dec 97						*; ***************************************************************; * Sound click device filter					*; * The Click filter can be used to generate a short clicking	*; * sound on the occurrence of all characters sent to a device	*; * or on a specific character only.  Click will always install	*; * itself in high memory, and will not attempt to load in the	*; * low driver zone.  It is installed with the SET and FILTER	*; * library commands.						*; ***************************************************************	TITLE	<CLICK/FLT - LS-DOS 6.3>;	IF	@MOD4TONE	EQU	48HLEN	EQU	18HSNDPORT	EQU	90H	ENDIF	IF	@MOD2LEN	EQU	180HSNDPORT	EQU	0A0H	ENDIF;*GET	SVCMAC			; System SVC macros*GET	VALUES			; Misc equates*GET	COPYCOM			; Copyright message;	ORG	2400H;START	@@CKBRKC		; Check/clear BREAK	JR	Z,STARTA	LD	HL,-1		; Set up abort RET	RET;STARTA	LD	(EXIT+1),SP	; Save stack for error exit	CALL	DOINIT		; Do initialization	CALL	INSTFLT		; Relocate/install filterNORMEX	LD	HL,0		; Good exit	RET;;	Transfer DCB ptr to IX and stuff addrs in driver;DOINIT	PUSH	DE		; DE => DCB+0	POP	IX		; Transfer to IX	LD	(DCB),DE	;   and to header;;	Sign on;	PUSH	HL		; Save cmd line ptr	LD	HL,HELLO$	; Signon message	CALL	DSPLY;;	Check params and if entry from SET command;	LD	DE,PRMTBL	; Point to parameter tbl	POP	HL		; Get cmd line back	@@PARAM	JP	NZ,IOERR	; Exit on param error;	@@FLAGS			; IY => sys flags	BIT	3,(IY+CFLAG$)	; System request?	JP	Z,VIASET	; "Install with set;;	Before anything - make sure hi-mem is available;	BIT	0,(IY+CFLAG$)	; Hi memory available?	JP	NZ,CANT		; No - display error;;	Set up filter for CHAR if entered;CHARPRM	LD	DE,0		; Get CHAR param	LD	A,D		; Check if entered and	CP	E		;   is normal character	RET	Z		; Done if not entered	CP	00H		; Check is MSB is altered	LD	A,44		; Init "Param error	JP	NZ,IOERR	; Bad if so;	LD	D,E		; Set up CP nn	LD	E,0FEH		; Reverse it and	LD	(CKCHAR),DE	;  put it in the filter	RET;;*=*=*;	Actual CLICK filter code;*=*=*HEADER	JR	FILTEROLDHI	DW	0		; High$ before CLICK	DB	5,'CLICK'DCB	DW	$-$		; DCB pointing to CLICKSPARE	DW	0		; System wants it;;	Is there a character here?;FILTER	LD	IX,(DCB)	; Get DCB address	JR	C,NOTCTL	; Go if GET	JR	Z,NOTCTL	;   or PUTIS_CTL	@@CHNIO			; Pass the CTL call	RETNOTCTL	@@CHNIO			; Go to next in line	RET	NZ		; None - return NZ;;	Generate a short click;SOUND	PUSH	AF		; Save registersCKCHAR	DW	0		; Space for CP instruct	JR	NZ,POPAF	; Exit if CP above failsSNDNOW	PUSH	BC	PUSH	DE	IF	@MOD2	LD	BC,LEN		; Duration	LD	A,-1		; ON value	OUT	(SNDPORT),A	; Turn on sound	LD	A,16		; SVC @PAUSE	RST	28H		; Delay	XOR	A		; OFF value	OUT	(SNDPORT),A	; Turn off sound	ENDIF;	IF	@MOD4;STFVALS	LD	DE,TONE<8!LEN	; D=tone, E-length	LD	A,00H		; Init on/off toggle	LD	C,SNDPORT	; Point to port;;	On portion;DURLP	INC	A		; Hold output high	OUT	(C),A		;   for count of (B)	LD	B,D		; Play tone	DJNZ	$;;	Off portion;	DEC	A		; For count of B	OUT	(C),A	LD	B,D		; Hold output low	DJNZ	$		;   for duration of (B)	DEC	E		; Dec the duration	JR	NZ,DURLP	DJNZ	$		; Hold for 256 count	ENDIF;	POP	DE		; Restore regs	POP	BCPOPAF	POP	AF	RET			; and return;LENGTH	EQU	$-HEADER	; Length of filter;;	INSTFLT - Relocate and install filter;INSTFLT	LD	(IX+00H),47H	; Set Filter,Ctl,Get,Put;;	Pick up old HIGH$ and save in driver;	LD	HL,0		; Get HIGH$	LD	B,L	@@HIGH$	LD	(OLDHI),HL	; Stuff into header;;	Calculate new HIGH$ and stuff into DCB;	LD	BC,LENGTH	; Length of driver	PUSH	BC		; Save length	OR	A		; Clear carry	SBC	HL,BC		; HL => new HIGH$	@@HIGH$			; Set new HIGH$ (B=0)	INC	HL		; Point to driver	LD	(IX+01H),L	; Stuff driver address	LD	(IX+02H),H	;   into DCB;;	Calc offset between source and dest for relocate;	LD	DE,HEADER	; Start of driver	PUSH	HL		; Save src & dest ptrs	PUSH	DE	OR	A		; Clear carry	SBC	HL,DE		; Get offset;;	Relocate internal references in driver;	LD	IX,RELTBL	; Point to relocation table	LD	B,H		; Move to BC	LD	C,LRLOOP	LD	L,(IX+00H)	; Get address to change	LD	H,(IX+01H)	LD	A,H		; Test for zero entry	OR	L	JR	Z,RELDUN	; Go when done	LD	E,(HL)		; Get address	INC	HL	LD	D,(HL)		;   into DE	EX	DE,HL		; Offset it	ADD	HL,BC	EX	DE,HL		; Put it back	LD	(HL),D	DEC	HL	LD	(HL),E	INC	IX		; Bump table pointer	INC	IX	JR	RLOOP		; Loop until done;;	Relocation table for driver;RELTBL	DW	FILTER+2,0,0,0,0;;	Transfer filter code to high memory;RELDUN	POP	HL		; HL -> Source (driver start)	POP	DE		; DE -> Dest (old himem+1)	POP	BC		; BC -> Length of filter	LDIR			; Move the code	RET			; and return;;	DSPLY - Display a string;DSPLY	PUSH	DE		; Save DE	@@DSPLY			; Display it	POP	DE	RET	Z		; Return if no error;;	IOERR - Any fatal errors come here;IOERR	LD	L,A		; Xfer error # to HL	LD	H,00H	OR	0C0H		; Short msg, return	LD	C,A		; For SVC	@@ERROR	JR	EXIT		; Go to exit routine;;	Error handler;VIASET	LD	HL,VIASET$	; "Install with set	DB	0DDHCANT	LD	HL,CANT$	; "No memory...;	@@LOGOT			; Log error	LD	HL,-1		; Set abort codeEXIT	LD	SP,0		; Get old SP back	@@CKBRKC		; Clear out break	RET			;   and return;;	Parameter table;PRMTBL	DB	'CHAR  '	DW	CHARPRM+1	DB	'C     '	DW	CHARPRM+1	DB	00H;;	Messages;CANT$	DB	'No memory space available',0DHVIASET$	DB	'Must install via SET',0DHHELLO$	DB	'CLICK'*GET	CLIENT;	END	START