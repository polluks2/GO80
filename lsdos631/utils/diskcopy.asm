; ***************************************************************; * Filename: DISKCOPY/ASM					*; * Revision: 06.03.01						*; * Rev Date: 10 Jan 98						*; ***************************************************************; * Floppy diskette copying utility				*; * This file wasn't in "The Source", but it's part of version	*; * 6.3.1 now, so I disassembled/commented (pwc)		*; ***************************************************************;	TITLE	<DISKCOPY - LS-DOS 6.3>;ETX	EQU	3LF	EQU	10CR	EQU	13;*GET	SVCMAC			; System SVC macros;	ORG	2600H;DSTERR	LD	HL,DSTERR$	; Destination disk error	DB	0DDHSRCERR	LD	HL,SRCERR$	; Source disk error	PUSH	AF	@@LOGOT	POP	AFIOERR	OR	0C0H		; Short message, return	PUSH	AF		; Save error code	CALL	GETSYSD		; Make sure system disk is in	POP	AF		; Get it back again	LD	C,A		; Error code to C	LD	H,00H		;   and to HL	LD	L,A	@@ERROR			; Display the error message	LD	SP,(SAVESP+1)	; Get original SP back	JR	GETOUT		; Clear BREAK and exit;DOABRT	LD	HL,-1		; Init error code	JR	SAVESPDOEXIT	LD	HL,0		; Init no errorSAVESP	LD	SP,$-$		; Get original SP back	CALL	GETSYSD;GETOUT	@@CKBRKC		; Clear any BREAK key	RET			;   and exit;;	Internal error message handling;NOMEM	LD	HL,NOMEM$	; Not enough memory	DB	0DDHNOTJCL	LD	HL,NOTJCL$	; Not from JCL file	DB	0DDHNODRV	LD	HL,NODRV$	; No drive spec'd	DB	0DDHNOSNGL	LD	HL,NOSNGL$	; No single drive copy	DB	0DDHDRVDISA	LD	HL,DRVDIS$	; Drive disabled;	@@LOGOT			; Log the error message	LD	HL,-1		; Init error code	LD	SP,(SAVESP+1)	; Get original SP back	JR	GETOUT		;   and get out;ONLY5IN	LD	HL,ONLY5$	; Only for 5" drives	DB	0DDHNOTRDY	LD	HL,NOTRDY$	; Drive not ready	DB	0DDHWPROT	LD	HL,WPROT$	; Dest write protected	DB	0DDHDCABORT	LD	HL,ABORT$	; Diskcopy aborted	@@LOGOT	JR	DOABRT;;	Prompts and messages;HELLO$	DB	'DISKCOPY '*GET	CLIENT;NOMEM$	DB	'Not enough memory to Diskcopy',CRNOTJCL$	DB	'Diskcopy only valid at DOS level',CRNODRV$	DB	'Missing drive number(s)',CRNOSNGL$	DB	'Single drive Diskcopy invalid',CRDRVDIS$	DB	'Drive not enabled',CRABORT$	DB	LF,LF,'Diskcopy aborted',CRONLY5$	DB	'Diskcopy is for 5 inch, double density floppy disks only',CRNOTRDY$	DB	'Drive not ready',CRWPROT$	DB	'Destination drive is write protected',CRMOUNT$	DB	'Mount source and destination disks, press ENTER when ready ',CRDSTERR$	DB	LF,LF,'Destination disk error',CRSRCERR$	DB	LF,LF,'Source disk error',CRDCDONE$	DB	LF,LF,'Disk copy complete, copy another (Y/N) ? ',LF,CRPMTSYS$	DB	LF,'Mount SYSTEM disk, press ENTER when ready ',CR;;	Start here;BEGIN	@@CKBRKC		; Check for BREAK	JR	Z,BEGINA	; Continue if none	LD	HL,-1	RET;BEGINA	LD	(SAVESP+1),SP	; Save original stack for exit	PUSH	HL		; Save command line pointer	LD	HL,HELLO$	; Greet the user	@@DSPLY;	@@FLAGS			; Get system flags	LD	A,(IY+'C'-'A')	; Check if JCL active	BIT	1,A	JP	NZ,NOTJCL	; Abort if in JCL;	LD	HL,0		; Get current HIGH$	LD	B,L	@@HIGH$	LD	DE,7F00H	; Must have this much	OR	A		; Clear carry	SBC	HL,DE	POP	HL		; Get cmd line back	JP	C,NOMEM		; Jump if not enough memory	CALL	SKIPSPC		; Skip over cmd line spaces	CP	':'		; Drive separator found?	JP	NZ,NODRV	; Abort if not	LD	A,(HL)		; Get possible drive #	INC	HL		; Bump cmd line pointer	SUB	'0'		; Convert to binary	CP	08H		; Out of range?	JP	NC,NODRV	; Abort if it is	LD	(SRCDRV),A	; Save source drive	LD	C,A	@@GTDCT			; Get the drive's DCT	LD	A,(IY+00H)	; Is drive enabled?	CP	0C9H	JP	Z,DRVDISA	; Quit if it's not	CALL	SKIPSPC		; Skip more spaces in cmd line	CP	':'		; Second drive separator found?	JP	NZ,NODRV	; Abort if not	LD	A,(HL)		; Get possible dest drive	SUB	'0'		; Convert to binary	CP	08H		; Check range	JP	NC,NODRV	; Quit if out of range	CP	C		; Same as source?	JP	Z,NOSNGL	; Abort if source=dest;	LD	(DSTDRV),A	; Save destination drive	LD	C,A		; Get DCT of destination	@@GTDCT	LD	A,(IY+00H)	; Is destination enabled?	CP	0C9H	JP	Z,DRVDISA	; Abort if it's not;	CALL	GETSYS2		; Make sure SYS2 is loaded;DOCOPY	CALL	MOUNT		; Prompt for src and dest disks	LD	A,(SRCDRV)	; Get source drive's DCT	LD	C,A	@@GTDCT	LD	(SRCDCT),IY	; Save source DCT	LD	A,(IY+03H)	AND	01101000B	; Keep DDEN, 5/8", HDD bits	XOR	40H		; Toggle DDEN bit	JP	NZ,ONLY5IN	; Jump if not DDEN, 5" floppy	BIT	4,(IY+04H)	; Check if alien disk controller	NOP			; These must have been a JP NZ,xxxx	NOP	NOP	PUSH	IY		; Save the source DCT address	LD	A,(IY+09H)	; Get DIR cylinder	LD	D,A	LD	HL,SRCGAT	; I/O buffer	LD	E,L		; Sector 0	@@RDSSC			; Read GAT of source	JP	NZ,IOERR	; Abort on read error	LD	A,(DSTDRV)	; Get dest DCT	LD	C,A	@@GTDCT	LD	(DSTDCT),IY	; Save destination's DCT	LD	A,(IY+03H)	; Get DCT+3	AND	07H		; Keep step and delay bits	LD	B,A		; Move that to B	LD	A,(IY+04H)	; Get DCT+4	AND	0FH		; Keep drive select bits	LD	C,A		; Save those in C	PUSH	IY		; Move DCT to DE	POP	DE	INC	DE		; Point to dest DCT+3	INC	DE	INC	DE	POP	HL		; Get source DCT in HL	INC	HL		; Point to src DCT+3	INC	HL	INC	HL	PUSH	BC		; Save BC	PUSH	DE		; Save dest DCT+3	LD	BC,7		; Seven bytes to move	LDIR			; Copy src DCT info to dest	POP	DE		; Get dest DCT+3 back	POP	BC		; Get original DCT values back	LD	A,(DE)		; Get DCT+3	AND	78H		; Keep other bits	OR	B		; Merge with old DCT+3 bits	LD	(DE),A		; Save back in DCT	INC	DE		; Bump pointer to DCT+4	LD	A,(DE)		; Get DCT byte	AND	60H		; Keep just bits 5 and 6	OR	C		; Merge with old value	LD	(DE),A		; Save back in the DCT	INC	DE		; Bump pointer to DCT+5	XOR	A		; Clear out DCT+5	LD	(DE),A	LD	IY,(DSTDCT)	; Point IY to dest DCT	CALL	FMTTBL		; Set up format buffer	EXX	LD	HL,SRCGAT	; Point to GAT	LD	DE,SRCGAT+60H	; Point to lockout table	EXX	LD	A,(SECCYL)	; Get sectors/cylinder	LD	(RDSECS),A	; Save in code for	LD	(WRSECS),A	;   read/write/verify	LD	(VRSECS),A	LD	B,04H		; Get current cursor position	@@VDCTL	LD	(SVCRSR),HL	; Save the cursor loc'n;;	Loop to format destination track, read source track,;	write and verify destination track.;CPYLOOP	CALL	DOFORM		; Format the track	EXX			; Get alternate registers	LD	A,(DE)		; Get GAT lockout byte	LD	(GATLOCK),A	; Save for later	INC	DE		; Bump GAT pointer	CP	0FFH		; Is track locked out?	JR	NZ,NOTLOCK	; Go if it is not	INC	HL		;   else bump	EXX			; Normal registers back	JP	VERCYL		; Verify the cylinderNOTLOCK	CP	(HL)		; Is track empty?	INC	HL		; Bump pointer	EXX			; Normal registers back	JP	Z,VERCYL	; Just verify it if empty;;	Read the cylinder from the source disk;READCYL	LD	HL,READ$	; "Reading...	CALL	SHWPROG		; Show progress	LD	A,(SRCDRV)	; Source drive to C	LD	C,A	LD	D,(IY+05H)	; Curr track to D	LD	E,00H		; Start at sector 0	LD	B,00H		; Get sectors/cylRDSECS	EQU	$-1	LD	HL,IOBUFF	; HL => IO buffer area	LD	A,(IY+09H)	; Get DIR cylinder	CP	D		; Are we on it?	JR	Z,RSSCLP	; Go if soRSECLP	@@RDSEC			; Read sector from source	JP	NZ,SRCERR	; Abort on error	INC	H		; Bump buffer page	INC	E		; Bump sector number	DJNZ	RSECLP		; Loop for # of sectors	JR	WRITCYL		; Go write the cylinder;RSSCLP	@@RDSSC			; Read system sector	JP	NZ,SRCERR	; Abort on error	INC	H		; Bump buffer page	INC	E		; Bump sector number	DJNZ	RSSCLP		; Loop for # of sectors;;	Write data to destination disk;WRITCYL	LD	HL,WRIT$	; "Writing...	CALL	SHWPROG		; Show progress	LD	A,(DSTDRV)	; Set destination drive	LD	C,A		;   in C	LD	D,(IY+05H)	; Get current track	LD	E,00H		; Start on sector 0	LD	B,00H		; Get sectors/cylWRSECS	EQU	$-1	LD	HL,IOBUFF	; I/O buffer start	LD	A,(IY+09H)	; Get DIR track	CP	D		; Are we on it?	JR	Z,WRSSCLP	; Go if we areWRSECLP	@@WRSEC			; Write sector to destination	JP	NZ,DSTERR	; Abort on error	INC	H		; Bump buffer page	INC	E		; Bump sector number	DJNZ	WRSECLP		; Loop for # of sectors	JR	VERCYL		; Go to verify when done;WRSSCLP	@@WRSSC			; Write a system sector	JP	NZ,DSTERR	; Abort on error	INC	H		; Bump buffer page	INC	E		; Bump sector number	DJNZ	WRSSCLP		; Loop for number of sectors;;	Verify what was just written to destination;VERCYL	LD	HL,VERF$	; "Verifying...	CALL	SHWPROG		; Show progress	LD	A,(DSTDRV)	; Dest drive to C	LD	C,A	LD	D,(IY+05H)	; Curr track to D	LD	E,00H		; Start at sector 0	LD	B,00H		; Get sectors/cylVRSECS	EQU	$-1VRSECLP	@@VRSEC			; Verify sector	JR	Z,VRNEXT	; Go if okay	CP	06H		; System sector error?	JP	Z,VRNEXT	; That's okay, too	LD	E,A		; Save result in E	LD	A,(GATLOCK)	; Get GAT's lockout byte	CP	0FFH		; Is the track locked out?	LD	A,E	JR	Z,DONECYL	; Go if it is	JP	DSTERR		;  else destination errorVRNEXT	INC	E		; Bump sector number	DJNZ	VRSECLP		; Loop for # of sectors;;	Done with track.  Are we done with the disk?;DONECYL	LD	A,(IY+06H)	; Get highest cylinder	CP	(IY+05H)	; Are we there yet?	JR	Z,DONEDSK	; Go if we are;	RES	4,(IY+03H)	; Force side 0 of disk	CALL	STEPI		; Step disk in once	CALL	TSTBSY		; Test for drive busy	JP	NZ,IOERR	; Abort on error	LD	BC,0C8H		; Approx 3 msec pause	@@PAUSE	JP	CPYLOOP		; Loop back for more;DONEDSK	CALL	RSTOR	LD	HL,DCDONE$	; "Finished. Do another?"	@@DSPLYASKLOOP	@@KEY			; Get user response	CP	80H		; Break?	JP	Z,DOEXIT	; Exit if BREAK	OR	20H		; Force lower case response	CP	'y'		; Yes?	JP	Z,DOCOPY	; Go if yes	CP	'n'		; No?	JR	NZ,ASKLOOP	; Another key if not "n"	JP	DOEXIT		; Bye;;	Skip spaces in command line;SKIPSPC	LD	A,(HL)		; Get cmd line char	INC	HL		; Bump pointer	CP	0EH		; End of line?	JP	C,NODRV		; Jump if so	CP	' '		; Space?	JR	Z,SKIPSPC	; Loop if it is	RET			;   else return;;;MOUNT	LD	HL,MOUNT$	; "Mount source & destination	@@DSPLYMOUNT1	@@KEY			; Get one key from the user	CP	80H		; <BREAK> pressed?	JP	Z,DCABORT	; Abort if so	CP	CR		; Was it <ENTER>?	JR	NZ,MOUNT1	; Loop back until it is;	LD	A,00H		; Get source driveSRCDRV	EQU	$-1	LD	C,A		; Check if drive available	@@CKDRV	JR	NZ,MOUNT	; Loop back if not	LD	A,00HDSTDRV	EQU	$-1	LD	C,A	LD	(IODRIVE),A	; Set drive in I/O routine	@@GTDCT	LD	A,(IY+00H)	; Is drive enabled?	CP	0C9H	JP	Z,NOTRDY	; Jump if it's not	BIT	3,(IY+03H)	; 5 inch drive?	JP	NZ,ONLY5IN	; Abort if not	BIT	4,(IY+04H)	; Alien controller?	JP	NZ,ONLY5IN	; Abort if it is	CALL	RSTOR		; Restore to track 0	JP	NZ,IOERR	; Abort on error	CALL	TSTBSY		; Check if drive is busy	JP	NZ,IOERR	; Abort if it is	BIT	7,A		; NOT READY bit set?	JP	NZ,NOTRDY	; Abort if it is	BIT	2,A		; Track 0 bit set?	JP	Z,NOTRDY	; Abort if it's not	CALL	INDEX		; Mini ckdrv routine	JR	NZ,MOUNT	; Loop until disks mounted	RLCA			; Rotate WP to bit 7	OR	(IY+03H)	; Merge soft WP bit	AND	80H		; Are either set?	JP	NZ,WPROT	; Abort if write protected	LD	C,CR		; Start on a new line	@@DSP	RET;;	Make sure a system disk is in drive :0;GETSYSD	PUSH	HL		; Save HL	JR	GTSYSD2		; Bypass prompt this time;GTSYSD0	LD	HL,PMTSYS$	; "Insert SYSTEM disk...	@@DSPLY			; Display messageGTSYSD1	@@KEY			; Get key from user	CP	CR		; Enter?	JR	NZ,GTSYSD1	; Loop until it is;GTSYSD2	LD	HL,TMPBUF	; Temporary buffer	LD	DE,0		; Track 0, sector 0	LD	C,D		; Drive 0	@@CKDRV	JR	NZ,GTSYSD0	; Loop back until there	@@RDSEC			; Read BOOT sector	JR	NZ,GTSYSD0	; Loop back on error	LD	A,(TMPBUF+2)	; Get DIR track from 	LD	D,A	@@RDSSC			; Attempt to read	JR	NZ,GTSYSD0	; Loop back on error	LD	A,(TMPBUF+0CDH)	; Get GAT config byte	AND	80H		; System disk?	JR	NZ,GTSYSD0	; Loop back if it's not	LD	C,CR		; Start a new line	@@DSP	POP	HL		; Recover HL	RET			;   and return;;	Disk I/O routines;DCSTAT	XOR	A		; Test if drive is assigned	JR	GODOIO;SELECT	LD	A,01H		; Select drive	JR	GODOIO;RSTOR	LD	A,04H		; FDC Restore command	JR	GODOIO;STEPI	LD	A,05H		; FDC Step In command	JR	GODOIO;TSTBSY	LD	A,07H		; Test if drive is busy	JR	GODOIO;WRTRK	LD	A,0FH		; Write track	JR	GODOIO;HDFMT	LD	A,0CH		; HD Format	JR	GODOIO;WRSEC	LD	A,0DH		; Write a sector	JR	GODOIO;WRSYS	LD	A,0EH		; Write system sector	JR	GODOIO;RDSEC	LD	A,09H		; Read a sector	JR	GODOIO;VRSEC	LD	A,0AH		; Verify a sector;GODOIO	PUSH	BC;	LD	C,0FFH		; Get drive numberIODRIVE	EQU	$-1	ADD	A,40		; Convert command to SVC #	RST	28H		; Issue system request	POP	BC		; Get BC back	RET;;	Mini test to see if a disk is in the drive;INDEX	LD	HL,TMPBUF	; Temp buffer	@@TIME			; Get system time setting	EX	DE,HL		; HL => TIME$ location	DEC	HL		; Point to RTC counter	LD	A,(HL)		; Get current value	ADD	A,0FH		; Add 15 to it (1/2 second)	LD	D,A		; Set timeout value in DINDEX0	CALL	INDEX3		; Look for no index pulse	JR	NZ,INDEX0	; Loop until foundINDEX1	CALL	INDEX3		; Look for index pulse	JR	Z,INDEX1	; Loop until foundINDEX2	CALL	INDEX3		; Look for no index pulse	JR	NZ,INDEX2	; Loop until found	RET			; Return with Z status;INDEX3	EI			; Enable interrupts	LD	A,(HL)		; Get RTC counter value	SUB	D		; At timeout point yet?	JR	Z,INDEX4	; Go if we timed out	CALL	TSTBSY		; Get FDC status	BIT	1,A		; Index pulse seen?	RET			; Return status;INDEX4	POP	DE		; Pop return address	OR	01H		; Set NZ status	RET			;   and return;;	Load SYS2 overlay;GETSYS2	LD	A,84H		; Returns to caller	RST	28H;;	Set up formatting information;FMTTBL	LD	DE,D5TBL	; Point to format table	LD	A,(DE)		; Get # of sectors to format	INC	DE		; Bump pointer	LD	(SECTRK),A	; Save sectors/track	LD	B,A		; Save in B also	BIT	5,(IY+04H)	; Need twice as many if	JR	Z,$+3		;   double sided drive	RLCA	LD	(SECCYL),A	;	LD	A,(DE)		; Get track skew	INC	DE	LD	(TRKSKEW+1),A	; Save in code	LD	(SECSKEW+1),DE	; Format sector skew;;	Index past sector info;	INC	A		; Add DE -> begin of sec #	ADD	A,B		; B -> # of sectors/side	ADD	A,E		; A+1 -> a code byte	LD	E,A	ADC	A,D	SUB	E	LD	D,A	LD	HL,TMPBUF	; Buffer for format data	LD	BC,IDTBL	; Temp ptrs to trk/sec info;;	Create formatting data without track/sector info;FMTDAT	LD	A,(DE)		; Get table format byte	INC	DE		; Bump table pointer	CP	0F1H		; Start of cylinder?	JR	Z,CODF1	CP	0F2H		; Start of track trailer?	JR	Z,CODF2	CP	0F3H		; Start of track ID info?	JR	Z,CODF3	CP	0F4H		; End of table params?	JR	Z,CODF4	CP	0F5H		; Start of data?	PUSH	BC	JR	NZ,CODE1	; Go if not;;	Write 2 byte data pattern to format buffer;	LD	A,(DE)		; Get length to write	INC	DE		; Bump to 1st data byte	LD	B,A		; Xfer length to B	LD	A,(DE)		; Get a data byte	INC	DE		; Bump again for 2nd byte	LD	C,A		; Xfer 1st byte	LD	A,(DE)		; Get second byteCODF5	LD	(HL),C		; Stuff data into buffer	INC	HL	LD	(HL),A	INC	HL	DJNZ	CODF5		; Loop for byte count	JR	CODRET;;	Xfer bytes to the format buffer area;	A  => Count to move;	DE => Data byte to duplicate;CODE1	LD	B,A		; Count to B	LD	A,(DE)		; Get data byte to moveCODE1A	LD	(HL),A		; Fill buffer with byte	INC	HL	DJNZ	CODE1A		; Loop until doneCODRET	POP	BC	INC	DE		; Bump table pointer	JR	FMTDAT		; Go back for more;;	Save the current table position and the number of;	sectors per cylinder on the stack;CODF1	LD	A,(SECTRK)	; Get # of sectors/sideCODF1A	PUSH	DE		; Save table pointer	PUSH	AF		; Save value	JR	FMTDAT;;	Done with a sector.  Are there more on this cylinder?;CODF2	POP	AF		; Count down the # of sectors	DEC	A		;   to format	JR	Z,CODF2A	; Go if last one done	POP	DE		; Recover table pointer	JR	CODF1A		; Loop for more;CODF2A	POP	AF		; Clean the stack	JR	FMTDAT		;   and finish off the cylinder;;	Build a table of the location in the format buffer of;	the track and sector ID bytes, to be filled in during;	the actual formatting.;CODF3	LD	A,L		; Stuff pointer to where	LD	(BC),A		;   track & sector info	INC	BC		;   is to be placed	LD	A,H	LD	(BC),A	INC	BC	JR	FMTDAT;;	Finished building format cyl info.  Terminate the ID table;	with an extra 256 bytes in case of overrun.;CODF4	XOR	A		; Stuff two 00s to indicate	LD	(BC),A		;   the end of the ID position	INC	BC		;   table	LD	(BC),A	LD	B,00H		; Stuff 256 FFs into the	LD	A,0FFH		;   format buffer	LD	(HL),A	INC	HL	DJNZ	$-2	RET;;	Begin the formatting;DOFORM	LD	HL,FMAT$	; "Formatting	CALL	SHWPROG		; Show progressSECSKEW	LD	BC,0		; Begin of sector tableBFMT1	LD	HL,IDTBL	; Ptr to ID position tableBFMT2	@@CKBRKC		; Check for <BREAK> pressed	JP	NZ,DCABORT	; Abort if so;	LD	E,(HL)		; Get positions having sector	INC	HL		;   and cylinder info to be	LD	D,(HL)		;   stuffed into format data	INC	HL	LD	A,D		; Finished?	OR	E	JR	Z,BFMT4	LD	A,(IY+05H)	; Get cylinder # and stuff	LD	(DE),A		;   into format data	INC	DE	LD	A,(IY+03H)	; Get the side select bit	AND	10H	RRCA	RRCA	RRCA	RRCA	LD	(DE),A		; Save in format data	INC	DE	LD	A,(BC)		; Get the sector number	OR	A	JP	P,BFMT3		; Go if good number	ADD	A,C		;   else off the end,	LD	C,A		;   calculate the beginning	JR	C,BFMT3		;   of the sector table	DEC	BBFMT3	LD	A,(BC)		; Get next sector #	LD	(DE),A		; Stuff in format data	INC	DE	INC	BC	JR	BFMT2		; Loop until cylinder done;BFMT4	LD	(SECSKEW+1),BC	; Save end of sector table	LD	D,(IY+05H)	; Get current cylinder	LD	HL,TMPBUF	; Point to format data	CALL	SELECT		; Drive select	JP	NZ,IOERR	; Go on error	CALL	WRTRK		; Cylinder write	JP	NZ,IOERR	BIT	5,(IY+04H)	; Double sided?	JR	Z,BFMT5		; Go if not	BIT	4,(IY+03H)	; Flip bit for 2nd side	JR	NZ,BFMT5	;   if not already on it,	SET	4,(IY+03H)	;   else go to next	INC	BC		; Bump to start side 2	JR	BFMT1		;   at different sector #BFMT5	RES	4,(IY+03H)	; Turn off side 2TRKSKEW	LD	A,00H		; Get the track skew byte	ADD	A,C		; Repoint to the beginning	LD	C,A		;   of the sector table	ADC	A,B		; Skew start of next track	SUB	C	LD	B,A	LD	(SECSKEW+1),BC	RET;;SECCYL	DS	1SECTRK	DS	1;;	5" DDEN format table;D5TBL	DB	18,10	DB	0,9,1,10,2,11,3,12,4,13,5,14,6,15,7,16,8,17	DC	11,-18	DB	32,4EH	DB	0F1H,12,0,3,0F5H,1,0FEH	DB	0F3H,3,0,1,1,1,0F7H,22,4EH,12,0,3,0F5H	DB	1,0FBH,0F5H,128,6DH,0B6H	DB	1,0F7H,1,4EH,23,4EH	DB	0F2H,182,4EH,0F4H	DB	0,1,2,3,4,5,6,7,8	DB	9,10,11,12,13,14,15,16,17;;	Convert number in A to ASCII in BC (B=low digit);ATOASC	LD	C,'0'		; Init C to '0'ATOASC1	SUB	0AH		; Subtract 10 from number	JR	C,ATOASC2	; Jump if we passed 0	INC	C		; Bump tens digit	JR	ATOASC1		; Loop until carryATOASC2	ADD	A,'0'+10	; Convert remainder to ASCII	LD	B,A		; Save it in B	RET			;   and return;;	Show string followed by current cylinder;SHWPROG	PUSH	HL		; Save string address	LD	HL,0		; Get cursor positionSVCRSR	EQU	$-2	LD	B,03H		; Set cursor function	@@VDCTL	POP	HL		; Get string addr back	@@DSPLY			; Display it	LD	A,(IY+05H)	; Get current cylinder	CALL	ATOASC		; Convert to ASCII in BC	@@DSP			; Display char in C	LD	C,B		; Get ones digit in C	@@DSP			; Display that one, too	RET			;   and return;;	Data area;SRCDCT	DW	00H		; Source DCT addressDSTDCT	DW	00H		; Destination DCT addressGATLOCK	DB	00H		; Lockout byte for curr cylFMAT$	DB	'Formatting  ',ETXREAD$	DB	'Reading     ',ETXWRIT$	DB	'Writing     ',ETXVERF$	DB	'Verifying   ',ETX;	ORG	$<-8+1<+8;IDTBL	DS	256		; Track/Sector ID tableSRCGAT	DS	256		; Source disk GAT bufferIOBUFF	DS	36*256		; 18 sec/trk * 2 sides * 256 bytesTMPBUF	EQU	$		; Start of unused space;	END	BEGIN