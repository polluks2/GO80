;****************************************************************;* Filename: SYSINIT4/ASM					*;* Rev Date: 30 Nov 97						*;* Revision: 6.3.1						*;****************************************************************;* Initialization part of SYSRES				*;*								*;****************************************************************;;	Miscellaneous equates for initialization.;TRKREG	EQU	0F1H		;FDC track registerKB1	EQU	0F401H		;Keyboard row 1KB67	EQU	0F460H		;Keyboard rows 6 & 7KB7	EQU	0F440H		;Keyboard row 7BOL	EQU	01DH		;Beginning of line;;; 	Cursor positions for various things in SYSINIT4;	IF	@PCERV;DATEROW EQU	5		; Row location of DATEDATECOL EQU	0		; Col location of DATETIMEROW EQU	6		; Same for TIMETIMECOL EQU	0SYSGROW EQU	8DINIROW EQU	8PACKROW EQU	2PACKCOL EQU	0VERROW	EQU	2VERCOL	EQU	64;	ELSE;;	Use old positions for all that stuff;DATEROW EQU	21		; Row location of DATEDATECOL EQU	27		; Col location of DATETIMEROW EQU	22		; Same for TIMETIMECOL EQU	27SYSGROW EQU	21		; Row for "*SYSGEN*"DINIROW EQU	21PACKROW EQU	2		; Where pack name shows upPACKCOL EQU	30		; Was 20 under 6.3.0VERROW	EQU	2		; Dos version locationVERCOL	EQU	40		; Would be 30 under 6.3.0;	ENDIF;	ORG	1E00H+START$;	DI	LD	HL,@RSTNMI	; Reset NMI vector to	LD	(@NMI+1),HL	;   SYSRES's needs;	IF	@PCERV;;	Changes for Pete Cervasio's logo stuff - keep the code the same;	as much as possible, even though a simpler bit of code would;	work just as well...;	LD	HL,PAKNAM$+14	;Point to O/S revision info	LD	DE,VERROW*80+VERCOL+CRTBGN$	LD	BC,2		; 2 chars to move	LDIR			; Display the info...	LD	C,8	INC	DE	INC	DE	DW	0		; Take the space of the LDIR;	ELSE;	LD	HL,PAKNAM$	; Point to disk pack name	LD	DE,PACKROW*80+PACKCOL+CRTBGN$	LD	BC,8	LDIR			; Move pack name to screen	LD	C,8		; B already holds a 0	INC	DE		; Leave two spaces	INC	DE	LDIR			; Move pack date to crt;	ENDIF;;---> 6.3.1 changes from version 6.2.0 in "The Source";	INC	DE	INC	DE		; Leave two more spaces	LD	C,18		; 18 characters	LD	HL,M2185	; Point to message areaM1E1F	NOP			; 6.3.0 LDIR to put the	NOP			;  serial # up on screen;;<--- end of 6.3.1 changes;;	Initialization routines;	XOR	A		;Clear out stack area	LD	HL,STACK$+1	;Start STACK+1CLRLOOP DEC	L		;Move down a byte	LD	(HL),A		;Now loop and fill	JR	NZ,CLRLOOP	;  with zero bytes;	IM	1		;Set the interrupt mode	LD	SP,STACK$	;Set the stack area	XOR	A	LD	(LBANK$),A	;Set logical bank #	OUT	(0E4H),A	;Disable INTRQ & DRQ;	LD	HL,S1DCB$ZERDCB	LD	(HL),A		;Zero spare DCB area	INC	L	JR	NZ,ZERDCB;	LD	A,(MODOUT$)	;Set high speed	OUT	(0ECH),A	;  and external BUS	LD	A,(WRINT$)	OUT	(0E0H),A	;Enable RTC interrupts	LD	A,(OPREG$)	;Set memory configuration	LD	B,A	LD	A,0A7H		;Value for AUX/RAM	LD	C,@OPREG	;Set memory mgt port	OUT	(C),B		;Bring up regular RAM	LD	HL,-1		;Check for extended RAM	LD	(HIGH$),HL	LD	(PHIGH$),HL;;	Check the banks;	LD	D,(HL)		;Save what's in RAM	LD	(HL),55H	;Stuff in regular RAM	OUT	(C),A		;Switch in alt RAM	LD	E,(HL)		;Save the byte there, too	LD	(HL),A		;Stuff alt RAM	OUT	(C),B		;Back to reg RAM	CP	(HL)		;What's there now?	LD	(HL),D		;Put reg RAM byte back	OUT	(C),A		;Back to alt RAM	LD	(HL),E		;Restore original byte	OUT	(C),B		;Back to reg RAM	LD	A,0FEH		;Init BAR$ for bank 0	JR	Z,MZMZ01	;Bypass if only 64k	LD	A,0F8H		;Init BAR$ for bank 0-2MZMZ01	LD	(BAR$),A	;Load bank available ram	LD	(BUR$),A	;Load bank used ram	LD	A,(FEMSK$)	;Get port FEh mask	OUT	(0FEH),A	; and set it	DC	3,0		;Space for a jump or call;;	Update DCT$ info for SYSTEM drive;	LD	A,(BOOTST$)	;Get boot step rate	AND	3		;Strip all but it	LD	B,A		;Save temporarily	LD	HL,DCT$+3	;Point to DCT step	LD	A,(HL)		;Get DCT step	AND	0FCH		;Strip step rate	OR	B		;Merge boot step	LD	(HL),A		;Update DCT	IN	A,(TRKREG)	;Update DCT with current	LD	(DCT$+5),A	;  track position of head;	LD	DE,KIDCB$	;Flush type ahead, init ptrs	LD	A,3	CALL	@CTL	EI			;Interrupts on;;	Get CONFIG status & set ZERO byte;	LD	HL,ZERO$	LD	A,(HL)		;Set to NOP if SYSGENed	LD	(HL),0		;Make always zero byte	PUSH	AF		;Save SYSGEN flag;;	Check if date prompt is to be suppressed;	LD	A,(DTPMT$)	;No prompt for DATE?	OR	A;;	Check on currency of date;	LD	HL,DATE$	;Point to year	LD	C,(HL)		;Save in reg C	LD	(HL),0		;  while resetting to zero	INC	HL		;Bump to day	LD	B,(HL)		;  and save in reg B	LD	(HL),0		;  while resetting to zero	INC	HL		;Bump to month	LD	A,(HL)		;Save month to A	LD	(HL),0		;  while resetting to zero	JP	NZ,TIMIN	;Check time if DATE=OFF	LD	L,CFGFCB$+31&0FFH ; Reset pointer;	IF	@INTL	LD	(HL),B		;Stuff day	DEC	HL	LD	(HL),A		;Stuff month	ELSE	LD	(HL),A		;Stuff month	DEC	HL	LD	(HL),B		;Stuff day	ENDIF;	DEC	HL	LD	(HL),C		;Stuff year	EX	DE,HL		;Point DE to CFGFCB$+29	DEC	A		;Check for month range <1-12>	CP	12		;Okay if 0-11 now	JR	C,DATIN1;DATIN	LD	HL,DATEROW<8!DATECOL	;Set video row, col	LD	DE,DATEPR	;DATE? question	LD	BC,8<+8!'0'	;Set buff len & char	CALL	GETPARM		;Get response	JR	NC,DATIN	;Jump on format errorDATIN1	LD	A,(DE)		;Is year a leap year?;--> 6.3.1 changes start	IFLT	@DOSLVL,'L'	;---> Before changes for 6.3.1L	CP	0CH		;Past 1912?	ELSE			;<-->	CP	50H		;Past 1980?	ENDIF			;<---	JR	NC,DATIN2	ADD	A,100		;Change to 20xx if not	LD	(DE),A;<-- 6.3.1 changes doneDATIN2	LD	C,A		;Save year for later	SUB	80		;Reduce for range test	IFLT	@DOSLVL,'L'	;---> Before changes for 6.3.1L	CP	20H		; Check year range (6.2 was 8) (up to 2011)	ELSE			;<-->	CP	64H		; Check year range (up to 2079)	ENDIF			;<---	JR	NC,DATIN	AND	3	LD	A,28		;Init February	JR	NZ,NOTLEAP	LD	HL,DATE$+3+1	;Set leap flag	SET	7,(HL)	INC	A		;Feb to 29 daysNOTLEAP LD	HL,MAXDAY$+2	;Set Feb max day #	LD	(HL),A;	IF	@INTL	NOP			;Keep same length	ELSE	INC	DE		;Bump to day	ENDIF	INC	DE		;Bump to month & get it	LD	A,(DE)	LD	B,A		;Save	DEC	A	CP	12		;Range check	JR	NC,DATIN	;Go if error	DEC	HL		;Point to Jan entry	ADD	A,L		;Index the month	LD	L,A;	IF	@INTL	INC	DE		;Point to day	ELSE	DEC	DE		;Point to day	ENDIF;	LD	A,(DE)		;Get day entry	DEC	A		;Reduce for test (0->FF)	CP	(HL)	JR	NC,DATIN	;Go if too large (or 0);;	Range checks okay - move into DATE$;	LD	HL,DATE$+2	INC	A		;Compensate for DEC A	LD	(HL),B		;Stuff month	DEC	L	LD	(HL),A		;Stuff day	DEC	L	LD	(HL),C		;Stuff year;;	Date is in DATE$ - display it;	LD	A,C		;Get year	PUSH	AF		;  and save it	AND	3		;Check on leap year	LD	HL,MAXDAY$+2	;Init & adj Feb as	LD	(HL),28		;  required	JR	NZ,$+3	INC	(HL)		;Bump to 29	LD	A,(DATE$+2)	;Get month and xfer	LD	B,A		;  it to B	LD	A,(DATE$+1)	;Get day of month;;	Compute day of year and day of week;	LD	L,A		;Start off with days	LD	H,0		;  in this month	LD	DE,MAXDAY$DAYLP	LD	A,(DE)	ADD	A,L		;8 bit add to 16 bit	LD	L,A	ADC	A,H		;Add high order & carry	SUB	L		;Subtract off low order	LD	H,A		;Update high order	INC	DE	DJNZ	DAYLP	EX	DE,HL		;Move day of year to DE	LD	HL,DATE$+3	;Store it	LD	(HL),E	INC	HL	LD	A,D		;Get bit "8"	OR	(HL)		;  and OR it in	LD	(HL),A		;Then put it back	EX	DE,HL		;Get DOY back in HL	POP	AF		;Pop the year and mask	SUB	80		;Compute DOW offset (6.2 was AND 7)	LD	E,A	ADD	A,3	RRCA	RRCA	IFLT	@DOSLVL,'L'	;---> Before changes for 6.3.1L	AND	0FH		; 6.3.1 change - 6.2 was 03H	ELSE			;<-->	AND	3FH		; 6.3.1L change	ENDIF			;<---	ADD	A,E	LD	E,A		;And add it in	LD	D,0		;Add into HL	ADD	HL,DE	INC	HL		;Start in right place;--> 6.3.1 changes	LD	A,7	CALL	@DIV16		;Divide by 7	INC	A;<-- 6.3.1 changes	LD	B,A		;Save in reg B	RLCA			;Shift to bits 1-3	LD	C,A		;Save temporarily	LD	HL,DATE$+3+1	LD	A,(HL)		;Pack into field	AND	0F1H	OR	C	LD	(HL),A	PUSH	BC	LD	HL,DATEROW<8!DATECOL	;Video row/col	LD	B,3		;Position cursor	CALL	@VDCTL	POP	BC	LD	HL,DAYTBL$	CALL	DSPMDY		;Write out the DAY	LD	A,','	CALL	@DSP	LD	A,' '	CALL	@DSP	LD	A,(DATE$+2)	;Get month number	LD	B,A	LD	L,MONTBL$&0FFH	;Set HL to month table;;	Another custom mod - month displayed slightly differently;	when @PCERV is enabled.;	IF	@PCERV	CALL	DSPMDY		;Add in the spaces if @PCERV	ELSE	CALL	DSPMON		;Write out the month name	ENDIF;	LD	A,' '		;Space after the name	CALL	@DSP	LD	A,(DATE$+1)	;Get day	DEC	B		;From 0 to X'FF'DIV10	INC	B		;Divide by 10	SUB	10		;  with quotient in B	JR	NC,DIV10	PUSH	AF		;Save remainder (-10)	LD	A,B		;Get quotient	ADD	A,'0'		;Change to ASCII	CP	'0'		;Zero?	CALL	NZ,@DSP		;Display if not	POP	AF		;Get back remainder	ADD	A,'0'+10	;Change to ASCII	CALL	@DSP		;Display it;--> 6.3.1 changes	LD	A,(DATE$)	;Get year digits (97?)	LD	HL,1900		;Init to 1900	ADD	A,L		;Add in base year low	LD	L,A		;Save back in L	ADC	A,H		;Add in high byte of year	SUB	L		;Drop extra	LD	H,A		;And put in H	LD	DE,PARTYR+1	;Buffer area	CALL	@HEXDEC		;Convert to decimal	LD	HL,PARTYR	;Point to buffer	CALL	@DSPLY		;And display it.;<-- 6.3.1 changes;;	Prompt for time;TIMIN	LD	A,(TMPMT$)	;Prompt for time?	OR	A	JR	NZ,M1FEA	;Skip if not;--> 6.3.1 changesTIMIN0	LD	B,3		;3 bytes to change	LD	HL,00FFH	;Top of first RAM pageM1FB8	LD	(HL),0		;Clear those bytes out	DEC	HL	DJNZ	M1FB8	LD	A,0FFH		;Set byte in code for	LD	(M20EE+1),A	;  comparison;<-- 6.3.1 changes	LD	HL,TIMEROW<8!TIMECOL ;Row/col set	LD	DE,TIMEPR	;Prompt message	LD	BC,8<+8!'0'	;Len and separ char	CALL	GETPARM	JR	NC,TIMIN0	;Loop on format error	LD	HL,CFGFCB$+31	LD	A,23		;Max hour value	CP	(HL)		;Test hour range	JR	C,TIMIN0	DEC	HL	LD	A,59		;Max minute value	CP	(HL)		;Test minutes	JR	C,TIMIN0	DEC	HL	CP	(HL)		;Test seconds	JR	C,TIMIN0	LD	DE,TIME$	;Move time value	LD	BC,3		;  into the TIME$ field	LDIR;--> 6.3.1 changesM1FEA	LD	B,80H		;Add a short pause	CALL	@PAUSE;<-- 6.3.1 changes;;	Check on any auto command;SELDCT	LD	HL,INBUF$	LD	A,(HL)		;Get 1st byte of AUTO	CP	'*'		;Unbreakable AUTO command?	JR	NZ,CKDCR	INC	HL	LD	A,0E6H		;Set break bit in flag by	LD	(STUB1+1),A	;  changing RES 4,(SFLAG$)				;  to SET 4,(SFLAG$)	JR	AUTO?GETKB17 CALL	ENADIS_DO_RAM	LD	A,(KB1!KB7)	;Scan rows 1 and 7	RETCKDCR	CALL	GETKB17		;Strobe keyboard	BIT	4,A		;Is 'D' pressed	PUSH	HL		;Save auto command pointer	LD	HL,@ABORT	;Get abort address	EX	(SP),HL		;Swap them around	JP	NZ,@DEBUG	;DEBUG on <D>	POP	DE		;Stack integrity	CPL	AND	1		;No auto if <ENTER>	JR	Z,NOAUT1AUTO?	LD	A,(HL)		;Any auto command?	CP	CR		;None if equalNOAUT1	POP	DE		;Get back SYSGEN flag	LD	A,D		;  and move to reg A	LD	DE,@EXIT	;Where to go after boot	LD	BC,0		;Init BC(HL)=0 for @EXIT	JR	Z,NOAUT		;Go if no AUTO	PUSH	HL		;Save buffer pointer	LD	HL,CURSET	;Point to cursor setting	INC	(HL)		;Bump it down a line	POP	HL		;Recover INBUF$ pointer	LD	DE,@CMNDI	;Low order of @CMNDI	PUSH	DE		;Save on stack for return	LD	B,H		;Put INBUF$ on stack	LD	C,L		;  for @CMNDI	LD	DE,@DSPLY	;But do this firstNOAUT	PUSH	DE		;Put on stack for RET	PUSH	BC		;Either INBUF$ or 0	LD	HL,STUB	LD	DE,MOD3BUF+80	;Must move out of way	LD	BC,STUBLEN	;  amout to move	PUSH	DE		;Add RET vector to stack	LDIR			;Move stub up	CALL	GETKB67	LD	DE,DCT$		;Set up to move DCTs	LD	HL,MOD3BUF	;  from configed area	LD	BC,80		;Count for DCTs (10*8)	EXX			;Keep in alternate set	AND	82H		;Load config if zero	RET	NZ		;No config > go back	LD	HL,SYSGROW<8	;Position the cursor	LD	B,3	CALL	@VDCTL	LD	HL,CONFIG$	;Show sysgen message	CALL	@DSPLY	LD	DE,CFGFCB$	;Set up to load CONFIG/SYS	JP	@LOAD;CONFIG$ DB	'** SYSGEN **',03;;;GETKB67 LD	HL,KB67		;Check CLEAR key	LD	C,A	CALL	ENADIS_DO_RAM	LD	A,C	OR	(HL)		;Key down OR not SYSGENed	RET;;	Final initialization code;STUB	LD	HL,SFLAG$STUB1	RES	4,(HL)		;Test or set BREAK bit				;Without changing Z/NZ	JR	NZ,NOTSG	;Go if no SYSGEN found	LD	HL,MODOUT$	;Get pointer to port mask	LD	A,(HL)		;Get mask byte	OUT	(0ECH),A	;Speed it up	EXX			;Set to move DCTs	LDIR			;Move 'em	CALL	@ICNFG		;Init configNOTSG	LD	C,7SETCYL0	CALL	@GTDCT		; Get drive's DCT	BIT	3,(IY+3)	; If hard drive, don't stuff FF	JR	NZ,NOFF		;   and don't restore	LD	(IY+5),0FFH	; Set in case no restore	LD	A,(RSTOR$)	; Restore drives at startup?	OR	A	CALL	Z,@RSTOR	; Restore drives 1-7NOFF	DEC	C		; Next drive down	JR	NZ,SETCYL0	; Loop for # of drives	LD	HL,DINIROW<8	; Where the cursor should wind upCURSET	EQU	$-1	LD	B,3	CALL	@VDCTL		; Set cursor position;;	Detect Model 4 or 4P and adjust TFLAG$;	Look at "MODEL" at 4018h.  If so, M4P;	LD	DE,'OM'		; Init DE to "MO"	LD	HL,(4018H)	; Get 4P rom "leftover"	SBC	HL,DE		; Check if it's "MO"	LD	A,4		; Init to Model 4 Reg.	JR	NZ,MOD4REG	;   and go if not	LD	A,5		; Change to Mod 4PMOD4REG LD	(TFLAG$),A;	LD	HL,@RST38	; Point to RST vector and	LD	(HL),0C3H	;   activate task processor	POP	HL		; Pop INBUF$	RET			; To @CMD or @DSPLY,@CMNDI;	DC	12,0		; Space for more codeSTUBEND EQU	$STUBLEN EQU	STUBEND-STUB;;	Date and time promptingGETPARM PUSH	BC		; Save separator char	PUSH	DE		; Save message pointer	LD	B,3	CALL	@VDCTL		; Set cursor position	POP	HL		; Recover message pointer	CALL	@DSPLY		;   and display it	LD	HL,OVERLAY	; Input buffer location	POP	BC		; Get max length back	PUSH	BC	CALL	@KEYIN		; Get user entry	XOR	A	OR	B		; Anything entered?	POP	BC;---> 6.3.1 changes	JR	NZ,M20F4	; Go if something enteredM20EE	LD	A,0		;   else set return	OR	A		;   Z/NZ status	RET	ZM20F2	SCF			; Set carry flag	RET			;   and return;<--- 6.3.1 changesM20F4	PUSH	BC	LD	B,40H	CALL	@PAUSE		; To let finger off	POP	BC;;	Routine to parse DATE entry;PARSDAT LD	DE,CFGFCB$+31	;Point to buffer end	LD	B,3		;Process 3 fieldsPRSD1	PUSH	DE		;Save pointer;;	Routine to parse a digit pair;	CALL	PRSD3		;Get a digit	JR	NC,PRSD2	;Jump if bad digit	LD	E,A		;Multiply by ten	RLCA			;*2	RLCA			;*4	ADD	A,E		;*5	RLCA			;*10	LD	E,A		;Save back in E	CALL	PRSD3		;Get another digit	JR	NC,PRSD2	;Jump on bad digit	ADD	A,E		;Accumulate new digit	LD	E,A		;Save 2-digit value	SCF			;Show valid	LD	A,E		;Xfer field valuePRSD2	POP	DE		;Recover pointer	RET	NC		;Ret if bad digit pair	LD	(DE),A		;Else stuff the value	DEC	B		;Loop countdown	SCF	RET	Z		;Ret when through	DEC	DE		;Backup the pointer	LD	A,(HL)		;Ck for valid separator	INC	HL		;Bump pointer	CP	':'		;Check for colon	JR	Z,PRSD1		;Loop if match	CP	C		;Separator char required	JR	NC,PRSD4	;Exit if bad char;---> 6.3.1 changes	CP	0DH		;Enter?	JR	NZ,PRSD1	;Loop if not	LD	A,B		;Get char count	DEC	A		;Decrement it	JR	NZ,PRSD1	;Loop if not done	LD	A,(M20EE+1)	;Get value from code	OR	A		;Is it zero?	JR	Z,PRSD1		;Loop if it is	SCF			;Else set carry	RET			;  and return;<--- 6.3.1 changesPRSD3	LD	A,(HL)		;Get a digit	INC	HL	SUB	30H		;Convert to binaryPRSD4	CP	10	RET;;	Routine to display month or day of week;DSPMDY	PUSH	HL		;Print 4 spaces	LD	HL,SPACE4$	;Point to string	CALL	@DSPLY	POP	HLDSPMON	DEC	B		;Point to Bth entry	LD	A,L		;  in table	ADD	A,B		;Entries are 3 long	ADD	A,B		;  so have to add B	ADD	A,B		;  three times.	LD	L,A	LD	B,3		;Print 3 charsDSPM1	LD	A,(HL)	INC	HL	CALL	@DSP	DJNZ	DSPM1	RETPARTYR	DB	', 198 ',30,3;	IF	@INTLDATEPR	DB	30,'Date DD/MM/YY ? ',3	ELSEDATEPR	DB	30,'Date MM/DD/YY ? ',3	ENDIF;TIMEPR	DB	30,'Time HH:MM:SS ? ',3SPACE4$	DB	'   ',3,3;;	Under 6.3.0, this was the "Serial# xxxxxxxxxx' string;M2185	DC	21,0		;Space for message, or ???M2XXX	DC	32,0	END