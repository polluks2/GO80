;LBROUTE/ASM - ROUTE command	TITLE	<ROUTE - LS-DOS 6.3>;*GET	SVCEQU			; System SVC equates*GET	VALUES			; Misc equates;INH	EQU	0		; Inhibit LRL fault;	ORG	2400H;;	Save the stack and call Route routine;ROUTE	LD	(SAVESP+1),SP	; Save stack pointer	CALL	ROUTE1		; Call route routine	LD	HL,0		; Clean exit	JR	SAVESP;PRMERR	LD	A,PAR_ERR	; Parameter errorIOERR	LD	L,A		; Error code to HL	LD	H,00H	OR	0C0H		; Abbrev and return	LD	C,A		; Err code to C	LD	A,@ERROR	; Display error message	RST	28H	JR	SAVESP		; Go to exit;;	Internal error message handling;CANT	LD	HL,CANT$	; "No mem space..."	DB	0DDHSPCERR	LD	HL,SPCERR$	; "Devspec req..."	LD	A,@LOGOT	RST	28H	LD	HL,-1		; Set abort codeSAVESP	LD	SP,0		; Get stack ptr back	LD	A,@CKBRKC	; Clear break flag	RST	28H	RET			; Exit;;	ROUTE1 - Route spec to spec;ROUTE1	LD	DE,FCBSRC	; Fetch source spec	LD	A,@FSPEC	RST	28H	JR	NZ,SPCER	; Jump on error	LD	A,(DE)		; Get 1st char of name	CP	'*'		; Must be a device	JR	NZ,SPCER	; Jump if it's not	LD	DE,PRMTBL$	; Check parameters	LD	A,@PARAM	RST	28H	JR	NZ,PRMERR	; Jump on param error	LD	DE,(FCBSRC+1)	; Stuff source name	LD	(RTENAM+3),DE	LD	A,@FLAGS	; Get system flags	RST	28H;;	Test NIL parameter;NPARM	LD	BC,0		; Pick up NIL param	LD	A,B	OR	C	JP	NZ,NILDCB	; Jump if NIL entered;;	Route to device / file - check which one;	LD	DE,FCBDST	; Get destination spec	LD	A,@FSPEC	RST	28HSPCER	JP	NZ,SPCERR	; Jump on error	PUSH	DE	LD	DE,PRMTBL$	; Need in case REWIND	LD	A,@PARAM	RST	28H	POP	DE	JR	NZ,PRMERR	; Exit on param error	LD	A,(DE)		; Get 1st char of name	CP	'*'		; Test device / file	JR	NZ,INITFCB	; Jump if a file;;	Destination spec is a device;	LD	DE,(FCBDST+1)	; Get device name	LD	HL,(FCBSRC+1)	; Make sure SRC <> DEST	SBC	HL,DE		;   CF is reset	JP	Z,SPCERR	; Error if same	LD	A,@GTDCB	; Find in tables	RST	28H	JP	NZ,IOERR	; Jump if not foundCKDCBS	PUSH	HL		; Save DCB addr of dest	CALL	CKSRC		; Locate source DCB	JP	NZ,IOERRCKDCB1	DI	POP	BC		; Recover dest route vector	PUSH	HL		; Save DCB+0;;	Save the old device while stuffing the new;	INC	L		; Point to vector	LD	A,(HL)		; Save what's there	LD	(HL),C		; Stuff dest route	LD	C,A		;   into DCB of source	INC	L		;   while saving old	LD	A,(HL)		;   vector for storage	LD	(HL),B		;   (could be a FCB)	LD	B,A;;	Now set ROUTE bit and rest of DCB block;	POP	HL		; Recover pointer to DCB+0	LD	A,(HL)		; Init the ROUTE bit	PUSH	AF		; Save old TYPE bit	AND	07H		; Strip any flag bits	OR	10H	LD	(HL),A		; Show source is routed	LD	A,L	ADD	A,07H		; Point to name field	LD	L,A	LD	(HL),D		; And stuff in the name	DEC	L		;   in case this is a 	LD	(HL),E		;   new DCB block	POP	AF		; Get old TYPE byte and	BIT	4,A		;   save old data if	JR	NZ,CKDCB2	;   not already routed	DEC	L	LD	(HL),B		; Stuff old vector	DEC	L		;   for reclamation	LD	(HL),C	DEC	L	LD	(HL),A		; Stuff old TYPECKDCB2	EI	RET			; Successful;;	Destination is a file - INIT it and position to end;INITFCB	PUSH	DE	LD	DE,RTENAM	; See if space already	LD	A,@GTMOD	;   allocated for this	RST	28H		;   device name	POP	DE	JR	NZ,NOTRES	; Go if not found;;	Space in memory - re-use it;	INC	HL		; Get last byte used	INC	HL		;   into HL	LD	A,(HL)	INC	HL	LD	H,(HL)	LD	L,A	XOR	A		; Set a 0 to show	LD	(CKIFRES+1),A	;   already resident	JR	SETBUF;;	Not yet resident - get space for it;NOTRES	BIT	0,(IY+CFLAG$)	; Can we alter HIGH$?	JP	NZ,CANT		; Can't if frozen	LD	HL,0		; Get HIGH$	LD	B,L	LD	A,@HIGH$	RST	28HSETBUF	LD	(RTEDVR+2),HL	; Stuff highest used	INC	HL		; Reserve a page for	DEC	H		;   the I/O buffer	PUSH	HL		; Don't lose it	LD	B,00H		; LRL = 0 (256)	LD	A,@INIT		; Init the file	RST	28H	JR	NZ,INITF1	; What? An error?RPARM	LD	BC,0		; Check on rewind (no @PEOF)	INC	B		; Keep file at start	JR	Z,INITF1	;   if REWIND specified	LD	A,@PEOF		;   else position to EOF	RST	28H	JR	Z,INITF1	CP	1CH		; At end of file?INITF1	POP	HL		; Get back buffer pointer	JP	NZ,IOERR	; Any other error - Jump	LD	BC,32+14	; Back up another 32	XOR	A		;   for the FCB storage	SBC	HL,BC		;   + 14 for linkage	PUSH	HL		; Save module start;;	Bypass HIGH$ stuff if "ISRES";CKIFRES	OR	0FFH		; "OR 0" if is resident	JR	Z,ISRES1	;	DEC	HL		; Reset HIGH$ (B=0)	LD	A,@HIGH$	; Stuff new HIGH$	RST	28HISRES1	POP	DE		; Recover module pointer	PUSH	DE	LD	HL,RTEDVR	; Move module to memory	LDIR	POP	DE		; Now adjust to true	LD	HL,14		;   FCB location	ADD	HL,DE	JP	CKDCBS		; Go check the DCBs;;	Scan device tables for source device;CKSRC	LD	DE,(FCBSRC+1)	; Get source device name	PUSH	DE		;   and save for later	LD	A,@GTDCB	; Find device in table	RST	28H	JR	Z,CKSRC1	; Use it if found	LD	DE,0		;   else find a spare	LD	A,@GTDCB	;   DCB block	RST	28H	LD	A,33		; Init "No device space..."	JR	NZ,CKSRC2	; Abort if no spaceCKSRC1	PUSH	HL	CALL	CLSFILS		; Close any existing	POP	HL		;   file routesCKSRC2	POP	DE		; Recover source name	RET;;	NIL parameter entered, close up any open file;NILDCB	CALL	CKSRC		; Check on device	LD	A,(HL)		; Get type byte	OR	08H	LD	(HL),A		; Show is NIL device	LD	A,L		; Point to name field	ADD	A,06H	LD	L,A	DI			; No interruptions!	LD	(HL),E		; Stuff in our name	INC	L		;   in case it's a	LD	(HL),D		;   new DCB block	EI			; Okay to interrupt now	RET			; Successful;;	Find the last device route and close any open file;CLSFILS	BIT	4,(HL)		; Jump if no route	JR	Z,CLSFIL1	INC	HL		; Else pick up link addr	LD	A,(HL)		;   and test that one	INC	HL		;   for a chain	LD	H,(HL)	LD	L,A	JR	CLSFILSCLSFIL1	BIT	7,(HL)		; A file??	RET	Z		; Return if it's not	LD	DE,FCBFIL	; Point to FCB area	PUSH	DE	LD	BC,32		; 32 bytes in a FCB	LDIR			; Fill from device vector	POP	DE		; Get FCB pointer back	LD	A,@CLOSE	; Close the file	RST	28H	RET			; Return with Z/NZ status;;	Error messages;CANT$	DB	'No memory space available',0DHSPCERR$	DB	'Device spec required',0DH;;	Parameter table;PRMTBL$	DB	80H		; Version 6.x param table;	DB	53H,'NIL',0	DW	NPARM+1;	DB	56H,'REWIND',0	DW	RPARM+1	DB	00H;RTEDVR	JR	$		; No real jump	DW	$-$		; Stuff of HIGH$	DB	05H		; Name 5 longRTENAM	DB	'RTExx'		; Name of module	DW	0,0;FCBDST	DB	0	DS	31FCBFIL	DB	0	DS	31FCBSRC	DB	0	DS	31;	END	ROUTE