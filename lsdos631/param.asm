;****************************************************************;* Filename: PARAM/ASM						*;* Rev Date: 30 Nov 97						*;* Revision: 6.3.1						*;****************************************************************;* Parsing routines						*;*								*;****************************************************************;;	Parse a field;	(HL) -> Command Line;	(DE) -> FCB area;	(HL) <- 1 byte past non alphanumeric except 13,3,'(';	Z    <- Found valid flag;	NZ   <- Found invalid flag;@PARSER LD	B,08H		;Set length@PAR1	LD	A,B	LD	(PAR6+1),A	;Stuff length for test	INC	BPAR2	LD	A,(HL)	CP	03H		;ETX?	JR	Z,PAR5	CP	0DH		;<ENTER>?	JR	Z,PAR5	CP	'('		;Begin of param?	JR	Z,PAR5	INC	HL		;Bump pointer to next	CALL	TST09AZ		;Test if 0-9 or A-Z	JR	NC,PAR3		;Go if one of the above	CP	'a'		;Check on lower case	JR	C,PAR5		;Jump on non-alpha	CP	'z'+1		;Is it a-z?	JR	NC,PAR5		;Jump on non-alpha	RES	5,A		;Convert lower to upperPAR3	DEC	B		;Count down	JR	Z,PAR4	LD	(DE),A		;Xfer the char	XOR	A		;Show at least 1 valid	LD	(PAR6+1),A	;  char was detected	INC	DE		;Bump FCB pointer	JR	PAR2		;LoopPAR4	INC	B		;Here on max chars checked	JR	PAR2PAR5	LD	C,A		;Save separator	CP	' '	JR	NZ,PAR5B	DB	0FEH		; Mask INC HLPAR5A	INC	HL	CP	(HL)	JR	Z,PAR5APAR5B	LD	A,03H		;Stuff ETC	LD	(DE),A		;;;	Return status of field validity;PAR6	LD	A,00H		;Set Z flag if at least	OR	A		;  1 valid char detected	LD	A,C		;Recover separator char	RET;;	Test if 0-9 or A-Z;TST09AZ CP	'0'		;Special char?	RET	C		;Go if not in range	CP	'9'+1		;Jump on digit 0-9	JR	C,EXITC		;Go if 0-9 and set NC	CP	'A'		;Jump on special char	RET	C		;Go if 3BH to 40H	CP	'Z'+1		;Jump on A-ZEXITC	CCF			;Switch flag of result	RET;;	Find parameter in table;	(HL) -> Pointer to line;	(DE) -> Pointer to buffer area;	(BC) -> Pointer to parameter table;	(BC) <- Pointer to possible response byte;	(DE) <- Param vector address;	Z    <- Set if found;	NZ   <- If not found in table;@FNDPRM PUSH	HL	LD	H,B		;Xfer table addr	LD	L,C	LD	A,(HL)		;get 1st byte of table	RLCA			;  & test for enhanced	PUSH	AF		;  table format	JR	NC,FND1	INC	HL		;Bump past indicatorFND1	POP	AF		;Old or enhanced format?	PUSH	AF	LD	A,05H		;Init for old lengths	LD	BC,1<8!2	JR	NC,FND1A	;Branch if old format	LD	A,(HL)		;  else get param length	AND	0FH		;Strip flags	DEC	A		;Adjust for length-1	INC	B		;Update offset to address	INC	HL		;Bump past TYPE byteFND1A	LD	(FND3A+1),A	;Stuff the lengths	ADD	A,B	LD	(FND5A+1),A	ADD	A,C	LD	(FND2+1),A	LD	A,(DE)		;Get command line byte	CP	(HL)		;Match 1st char of table?	JR	Z,FND3		;Jump if 1st char matchesFND2	LD	BC,0008H	;  else bypass that entry	ADD	HL,BC	LD	A,(HL)		;Test for table end	OR	A	JR	NZ,FND1		;Loop if more	POP	HL		;Clean flag from stack	POP	HL		;Recover saved reg &	INC	A		;  set NZ for not found	RETFND3	POP	AF		;Check old or new table	PUSH	AF	JR	NC,FND3A	;Go if old format table	DEC	HL		;Check if type byte permits	BIT	4,(HL)		;  single-char abbreb	INC	HL	JR	Z,FND3A		;Go on no abbrev	INC	DE		;Make sure the next char	LD	A,(DE)		;  is not in the range	DEC	DE		;  <0-9,A-Z> before	CALL	TST09AZ		;  assuming abbrev	JR	C,FND5A		;Go on 1 char abbrevsFND3A	LD	B,05H		;5 more chars to match	PUSH	HL	PUSH	DE	LD	A,B		;Don't if trailing length	OR	A		;  is zero	JR	Z,FND5FND4	INC	DE	INC	HL	LD	A,(DE)	CP	03H		;ETX?	JR	Z,FND7	CP	0DH		;Jump on ENTER	JR	Z,FND7	CP	(HL)		;Match?	JR	NZ,FND6		;Jump if not	DJNZ	FND4		;  else loopFND5	POP	DE		;Param matched	POP	HL		;Recover begin of paramFND5A	LD	BC,0006H	;Point to address field	ADD	HL,BC	LD	C,L		;Save the response byte	LD	B,H		;  pointer in BC	DEC	BC	LD	E,(HL)		;Get param table address	INC	HL	LD	D,(HL)	POP	AF		;If not enhanced, change	JR	C,FND5B		;  pointer to bucket	LD	B,SBUFF$<-8	;  so we don't alter userFND5B	POP	HL		;Recover line position	XOR	A		;Show found	RETFND6	CALL	TST09AZ		;Check if 0-9,A-Z	JR	NC,FND8		;Go if in rangeFND7	LD	A,(HL)		;Loop if table has	CP	20H		;  trailing spaces	JR	Z,FND5FND8	POP	DE	POP	HL	JR	FND2;;	PARAM routine;	(HL) -> Param line;	(DE) -> Param table;	(DE) <- Table address value;	C    <- # of param;	Z    =	OK;	NZ   =	Param error;PARAM0	INC	HL		;Bump the pointerPARAM	LD	A,(HL)		;  and get char	CP	0DH	RET	Z		;Return on enter	CP	20H	JR	Z,PARAM0	;Loop on space	CP	'('	JR	NZ,PARAM5	;Jump if not left paren	LD	A,(DE)		;Check if enhanced table	RLCA	JR	NC,PARAM1	PUSH	DE		;Save pointer to start	INC	DE		;Point to 1st TYPE byte	PUSH	HL		;Save this position$?1	LD	A,(DE)		;get TYPE byte	AND	0FH	JR	Z,$?2		;Exit on end of table	LD	L,A		;Point to response byte	XOR	A	LD	H,A	INC	L	ADD	HL,DE	LD	(HL),A		;Zero the response	INC	HL		;Bump to the next TYPE	INC	HL	INC	HL	EX	DE,HL		;Table pointer back to DE	JR	$?1		;Loop through all response bytes;$?2	POP	HL		;Recover reg	POP	DE		;  & start of param tablePARAM1	PUSH	DE	LD	B,0FH		;Max 15 char field	LD	DE,SBUFF$	;Point to buffer region	INC	HL		;Bypass the "("	CALL	@PAR1		;Get the field	DEC	HL		;Backup to separator	POP	DE	JR	NZ,ERROUT	;Return if bad field	CP	0DH		;If separator was a CR,	JR	NZ,$?3		;  we need to counteract	INC	HL		;  the DEC HL above$?3	PUSH	DE	LD	B,D		;Table pointer to BC	LD	C,E	LD	DE,SBUFF$	;Param in table?	CALL	@FNDPRM	PUSH	BC		;Save response pointer	JR	Z,PARAM3	;Jump if found in table;;	Parameter not in table - NZ condition;PARAM2	POP	DE		;Pop response pointer	POP	DE		;Pop param table pointerERROUT	LD	A,44		;Set up PARAM ERROR	RET;;	Parameter found in table, parse the value;PARAM3	LD	A,(HL)		;Test for assignment	CP	'='	LD	BC,0		;Init BC for False	JR	Z,ASSIGN	;Jump if parm=value	DEC	BC		;  else set symbol TRUEPARMSW	EX	(SP),HL		;Get response byte	SET	6,(HL)		;Turn on FLAG-SWITCH;;	Valid param argument parsed into reg BC;PARAM4	EX	DE,HL		;Address pointer to HL	LD	(HL),C		;Stuff low-order value	INC	HL	LD	(HL),B		;Stuff high order value	POP	HL		;recover param line pointer	POP	DE		;recover param table pointer	LD	A,(HL)	CP	','		;Comman separator?	JR	Z,PARAM1	CP	0DH	RET	Z	CP	')'		;Closing paren?	JR	NZ,ERROUT	;Leave with error	INC	HL		;Bump line pointerPARAM5	XOR	A		;Show all OK	RET;;	Parameter assignment statement;ASSIGN	INC	HL		;Advance token past '='	LD	A,(HL)	CP	'"'		;Double quote string?	JR	Z,STRING	CP	'A'		;Check on digit or	JR	C,ASS3		;  special char	RES	5,A		;Strip lower case	CP	'X'		;Hexadecimal?	JR	Z,ASS1	CALL	ONOFF		;Check on Y/N/ON/OFF	JR	Z,PARMSW	;set FLAG-SWITCH if ok	JR	PARAM2		;  else error exitASS1	INC	HL	CALL	HEXVAL		;Check on hex format	JR	NZ,PARAM2	;Error if bad format	JR	ASS3A		;  else bypass & set resp;;	Is the parameter numeric or flag?;ASS3	CP	'0'		;Parameter = number?	PUSH	AF		;CF=0 if number	CALL	@DECHEX		;Cvt # @ HL to bin in DE	POP	AFASS3A	EX	(SP),HL		;Get response pointer	JR	NC,ASS4		;Show numeric if CF=0	SET	6,(HL)		;  otherwise show switch	DB	LD__A		;Skip next instructionASS4	SET	7,(HL)		;Set numeric response byte	JR	PARAM4;;	String parameter entry;STRING	INC	HL		;Bypass quote char	LD	B,H		;Save starting address	LD	C,LSTR1	LD	A,(HL)		;Get a char	CP	20H	JR	C,PARAM2	;Exit on control char	INC	HL		;Bump pointer	CP	'"'		;Closing double quote?	JR	NZ,STR1	PUSH	HL		;Save current pointer	SBC	HL,BC		;Calc length of string	LD	A,L	DEC	A		;Adjust for INC HL	CP	32		;if len>31, set to 0	JR	C,STR1A	XOR	ASTR1A	POP	HL		;Recover pointer	EX	(SP),HL		;Get response byte	OR	20H		;Set FLAG-STRING	LD	(HL),A	JR	PARAM4;;	Check for Yes, No, On, Off;ONOFF	SUB	'Y'		;Is it Yes?	JR	Z,ONO1		;Jump on yes	ADD	A,'Y'-'N'	;Is it no?	JR	Z,ONO2		;Jump on no	DEC	A		;Is it 'O'n or 'O'ff?	RET	NZ		;Return if neither	INC	HL		;Bump pointer to next	LD	A,(HL)		;  char and get it	RES	5,A		;Set lower to upper	CP	'F'		;Off?	JR	Z,ONO2		;Jump if OFF	CP	'N'		;On?	RET	NZ		;Return if notONO1	DEC	BC		;Init to trueONO2	INC	HL		;Ignore trailing part	LD	A,(HL)		;  of word until closing	CP	')'		;  ")" or comma separator	RET	Z		;  or CR	CP	0DH	RET	Z	CP	','	RET	Z	JR	ONO2		;Loop;;	Process hexadecimal assignment;HEXVAL	LD	A,(HL)		;Get a char	CP	27H		;Must be single quote	RET	NZ		;Return if it's notHEX1	INC	HL		;Bump past it	LD	A,(HL)		;Get possible hex digit	SUB	30H		;Begin conversion	JR	C,HEX2		;Jump if < "0"	CP	0AH		;Check for 0-9	JR	C,HEX3		;Jump if it is	RES	5,A		;Force lower to upper	SUB	07H		;  and check A-F	CP	16	JR	C,HEX3		;Jump if A-FHEX2	LD	A,(HL)		;Test for closing quote	CP	27H	INC	HL		;Bump pointer	RET	Z		;ret if closing quote	DEC	HL		;  else backup, set OK,	XOR	A		;  then return	RETHEX3	PUSH	BC		;Exchange BC and HL	EX	(SP),HL		;  and save HL	ADD	HL,HL		;Multiply by 16	ADD	HL,HL	ADD	HL,HL	ADD	HL,HL	LD	B,H		;Merge new digit	ADD	A,L	LD	C,A	POP	HL		;Recover pointer	JR	HEX1		;Loop;