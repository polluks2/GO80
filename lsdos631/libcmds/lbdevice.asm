; LBDEVICE/ASM - Devicy commands	TITLE	<DEVICE - LSDOS 6.3>;LF	EQU	10CR	EQU	13;*GET	SVCEQU			; Get SVC equates;	ORG	2400H;DEVICE	LD	A,@CKBRKC	; Check for break	RST	28H	JR	Z,DEVICEA	; Continue if not	LD	HL,-1		;   else abort	RET;DEVICEA	LD	(SAVESP+1),SP	; Save stack pointer	LD	DE,PRMTBL$	; First check for user parms	LD	A,@PARAM	RST	28H	JP	NZ,IOERR	; Go if param error	LD	A,@FLAGS	; Get flag table pointer	RST	28H	CALL	RESKFL		; Reset Pause and Enter	EI			; Make sure they're onDPARM	LD	HL,-1		; Check drive parameter	LD	A,H	OR	L	JP	Z,DEND		; Go if D=NO	LD	C,00H		; Init to drive 0DEV1	PUSH	BC		; Save drive #	XOR	A		; Reset flag stuff	LD	(WPTEST+1),A	;   location	LD	A,@GTDCT	; Get DCT address	RST	28H	LD	A,(IY+0)	; Is this drive disabled?	CP	0C3H	JP	NZ,POPDRV	; Ignore if it is	LD	A,@CKDRV	; This drive available?	RST	28H	JR	NZ,DEV2		; Go if no diskette	RRA			; Shift C flag to bit 7	LD	(WPTEST+1),A	;   & save for WP test	LD	HL,BUFFER	; Pick up GAT for the	LD	D,(IY+09H)	;   pack name	LD	E,L	LD	A,@RDSSC	RST	28H	LD	A,20		; "GAT read error	JP	NZ,IOERR	; Go if error	LD	HL,BUFFER+0D8H	; Shove bracket ETX	LD	(HL),']'	INC	L	LD	(HL),' '	INC	L	LD	(HL),3	LD	L,0D0H		; Point to start of name	JR	DEV2A;;	Drive info for this active drive;DEV2	LD	HL,NOPACK$	; Display pack name	LD	DE,BUFFER+0D0H	LD	BC,12	LDIRDEV2A	LD	A,':'		; Output the colon	CALL	BYTOUT	POP	BC		; Get drive back	PUSH	BC	LD	A,C		; Get drive # converted	ADD	A,'0'		;   to ASCII & display it	CALL	BYTOUT	CALL	SPCOUT		; Output a spaceWPTEST	LD	A,00H		; Get CKDRV FDC status	OR	(IY+03H)	; Test software WP	AND	80H		; Set Z if not WP	LD	A,' '		; Pair of spaces	LD	B,' '		; if not WP	JR	Z,DEV2B		; Go if not WP	LD	A,'W'		; Else write "WP"	LD	B,'P'DEV2B	CALL	BYTOUT	LD	A,B	CALL	BYTOUT	CALL	SPCOUT	LD	A,'['		; Left bracket	CALL	BYTOUT	LD	HL,BUFFER+0D0H	; Write the pack name	CALL	LINOUT;;	Determine if 5" or 8";	BIT	5,(IY+03H)	; Test 5 or 8 inch	LD	A,'5'		; Init to 5	JR	Z,M24A9		; Bypass if not 8	LD	A,'8'		; Else set to 8M24A9	CALL	BYTOUT	BIT	3,(IY+03H)	; Test rigid/floppy	LD	HL,FLOPY$	; Init to floppy	JR	Z,M24B8		; Go if floppy	LD	HL,RIGID$	; Else write hardM24B8	CALL	LINOUT	LD	A,(IY+04H)	; Output drive select addr	AND	0FH		;   in ascii	ADD	A,90H	DAA	ADC	A,40H	DAA	CALL	BYTOUTDEV3	LD	L,(IY+06H)	; Get highest cylinder	LD	H,00H	INC	HL		; Adjust for 0 offset	BIT	3,(IY+03H)	; Hard drive?	JR	Z,DEV4		; Go if floppy	BIT	5,(IY+04H)	; Double step?	JR	Z,DEV4	ADD	HL,HLDEV4	LD	DE,COMMA$	; Convert cyls to dec	LD	B,03H		; Max 3 chars	LD	A,@HDEC		; Convert to ASCII	RST	28H	LD	HL,CYLS$	; Display cyls = xx	CALL	LINOUT	BIT	3,(IY+03H)	; Bypass if floppy	JR	Z,FLOPPY	BIT	2,(IY+03H)	; Test fixed/removable	LD	HL,REMOV$	; Init to removable	JR	Z,M24FC		; Bypass if so	LD	HL,FIXED$	;   else show fixedM24FC	CALL	LINOUT	JR	ENDLINE;;	Next section deals only with floppies;FLOPPY	BIT	6,(IY+03H)	; Test SDEN/DDEN	LD	A,'S'		; Init to SDEN	JR	Z,M250B		; Jump if it is	LD	A,'D'		;   else show DDENM250B	CALL	BYTOUT	LD	HL,DEN$		; Show rest of "DEN"	CALL	LINOUT	BIT	5,(IY+04H)	; Test # sides	LD	A,'1'		; Init to 1	JR	Z,M251D		; And go if it is	INC	A		; Else make it 2M251D	CALL	BYTOUT	LD	HL,STEP$	CALL	LINOUT	LD	A,(IY+03H)	; Get step rate & 8/5	AND	23H		; Convert rate to an	LD	B,A		;   index in the table	RRCA	RRCA	RRCA	OR	B	RLCA	AND	0EH		; Mask off garbage	LD	HL,STPRAT$	; Get table base	ADD	A,L		; Add table low order	LD	L,A		; Set low order	ADC	A,H	SUB	L	LD	H,A	LD	A,(HL)		; Get 1st step char	INC	HL	CALL	BYTOUT		; Display it	LD	A,(HL)		;   and the 2nd	CALL	BYTOUT	LD	HL,MS$		; Display "ms,"	CALL	LINOUT	BIT	5,(IY+03H)	; Bypass DELAY if 8"	JR	NZ,ENDLINE	; 8" always running	LD	HL,DLY$		; Display "dly="	CALL	LINOUT	BIT	2,(IY+03H)	; Test on/off	LD	A,' '	LD	B,'1'	JR	Z,M2564		; Go if 1 sec	LD	A,'.'	LD	B,'5'M2564	CALL	BYTOUT		; Indicate delay	LD	A,B	CALL	BYTOUT	LD	A,'s'	CALL	BYTOUTENDLINE	CALL	CKPAWS		; Check pause of displayPOPDRV	POP	BC		; Recover drive #	INC	C		; Next drive	LD	A,C	CP	08H		; All done?	JP	NZ,DEV1		; Go if notDEND	EQU	$BPARM	LD	HL,$-$		; Check B parameter	LD	A,H	OR	L	JP	Z,SPARM;;	Display the device vectoring;	LD	DE,'IK'		; Start of device tables	LD	A,@GTDCB	RST	28H	JP	NZ,IOERRLOGDCB	LD	A,(HL)		; Bypass this device if	OR	A		;   table shows spare	JP	Z,DVRB2	LD	DE,STRBUF	; Point to string buffer	PUSH	HL		; Save origin ptr	CALL	MOVNAM		; Move dev name to strbuf	POP	HL		; get origin back	PUSH	HLLOGDCB1	BIT	3,(HL)		; if NIL don't show	JR	NZ,DVRADDR	;   any routes	BIT	4,(HL)		; Is device routed?	JR	Z,DVRADDR	; Bypass if not;;	This device is routed;LOGRTE	CALL	VEC2HL		; Get vector in HL	BIT	7,(HL)		; Is the route to a file?	JP	NZ,RTEFCB	; Jump if a file	PUSH	HL		; Hang on to this vector	CALL	DCBDIR		; Get device direction	CALL	MOVNAM		; Move name to strbuf	POP	HL		; Recover org of routee	BIT	4,(HL)		; Is route also routed?	JR	NZ,LOGRTE	; Loop-de-loop if yes	JR	DVRB1		;   else go display the line;;	Device has no routes - show its driver address;DVRADDR	CALL	DCBDIR		; Get device direction	BIT	3,(HL)		; Is this a NIL device?	JP	NZ,MOVNIL	; No address if NIL;;	If linked, show device name of link;	BIT	5,(HL)		; Any link DCB?	JR	Z,DVRA0		; Go if none	CALL	VEC2HL		; Get address of link DCB;;	Now move in the name of the linked DCB;	PUSH	HL	PUSH	HL	CALL	MOVNAM		; Move name of link DCB	LD	A,'|'		; Get separator for display	LD	(DE),A		;   and put it in buffer	INC	DE	POP	IY		; Pop address to IY	LD	L,(IY+04H)	; Get linked DCB address	LD	H,(IY+05H)	CALL	MOVNAM		; Move name of linked DCB	POP	HL		; Recover address	EX	DE,HL		; Switch temp, HL to	LD	(HL),' '	;   display buffer	INC	HL	LD	(HL),'&'	; Show the link	INC	HL	EX	DE,HL		; Back to normal	JR	LOGDCB1		; Go check this one;;	If filtered, find the filter DCB;DVRA0	BIT	6,(HL)		; If filtered, recover the	JR	Z,DVRB0		;   original data by	PUSH	HL		;   swapping back the	LD	A,'['	LD	(DE),A	INC	DE	PUSH	DE	LD	D,H	LD	E,L		;   1st three bytes with	CALL	VEC2HL		;   the FILTER DCB	LD	BC,4		; HL now points to the	ADD	HL,BC		;   entry point.  Get its	LD	C,(HL)		;   DCB address by peeking	INC	C		;   past the name field	ADD	HL,BC	CALL	VEC2HLA		; Get addr	PUSH	HL		; If DCB is itself, then	SBC	HL,DE		;   bring in the "inactive	POP	HL	POP	DE		; Recover string buff ptr	JR	NZ,DVRA1	LD	HL,INACT$	LD	BC,8	LDIR	JR	DVRA2;DVRA1	CALL	MOVNAM		; Move name of filter DCBDVRA2	LD	A,']'		; Put dsp chars into buffer	LD	(DE),A	INC	DE	LD	A,' '	LD	(DE),A	INC	DE	POP	HL		; Pop orig DCB pointer;;	Routine to construct address "X'xxxx'";DVRB0	LD	A,'X'		; Show address as	LD	(DE),A		;   X'dddd'	INC	DE	LD	A,27H		; Single quote	LD	(DE),A	INC	DE	CALL	VEC2HL		; Get vector	EX	DE,HL		; Put in DE	LD	A,@HEX16	; Convert to hex digits	RST	28H	EX	DE,HL		; Put str ptr back in DE	LD	A,27H		; Closing single quote	LD	(DE),A	INC	DEDVRB1	LD	A,CR	LD	(DE),A		; Stuff end of line	LD	HL,STRBUF	; Display the line	CALL	LINOUT	CALL	CKPAWS0		; Chk with no CR	POP	HL		; Recover table orgDVRB2	LD	A,L		; Advance to next tableTABLEN	ADD	A,08H	LD	L,A	JP	C,SPARM		; Exit if finished	JP	LOGDCB		;   else loop;;	Device routed to a file - grab its filespec;RTEFCB	PUSH	HL		; Save control block org	LD	HL,IO$		; Show 2-way device	LD	BC,5	LDIR	POP	HL	LD	A,L		; Pt to file route data	ADD	A,06H		;   by indexing into FCB	LD	L,A	ADC	A,H	SUB	L	LD	H,A		; HL = FCB+6	LD	C,(HL)		; Grab drive #	INC	HL	LD	B,(HL)		; Get DEC	PUSH	DE	LD	A,@FNAME	; Fetch filename	RST	28H	POP	DE	JP	NZ,IOERRRTEF1	LD	A,(DE)		; Find end of filename	CP	03H	JR	Z,DVRB1		; Exit on ETX to put CR	INC	DE	JR	RTEF1;;	Move in NIL as driver address;MOVNIL	LD	HL,NIL$		; Move in NIL	LD	BC,3	LDIR	JR	DVRB1;;	Routine to denote i/o direction;DCBDIR	CALL	MOVSPC		; 1st need a space	BIT	0,(HL)		; Test if input device	JR	Z,DCBD1		; Put another space if not	LD	A,'<'		;   else show input capableDCBD1	LD	(DE),A	INC	DE	LD	A,'='		; Always need this	BIT	6,(HL)		; If a filter, then	JR	Z,M2688		;   reset to #	LD	A,'#'M2688	LD	(DE),A	INC	DE	LD	A,' '		; Init a space	BIT	1,(HL)		; Output device?	JR	Z,DCBD2	LD	A,'>'		; Show output capableDCBD2	LD	(DE),A	INC	DE;;	Move a space into the buffer;MOVSPC	LD	A,' '		; and end with a space	LD	(DE),A	INC	DE	RET;;	Get vector to HL;VEC2HL	INC	L		; Pt to vectorVEC2HLA	LD	A,(HL)		; Move it to HL	INC	L	LD	H,(HL)	LD	L,A	RET			; and return;;	Move device name into string buffer;MOVNAM	LD	A,L		; Point to name field	ADD	A,06H	LD	L,A	LD	A,'*'		; Stuff "*" in str buf	LD	(DE),A	INC	DE		; Bump to next pos	LDI			; Move 1st char of name	LD	A,(HL)		; Test 2nd	OR	A	RET	Z		; Return if done	LD	(DE),A		;   else move 2nd char of name	INC	DE	RETBEND	EQU	$;;	Show high memory device drivers;SPARM	LD	HL,-1		; Check S parameter	LD	A,H	OR	L	JP	Z,EXIT		; Exit if through	LD	HL,DVCHDR$	; Display header	CALL	LINOUT	LD	A,@FLAGS	; Get flag table	RST	28H	LD	A,(IY+'D'-'A')	; Get device flag	OR	A		; Exit if none in use	PUSH	AF		; Save flag	JR	Z,SHOWFS	; Go if nothing on	LD	HL,DVCS$	; Pt to word string	LD	BC,8<8!0FFH	; Init for 8 flag bitsDOD1	POP	AF		; Get link back	RRCA			; Test if active	PUSH	AF	JR	NC,DOD3		; Bypass if inactive	INC	C		; Do we do the comma?	LD	A,','		; End of word, do comma	CALL	NZ,BYTOUT	CALL	SPCOUT		; Start with a spaceDOD2	LD	A,(HL)		; Display word until carry	INC	HL	PUSH	AF	AND	7FH		; Strip possible carry	CALL	BYTOUT		; Display the char	POP	AF	RLCA			; Was carry set?	JR	NC,DOD2		; Loop if not	DJNZ	DOD1		; Loop for 8 bits	JR	SHOWFS		; Exit the loop;DOD3	LD	A,(HL)		; Loop & ignore word	INC	HL	RLCA			; Set carry on last char	JR	NC,DOD3	DJNZ	DOD1		; Loop for 8 bits;;	Show fast or slow;SHOWFS	BIT	3,(IY+'S'-'A')	; Get FAST setting	JR	NZ,FAST		; Jump if not slow	LD	HL,SLOW$	JR	SHOWITFAST	LD	HL,FAST$SHOWIT	LD	A,(IY+'D'-'A')	; Check if others shown	OR	A	JR	NZ,COMAOK	INC	HL		; Bypass commaCOMAOK	CALL	LINOUT;;	Display system modules resident;DORES	POP	AF		; Stack integrityNOTON	CALL	CKPAWS	LD	DE,RES$		; Check if driver resident	LD	A,@GTMOD	;   in memory	RST	28H	JP	NZ,EXIT		; Done if nothing res'd	LD	HL,5	ADD	HL,DE		; Point to hi-order table	PUSH	HL	LD	HL,SYSRES$	; Display header	CALL	LINOUT	POP	HL	LD	BC,16<8!0FFH	; Init for 16 modulesDORES1	LD	A,(HL)		; Get a hi-order vector	INC	HL		; Bump pointer to next	INC	HL	OR	A		; Is this module resident?	JR	Z,DORES3	; Go if not	INC	C	LD	A,','		; Need comma if 2nd	CALL	NZ,BYTOUT	CALL	SPCOUT		; Start with a space	LD	A,16	SUB	B		; Calculate module #	LD	D,-1DORES2	INC	D	SUB	10	JR	NC,DORES2	PUSH	AF		; Save units place	LD	A,D		; Test tens place	ADD	A,'0'		;   for non-zero	CP	'0'	CALL	NZ,BYTOUT	; Output if non zero	POP	AF		; Get units	ADD	A,'0'+10	; Adjust to ASCII	CALL	BYTOUTDORES3	DJNZ	DORES1	CALL	CKPAWS		; One last check for CR	JR	EXIT;;	Output display routines;LINOUT	LD	A,@DSPLY	; Display a line of text	RST	28H	JR	NZ,IOERR	; Go on error	LD	A,(PPARM+1)	; Check P param	OR	A	RET	Z	LD	A,@PRINT	; Also print if needed	RST	28H	JR	NZ,IOERR	; Go on error	RET;;	Display/print a byte;SPCOUT	LD	A,' '		; This displays a spaceBYTOUT	PUSH	BC		; Save BC	LD	C,A		; Get char into C	LD	A,@DSP		; Display it	RST	28H	JR	NZ,POPBCPPARM	LD	DE,0		; Get P Param	LD	A,E	OR	D	JR	Z,POPBC		; Skip print if not	LD	A,@PRT		;   else print char	RST	28HPOPBC	POP	BC		; Recover BC	RET	Z		; Return on no error;;	Error handler;IOERR	LD	L,A		; Move error code to HL	LD	H,00H	OR	0C0H		; Make short message	LD	C,A		; Store in C for SVC	LD	A,@ERROR	RST	28H	JR	SAVESP		; And exit;;	Routine to check on pause or break;CKPAWS	LD	A,CR		; End line first	CALL	BYTOUTCKPAWS0	LD	A,@FLAGS	; Get flag table	RST	28H	LD	A,(IY+'K'-'A')	; Get KFLAG$	BIT	0,A		; Check for break	JR	NZ,BREAK	; Go if detected	BIT	1,A		; Check for pause	RET	Z		; Return if notCKPAW1	LD	A,@KEY		;   else wait for key	RST	28H		;   input	CP	60H	JR	Z,CKPAW1	; Loop on pause key	CP	80H		; Break?	JR	Z,BREAKRESKFL	LD	A,(IY+'K'-'A')	; Reset pause & enter bits	AND	0F9H	LD	(IY+'K'-'A'),A	; Save it back	RET;;	Break handler routine;BREAK	CALL	RESKFL		; Reset keyboard flags	LD	HL,-1		; Init error codeSAVESP	LD	SP,$-$		; Restore the stack ptr	LD	A,@CKBRKC	; Clear any BREAK	RST	28H	RET			; and return;;	Exit;EXIT	LD	HL,0		; Init no error	JR	SAVESP		; Fix stack and return;;	String area;NOPACK$	DB	'No  Disk] ',3INACT$	DB	'Inactive'DVCHDR$	DB	LF,'Options:',3DVCS$	DB	'Spoole','r'!80H	DB	'Typ','e'!80H	DB	'Verif','y'!80H	DB	'Smoot','h'!80H	DB	'Memdis','k'!80H	DB	'Form','s'!80H	DB	'KS','M'!80H	DB	'Graphi','c'!80HFAST$	DB	', Fast',3SLOW$	DB	', Slow',3RES$	DB	'SYSRES',3SYSRES$	DB	'System modules resident:',3STPRAT$	DB	' 6122030 3 61015'FLOPY$	DB	'" Floppy #',3RIGID$	DB	'" Rigid  #',3CYLS$	DB	', Cyls='COMMA$	DB	'   , ',3REMOV$	DB	'Removable',3FIXED$	DB	'Fixed',3DEN$	DB	'den, Sides=',3STEP$	DB	', Step=',3MS$	DB	'ms',3DLY$	DB	', Dly=',3NIL$	DB	'Nil'IO$	DB	' <=> ';;	Parameter Table;PRMTBL$	EQU	$VAL	EQU	80HSW	EQU	40HSTR	EQU	20HSGL	EQU	10H;	DB	80H			; Version 6.x table format	DB	SW!SGL!6,'BYTEIO',0	DW	BPARM+1	DB	SW!SGL!6,'DRIVES',0	DW	DPARM+1	DB	SW!SGL!5,'PRINT',0	DW	PPARM+1	DB	SW!SGL!6,'STATUS',0	DW	SPARM+1	DB	SW!SGL!6,'OPTION',0	DW	SPARM+1	DB	00H			; End of table;	ORG	$<-8+1<8;BUFFER	DS	256STRBUF	EQU	$;	END	DEVICE