;LBPURGE/ASM - PURGE command	TITLE	<PURGE - LS-DOS 6.3>;; Revision history:;; 24 Nov 97;	Fixed bug in '*' parsing code for filespec/extspecs;	The code wasn't incrementing the destination pointer;	in the DJNZ loop.  See PRSPEC for changes.  Also, added;	code so "TEST*/CMD" would parse correctly.;;	Bugs only fixed if PWCFIX is -1;@PWCFIX	EQU	0;ETX	EQU	3LF	EQU	10CR	EQU	13PAR_ERR	EQU	44		; Parameter errorPASSWORD	EQU	42E0H	; Blank master password;*GET	SVCEQU			; SVC equates*GET	SVCMAC			; SVC Macros;	ORG	2400H;PURGE	LD	A,@CKBRKC	; Break key down?	RST	28H	JR	Z,BEGINA	; Okay if not	LD	HL,-1		;   else abort	RET;;	Purge code;BEGINA	LD	(SAVESP+1),SP	; Save stack pointer	PUSH	HL		; Save cmd line ptr	LD	A,@FLAGS	; Get system flags	RST	28H	PUSH	IY		; Move flags to DE	POP	DE	LD	HL,18H		; Point to YFLAG$	ADD	HL,DE	LD	(SVYFLG1+1),HL	; Save YFLAG$ ptr	LD	(SVYFLG2+1),HL	POP	HL;PURGE1	LD	A,(HL)		; Bypass cmd line blanks	INC	HL	CP	' '	JR	Z,PURGE1	LD	DE,BLANKS	; Point to filespec area	LD	B,08H		; Init for file name	CP	'-'		; If -, set up flag	JR	NZ,PUR0	LD	(MFLG+1),A	LD	A,(HL)	INC	HLPUR0	CALL	PRSPEC		; Check on filename	CP	'.'		; Check on password entered	JR	Z,PUR0A	CP	'/'		; Check on file ext entered	JR	NZ,PUR1PUR0A	LD	DE,BLANKS+8	; Point to ext field	LD	B,03H		; Max 3 chars	LD	A,(HL)	INC	HL	CALL	PRSPEC		; Check on EXTPUR1	CP	':'		; Drive entered?	LD	C,00H		; Init to drive 0	JR	NZ,PRMERRA	; Quit if no drive	LD	A,(HL)		; Get drive num	INC	HL	SUB	'0'		; Convert to binary	CP	08H		; In range?	JP	NC,PRMERR	; Jump if out of range	LD	C,A		; Store drive in C	LD	B,C		; Drive # to B	INC	B		; Adjust for zero offset	LD	A,63		; Init for instructionPUR1A	ADD	A,08H		; Make bit instruction	DJNZ	PUR1A		; Loop for proper bit	LD	(UNPK1+1),A	; Save it	LD	(M2641),A	;   in program codePUR2	LD	A,C		; Get drive # back	LD	(TSTMPW+1),A	; Save for later	LD	A,@CKDRV	; Check if drive available	RST	28H	LD	A,32		; Drive not available	JP	NZ,IOERR	LD	A,0FH		; Init WP error	JP	C,IOERR	LD	A,@GTDCT	; Get DCT to IY	RST	28H	LD	DE,PRMTBL$	; Get parameters	LD	A,@PARAM	RST	28HPRMERRA	JP	NZ,PRMERR	; Jump on errorDATPRM	LD	HL,0		; Get date="from=to"	LD	A,H	OR	L	JR	Z,PUR3		; Bypass if not entered	LD	A,(HL)		; Check for "-to"	CP	'-'	JR	Z,CKTO	LD	A,80H		; Set FROM bit	LD	(FTFLG),A	; Note FROM entered	CALL	PAKDAT		; Pack the date entry	JP	NZ,IOERR	; Quit if bad date	LD	(FMPAKD),BC	; Save packed FROM date	LD	A,(HL)	CP	'"'	JR	Z,FRCT0	CP	'-'		; Check for "-to"	JR	NZ,PUR3;;	Check TO date;CKTO	INC	HL		; Bypass the '-'	LD	A,(HL)		; Check for end of param	CP	'"'	JR	Z,PUR3		; Go on param end	CALL	PAKDAT		;   else pack the date	JP	NZ,IOERR	; Quit if date bad;FRCT0	LD	A,(FTFLG)	OR	01H		; Set TO bit	LD	(FTFLG),A	LD	(TOPAKD),BC	; Save packed TO datePUR3	LD	A,(QPARM+1)	; Query param used?	OR	A	JR	Z,DOEVER	; Go if not	CALL	CKINDO		; Invalid command during	JP	NZ,IOERR	;   <DO> processing;DOEVER	CALL	TSTMPW		; Check on master password	JP	NZ,IOERR	; Go if wrong	LD	A,(TSTMPW+1)	; Get drive	LD	C,A	LD	D,(IY+09H)	; Get DIR cylinder from DCT	LD	E,01H		; Point to HIT sector	LD	HL,HITBUF	LD	A,@FLAGS	; Point IY to flags	RST	28H	LD	A,@RDSSC	; Read HIT sector	RST	28H	LD	A,16H		; Init "HIT read error..."	JP	NZ,IOERR	; Go if error occurred	JR	SCNH3;;	Major loop to scan HIT for files;SCNHIT	POP	HL		;SCNH1	POP	BC		; Recover HIT ptr DEC	LD	H,HITBUF<-8	; Pt to hi-order buffer	LD	L,B		; Set lo-order DECSCNH2	LD	A,L	ADD	A,32		; Pt to next on in	LD	L,A		;   same dir sector	JR	NC,SCNH3	; Jump if still in sector	INC	L		; Bump to next dir sector	CP	1FH		; End of the line?	JR	NZ,SCNH3	; Loop if not	LD	C,CR	LD	A,@DSP		; Write new line & exit	RST	28H	JP	EXIT;;	Routine to check on dir record in use;SCNH3	LD	A,L		; Ignore BOOT & DIR	AND	0FEH	JR	Z,SCNH2	LD	A,(HL)		; Get HIT hash byte	OR	A	JR	Z,SCNH2		; Ignore if spare	LD	B,L		; Save the DEC	PUSH	BC	LD	A,L		; Get record # in L	AND	0E0H	LD	L,A	XOR	B		; Get sector # in ASCNH3A	CP	0FFH		; Same as what's in core?	JR	Z,SCNH4		; Bypass if same	LD	(SCNH3A+1),A	; Update indicator byte	LD	A,@DIRRD	; Read this directory	RST	28H	JP	NZ,IOERR	; Quit if error	LD	A,H		; Set SBUFF pointer	LD	(SCNH4+1),ASCNH4	LD	H,00H		; Pt to dir-buff hi order	LD	A,(HL)		; L set to low order	BIT	4,A		; Ignore if not assigned	JR	Z,SCNH1	BIT	7,A		; Ignore if it's an	JR	NZ,SCNH1	;   extended dir record	BIT	6,A		; Jump if not a SYS file	JR	Z,CKINVSPARM	LD	DE,0		; Pick up S param	LD	A,D		; Ignore this one if	OR	E		;   S-param not entered	JP	Z,SCNH1	JR	CKNAM;;	Non-SYS file;CKINV	BIT	3,A		; Jump if visible	JR	Z,CKNAMIPARM	LD	DE,0		; Pick up I param	LD	A,D		; Ignore if not entered	OR	E		;   as this file is	JP	Z,SCNH1		;   invisible;;	Parms match - grab filename and check class;CKNAM	PUSH	HL		; Save ptr to record	LD	A,L		; Point to filename	ADD	A,05H		;   in directory	LD	L,A	LD	DE,BLANKS	; Point to parsed input	LD	B,11		; Chk name/ext (11 chars)SCNH5	LD	A,(DE)	CP	'$'		; Wild char?	JR	Z,SCNH6		; Always a match	CP	(HL)		; Not global - char match?	JR	Z,SCNH6		; Go if so	CP	' '		; Blank = end of check	JR	NZ,MFLG		; If not blank, no matchSCNH6	INC	HL		; Bump pointers	INC	DE	DJNZ	SCNH5		; Loop for 11 chars	LD	A,(MFLG+1)	; Bypass if match but	OR	A		;   '-' exclude given	JP	NZ,SCNHIT	JR	SCNH6AMFLG	LD	A,00H		; Ignore if no match &	OR	A		;   no exclude given	JP	Z,SCNHITSCNH6A	POP	HL		; Recover DIR+0 pointer	PUSH	HL;;	Now check if date matches;	INC	HL		; Point to date field	CALL	UNPACK		; Alter date for compare	LD	A,(FTFLG)	RLCA			; Test FROM bit	JR	NC,SCNH6B	LD	A,D		; Ignore if no date in	OR	E		;   DIR for the file	JP	Z,SCNHIT	LD	HL,(FMPAKD)	; Get user entry	EX	DE,HL	CALL	CPHLDE		; Compare HL to DE	EX	DE,HL	JP	C,SCNHIT	; Go if out of rangeSCNH6B	LD	A,(FTFLG)	RRCA			; Test TO bit	JR	NC,MATCHES	; Go if no TO param	LD	A,D		;   else chk if file is dated	OR	E	JP	Z,SCNHIT	; Go if no DIR date	LD	HL,(TOPAKD)	; Get user's packed date	CALL	CPHLDE		; Compare the two	JP	C,SCNHIT	; Go if  out of range;MATCHES	POP	HL		; Recover ptr to DIRRECDONAM	PUSH	HL	LD	A,L		;   & point to filename	ADD	A,05H	LD	L,A	LD	DE,FCB1$	; Point to name/ext buffer	LD	B,08H		; Max 8 char nameDONAM1	LD	A,(HL)		; Move filename to buffer	CP	' '		;   until space or	JR	Z,DONAM2	;   8 characters	LD	(DE),A	INC	HL		; Bump pointers	INC	DE	DJNZ	DONAM1;DONAM2	LD	A,L		; Point to file extension	ADD	A,B	LD	L,A	LD	A,(HL)		; Is there an extension?	CP	' '	JR	Z,DONAM5	; Bypass if not	LD	A,'/'	LD	(DE),A		; Stuff EXT separator	INC	DE	LD	B,03H		; Init 3 char ext maxDONAM4	LD	A,(HL)		; Transfer up to space	CP	' '		;    or 3 characters	JR	Z,DONAM5	LD	(DE),A	INC	HL	INC	DE	DJNZ	DONAM4DONAM5	LD	A,':'		; Add the drivespec	LD	(DE),A	INC	DE	LD	A,(TSTMPW+1)	; Pick up drivespec	OR	'0'		; Make it ASCII and	LD	(DE),A		;   put in filespec	INC	DE	LD	A,ETX		; Terminate with ETX	LD	(DE),A	PUSH	DE		; Save pointerQPARM	LD	DE,-1		; Query each file?	LD	A,D	OR	E	JP	Z,NOPRMPT	; Not if Q=n;	LD	HL,PRGFIL$	; "Purge file?..."	LD	A,@DSPLY	RST	28H	POP	DE		; Recover ptr to file buf ETX	POP	HL		; Recover ptr to 1st dir byte	PUSH	DE	INC	HL		; Point to MOD flag	BIT	6,(HL)		; Test MOD flag	JR	Z,SCDAT1	; Go if not MOD'd	LD	A,' '		; Put a space	LD	(DE),A	INC	DE	LD	A,'+'		;   and the MOD sign	LD	(DE),A	INC	DESCDAT1	LD	A,' '		; Write a space	LD	(DE),A	INC	DE	INC	HL		; Advance to date field	EX	DE,HL	LD	(HL),'{'	; Stuff left brace	INC	HL	EX	DE,HL	LD	A,(HL)	OR	A	JR	Z,SCDAT4	; Ignore if no date saved	RRCA			; Has date, get day	RRCA	RRCA	AND	1FH	LD	B,'0'-1		; Convert day to decimalSCDAT2	INC	B		; By counting # of tens	SUB	0AH		; Subtract 10 from day #	JR	NC,SCDAT2	ADD	A,3AH		; Convert ones to ASCII	PUSH	AF		; Save day	LD	A,B		; Get tens	LD	(DE),A		; Put in string	INC	DE		; Next position	POP	AF		; Get ones back	LD	(DE),A		; Stuff ones in string	INC	DE		; Bump pointer	LD	A,'-'		; Init separator	LD	(DE),A		; Stuff in string	INC	DE		; Point to month field	PUSH	HL		; Save DIR ptr	DEC	HL		; Point to month	LD	A,(HL)		; Get month byte	AND	0FH		; Strip off flags	DEC	A		; (MON-1)*3 indexes string	LD	C,A		;    conversion table	RLCA	ADD	A,C	LD	C,A	LD	B,00H*LIST	OFF	IFLT	@DOSLVL,'L'	;---> Before changes for 6.3.1L*LIST	ON	LD	HL,MONTBL	; Point to month table*LIST	OFF	ELSE			;---- 6.3.1L*LIST	ON	LD	HL,MONTBL$	; Point to month table in LOWCOREMONTBL$	EQU	04DCH		; in LOWCORE*LIST	OFF	ENDIF			;<--- 6.3.1L*LIST	ON	ADD	HL,BC		; Add offset to month	LD	C,03H		; Move 3 char month	LDIR			;   into string	LD	A,'-'		; Stuff in a separator	LD	(DE),A	INC	DE		; Point to year field	POP	HL		; Get DIR pointer back	LD	C,'8'		; Year for old style dirSVYFLG2	LD	A,($-$)	; Get YFLAG$ entry	BIT	0,A		; Test bit for this driveM2641	EQU	$-1*LIST	OFF	IFLT	@DOSLVL,'L'	;---> Before changes for 6.3.1L*LIST	ON	JR	NZ,NEWDATE	LD	A,(HL)		; Pick up old year field	AND	07H		; Remove day	JR	PUTYR		; Skip past new date stuff;NEWDATE	LD	A,L		; Point to 6.3 year field	ADD	A,11H		; Offset to year field	LD	L,A		; Set it in the pointer	LD	A,(HL)		; Get year	AND	1FH		; Mask off other bitsNEWYLP	CP	0AH		; Is it 1980s?	JR	C,PUTYR		; Go if it is	INC	C		; Make C hold a '9'	SUB	0AH		; Is it 1990s?	CP	0AH		;*LIST	OFF	ELSE			;<--> 6.3.1L*LIST	ON	CALL	GTDIRYR		; Get dir year-1980 in A	LD	C,'8'		; Year for old style dirL2647	CP	10		; Is it 1980s?	JR	C,PUTYR		; Skip if yes	SUB	10		; Subtract 10	INC	C		; Make C hold a '9'	LD	B,A		; Save subtracted year to B	LD	A,C		; Get 10s digit in ANEWYLP	CP	'9'+1		; Is digit > '9' ?	LD	A,B		; subtracted year	JR	NZ,L2647	; Loop if not	LD	C,30H		; Else reset 10s digit to '0'	JR	L2647		; And loop*LIST	OFF	ENDIF			;<--- 6.3.1L*LIST	ON;	Garbage ...	JR	C,PUTYR		; Go if it is	SUB	0AH		; Must be 2000s	LD	C,'0'		; Set C to 0	JR	NEWYLP		;   and loop back for more;;	Put year in string;PUTYR	LD	B,A		; B = decimal ones of year	LD	A,C		; Get tens digit of year	LD	(DE),A		;   and put in string	INC	DE		; Point to ones of year	LD	A,B		; Get	ADD	A,'0'		; Convert to ASCII	LD	(DE),A		; And store it in the string	INC	DE		; Point to next charSCDAT4	LD	A,03H		; Stuff in an ETX byte	LD	(DE),A	LD	HL,FCB1$	; Display filename	LD	A,@DSPLY	RST	28H	LD	HL,QMARK$	; Display "???"	LD	A,@DSPLY	RST	28H	LD	HL,LILBUF$	; Get response (y/n)	LD	BC,3<8	LD	A,@KEYIN	RST	28H	JP	C,BREAK		; Abort on BREAK	LD	A,(HL)		; Get response	RES	5,A		; Force to upper case	CP	'Y'		; Is it Yes?	JP	NZ,SCNHIT	; Bypass if not	EX	(SP),HL		; Place dummy HL below	PUSH	HL		;   pointerNOPRMPT	BIT	0,(IY+'K'-'A')	; Check if BREAK bit in	JP	NZ,BREAK	;   KFLAG$ is active	LD	HL,PURGE$	; "Purging: ..."	LD	A,@LOGOT	RST	28H	POP	HL		; Get pointer to ETX	LD	(HL),CR		; And replace with CR	LD	HL,FCB1$	; Display filename	LD	A,@LOGOT	RST	28H	POP	HL		; Pop dummy or DIRREC ptr	POP	BC		; Get drive and DEC	PUSH	BC	LD	A,B		; Pick up the DEC	LD	(FCB+7),A	; Stuff in FCB	LD	A,(TSTMPW+1)	; Get the drive	LD	(FCB+6),A	; Stuff in FCB, too	LD	A,01H		; Set up FCB for remove	LD	(FCB+1),A	LD	A,80H		; Show FCB as open	LD	(FCB),A	LD	DE,FCB		; Remove the file	LD	A,@REMOV	RST	28H	JP	NZ,IOERR	; Jump on error	LD	A,0FFH		; Show we don't have	LD	(SCNH3A+1),A	;   latest dir record	JP	SCNH1		; Loop;;	Routine to get the master password and match it;TSTMPW	LD	C,$-$		; Init to drive requested	CALL	GATRD		; Read GAT into GATBUF	RET	NZ		; Back on error	LD	HL,(GATBUF+0CEH)	LD	DE,PASSWORD	; Password="PASSWORD"?	XOR	A	SBC	HL,DE	RET	Z		; Yes - back if it's PASSWORD;;	MPW is not PASSWORD - Check for entry match;PWPARM	LD	DE,0		; Pick up MPW str addr	LD	HL,MPW$		; Init prompt	CALL	GETMPW		; Hash param or entry	RET	NZ		; Return on error	EX	DE,HL		; Put hashed MPW in DE	LD	HL,(GATBUF+0CEH) ; Grab disk MPW and	XOR	A		; Check if user entered	SBC	HL,DE		;   the proper MPW	LD	HL,BADMPW$	; Init error pointer	LD	A,63		; Init extended error	RET			; Z or NZ, depending;;	Routine to get 8-char password;GETMPW	CALL	GMPW1		; Test if user entered MPW	RET	NZ	LD	A,0E4H		; Hash password (DE) to HL	RST	28H		; Ret to what calledGMPW1	LD	A,D		; Test if user entered MPW	OR	E	JR	Z,GMPW3		; Prompt if not	INC	A		;   or no operand	JR	Z,GMPW3;;	Place entered password into buffer;	LD	HL,BUFFER	PUSH	HL	LD	B,08H		; Max entry of 8 charsGMPW2	LD	A,(DE)		; Get password char	CP	CR		; End of the line?	JR	Z,GMPW4		; Space out if so	CP	','		; Comma separator?	JR	Z,GMPW4	CP	'"'		; Closing quote?	JR	Z,GMPW4	INC	DE	LD	(HL),A		; Transfer the char	INC	HL	DJNZ	GMPW2		; Loop for 8	JR	GMPW5;;	Not entered as param, grab from keyboard;GMPW3	CALL	CKINDO		; Can't prompt in DO	RET	NZ	LD	A,@DSPLY	; Display request	RST	28H	RET	NZ	LD	BC,8<8		; 8 chars input	LD	HL,BUFFER	; Point to buffer	PUSH	HL	LD	A,@KEYIN	; Get password from user	RST	28H	JP	C,BREAK		; Exit on BREAK	EX	DE,HL		; Buffer start to DE	LD	H,00H		; Buffer len to HL	LD	L,B	ADD	HL,DE		; Point to 1st unused pos	LD	A,08H		; Calculate spaces needed	SUB	B	JR	Z,GMPW5		; Ret if none needed	LD	B,A		; Set counter for spacesGMPW4	LD	(HL),' '	;   and put them in	INC	HL	DJNZ	GMPW4;;	Convert (SP) through (SP+7) to upper case;GMPW5	POP	HL		; Recover pointer to buffer	PUSH	HL	LD	B,08H		; Loop through fieldGMPW6	LD	A,(HL)	CP	'a'	JR	C,GMPW7	CP	'z'+1	JR	NC,GMPW7	RES	5,(HL)		; Force upper caseGMPW7	INC	HL	DJNZ	GMPW6	POP	DE		; Recover ptr to start	XOR	A		; Indicate no error	RET;;	Routine to read the granule allocation table;GATRD	PUSH	DE	PUSH	HL	LD	D,(IY+09H)	; Get DIR cylinder	LD	HL,GATBUF	LD	E,L		; Set to sector 0	LD	A,@RDSSC	; Read GAT sector	RST	28H	POP	HL	POP	DE	LD	A,14H		; Init "GAT Read error"	RET			; Return Z/NZ status;;	Routine to check if DO is active;CKINDO	PUSH	IY		; Save IY	LD	A,@FLAGS	; Get system flags	RST	28H	BIT	5,(IY+'S'-'A')	; Set if DO active	POP	IY		; Recover IY	RET	Z	LD	HL,NOINDO$	; Point to message	LD	A,63		; Extended error	RET;;	Parse file name or extension on the command line;PRSPEC	CP	'*'		; Is it "*"?	JR	NZ,NOTSTAR	; No	LD	A,'$'		; Fill with wildchrsM277F	LD	(DE),A		; Stuff byte;------------------------------------------------------------------	IF	@PWCFIX	INC	DE		; Next position  (pwc 11/24/97)	ENDIF;------------------------------------------------------------------	DJNZ	M277F		; Loop for rest of chars	LD	A,(HL)		;   INC DE before	INC	HL		;   that DJNZ thing?	RET;;	End of 6.3 changes;	Okay, this is what the old code had originally;NOTSTAR	CP	'$'		; Wild character?	JR	Z,PRS2		; Always a match if so;------------------------------------------------------------------	IF	@PWCFIX	CP	'*'		; Rest wild chars?   (pwc 11/24/97)	JR	Z,PRSPEC	; Jump back if so    (pwc 11/24/97)	ENDIF;------------------------------------------------------------------	CP	'A'		; Check on filename	JR	NC,PRS1		; Jump if possible alpha	CP	'9'+1		; Check on "0"-"9"	RET	NC		; Bad if >"9" and <"A"	CP	'0'	RET	C		; Bad if <"0"PRS1	CP	'a'		; Convert to U/C if needed	JR	C,PRS2	CP	'z'+1	JR	NC,PRS2	RES	5,APRS2	LD	(DE),A		; Xfer char to buffer	INC	DE		; Bump destination pointer	LD	A,(HL)		; Get next character	INC	HL		; Bump source pointer	DJNZ	PRSPEC		; Loop 8 max	RET;;	Routine to extract date from directory;UNPACK	LD	A,(HL)		; Get DIR+1 byte	AND	0FH		; Remove flags*LIST	OFF	IFLT	@DOSLVL,'L'	;---> Before changes for 6.3.1L*LIST	ON	LD	E,00H	SRL	A		;	RR	E	LD	D,A		; Save month	INC	HL		; Point to DIR+2	LD	A,(HL)		;	AND	0F8H		; Strip year	RRCA	OR	E	LD	E,ASVYFLG1	LD	A,($-$)		; Test YFLAG$UNPK1	BIT	0,A		; Bit for this drive set?	JR	NZ,UNPK3	; Go if old date	LD	A,(HL)	AND	07H		; Mask off monthUNPK2	RLCA			; Shift year to 5-7	RLCA	RLCA	OR	D		; Merge with month	LD	D,A	RETUNPK3	LD	A,L		; Point to 6.3 year field	ADD	A,11H	LD	L,A		; Save back in pointer	LD	A,(HL)		; Get year	AND	1FH		; Mask off other stuff	JR	UNPK2;;	Pack user date string;PAKDAT	LD	A,(HL)	LD	C,'/'		; Init separator	CALL	PARSDAT		; Parse entry	JR	NZ,BADFMT	; Jump on format error	EX	DE,HL	LD	A,(HL)		; Get year	CP	12		; Is it in range	JR	NC,PAKDA01	; It's fine like it is	ADD	A,100		;   else put it in 2000	LD	(HL),APAKDA01	AND	03H		; Check if leap year	LD	HL,MAXDAYS+1	; Point to Feb days	JR	NZ,PAKDA02	INC	(HL)		; Set Feb to 29 daysPAKDA02	LD	A,(LILBUF$+2)	; Get month	DEC	A	CP	12		; Is it in range?	JR	NC,BADFMT	; Go if too large or 0	DEC	HL		; Point to day	ADD	A,L	LD	L,A	LD	A,H	ADC	A,00H	LD	H,A	LD	A,(LILBUF$+1)	DEC	A	CP	(HL)	JR	NC,BADFMT	LD	HL,LILBUF$+2	LD	B,(HL)	LD	C,00H	SRL	B	RR	C	DEC	HL	LD	A,(HL)	RLCA	RLCA	OR	C	LD	C,A	DEC	HL	LD	A,(HL)		; Get year	SUB	80		; Adjust for offset	JR	NC,M2814	XOR	AM2814	RLCA	RLCA	RLCA	OR	B	LD	B,A	EX	DE,HL	XOR	A	RET*LIST	OFF	ELSE			;<--> 6.3.1L*LIST	ON	LD	B,A		; B contains month	INC	HL		; Point to DIR+2	LD	A,(HL)		; Get year and day	RRCA			; Bring day	RRCA	RRCA	AND	1FH		; Mask off year	LD	C,A		; C contains day	PUSH	BC		; Save month and day	CALL	GTDIRYR		; Get year in a	POP	BC		; Restore month and day	CALL	PKDAT		; Pack YMD to BC	LD	D,B		; Move to DE	LD	E,C	RET			; Done;;	New routine to get year-1980 from directory entry;	IN:	HL = DIR+2;	OUT:	A = Y-1980;GTDIRYR	LD	A,(HL)		; Get day and year from DIR+2	AND	07H		; Keep old style year (0-7)	LD	B,A		; to BSVYFLG1	LD	A,($-$)		; Test YFLAG$UNPK1	BIT	0,A		; Bit for this drive set?	JR	Z,RETOLDY	; Go if old style (ret Y-1980 in A, Cy reset);	New date style	LD	A,L		; Point to DIR+19 = Lev.H+ Date	ADD	A,11H	LD	L,A	JR	GTEXTYR		; Get extended Lev.H+ year	JR	SVYFLG1		; Garbage;;	Pack user date string;PAKDAT	LD	A,(HL)		; Get character	LD	C,'/'		; Init separator	CALL	PARSDAT		; Parse entry	JR	NZ,BADFMT	; Abort on format error	INC	DE		; Point to day	LD	A,(DE)		; Get day	DEC	A		; Day-1	CP	31		; Less than 31?	JR	NC,L27E4	; Jump if yes	LD	C,A		; C=day-1	INC	C		; C=day	INC	DE		; Point to month	LD	A,(DE)		; Get month	DEC	A		; Month-1	CP	12		; Less than 12?L27E4	JR	NC,BADFMT	; Abort if no	LD	B,A		; B=month-1	INC	B		; B=month	DEC	DE		; Point to year	DEC	DE		;	LD	A,(DE)		; Get year	SUB	80		; -80	JR	NC,L27F1	; Skip adjustment if >= 80	ADD	A,100		; Adjust by adding 100L27F1	JP	PKDAT		; Jump to Pack Date routine;;	New routine to get year from dir entry;	IN:	HL = DIR+19, new Lev.H+ date;		B = Old year (can contain (Y-1980)/32;			XORed with (HL)'s bits 0-2);	OUT:	A = Year - 1980;		Cy set to indicate new style;GTEXTYR	LD	A,(HL)		; Get byte	AND	1FH		; Keep bits 0-4 = Lev.H Y-1980	LD	C,A		; Save to C	LD	A,B		; XOR with B	XOR	C		;	AND	07H		; Check bits 0-2	JR	Z,L2817		; Skip if 0 (Old year == Lev.H year); Double-check that DIR+19 does not contain 4296H (def't user password); (not really necessary -- this is not done in LBDIR ...)	PUSH	AF		; Save (Y-1980)/32	LD	A,96H		; Check LSB	CP	(HL)	JR	NZ,L280F	; OK if not 96H	INC	HL	LD	A,42H		; check MSB	CP	(HL)	DEC	HL	JR	NZ,L280F	; OK if not 42H	POP	AFRETOLDY	LD	A,B		; otherwise ret old year	OR	A		; with C reset to indicate old style	RETL280F	POP	AF		; Restore (Y-1980)/32; Unpack new year	RRCA			; Mult by 32	RRCA	RRCA	OR	C		; Combine with low bits (Y-1980)%32	CP	64H		; Less than 100 (2079)?	RET	C		; Return Lev.L Y-1980 if yes (with Cy set)L2817	LD	A,C		; Lev.H Y-1980	SCF			; Cy to indicate new style	RET			; Done	XOR	A		; Garbage	RET*LIST	OFF	ENDIF			;<--- 6.3.1L*LIST	ON;BADFMT	LD	HL,BADFMT$	LD	A,63		; Extended error	OR	A		; Set NZ flag	RET;;	Routine to parse date/time entry;PARSDAT	LD	DE,LILBUF$+2	; Point to buff end	LD	B,03H		; Process three fieldsPRSD1	PUSH	DE		; Save pointer	CALL	PRSD2		; Get a digit pair	POP	DE		; Recover pointer	RET	NZ		; Ret if bad digits	LD	(DE),A		;   else stuff the value	DEC	B		; Dec counter	RET	Z		; Return if done	DEC	DE		; Dec the pointer	LD	A,(HL)		; Check valid separator	INC	HL		; Bump pointer	CP	C		; Check separator	JR	Z,PRSD1		; Loop if match	RET			;   else ret bad (NZ);;	Routine to parse a digit pair;PRSD2	CALL	PRS4		; Get a digit	JR	NC,PRSD3	; Jump if it's bad	LD	E,A		; Multiply by ten	RLCA	RLCA	ADD	A,E	RLCA	LD	E,A	CALL	PRS4		; Get another digit	JR	NC,PRSD3	; Jump if bad	ADD	A,E		; Accumulate new digit	LD	E,A		; Save 2 digit value	XOR	A		; Clear flags	LD	A,E		; Xfer field value	RET			; and returnPRSD3	OR	A		; Set NZ	RETPRS4	LD	A,(HL)		; Get a digit	INC	HL		; bump pointer	SUB	'0'		; Convert to binary	CP	0AH	RET;;	Routine to compare DE to HL;CPHLDE	LD	A,H	SUB	D	RET	NZ	LD	A,L	SUB	E	RET;;	Error processing;PRMERR	LD	A,PAR_ERR	; Parameter errorIOERR	CP	63		; Extended error?	JR	Z,EXTERR	LD	L,A	LD	H,00H	OR	0C0H		; Abbrev & return	LD	C,A	LD	A,@ERROR	RST	28H	JR	SAVESP;;	BREAK handler routine;BREAK	LD	A,@CKBRKC	; Clear break bit	RST	28HERREXIT	LD	HL,-1SAVESP	LD	SP,$-$		; Restore the stack	LD	(RETCODE),HLEXIT	LD	HL,0RETCODE	EQU	$-2	LD	A,@CKBRKC	RST	28H	RETEXTERR	LD	A,@LOGOT	RST	28H	JR	ERREXIT;;	Messages and stuff;NOINDO$	DB	'Invalid command during <DO> processing',CRMPW$	DB	'Master password ?      ',ETXBADMPW$	DB	'Invalid master password',CRMAXDAYS	DB	1FH,1CH,1FH,1EH,1FH,1EH,1FH,1FH,1EH,1FH,1EH,1FHBADFMT$	DB	'Bad date format',CRPRGFIL$	DB	'Purge file: ',ETXQMARK$	DB	'} ?  ',ETXPURGE$	DB	'Purging: ',ETX*LIST	OFF	IFLT	@DOSLVL,'L'	;---> Before changes for 6.3.1L*LIST	ONMONTBL	DB	'JanFebMarAprMayJunJulAugSepOctNovDec'*LIST	OFF	ELSE			;<--> 6.3.1L*LIST	ON;	New routine to pack date;	IN:	A=Year, B=Month, C=Day;	OUT:	BC=(A*16+B)*32+CPKDAT	PUSH	HL	LD	L,A		; L=A=Year	ADD	HL,HL	ADD	HL,HL	ADD	HL,HL	ADD	HL,HL		; *16	LD	A,B		; B=Month	OR	L	LD	L,A		; HL=A*16+B	ADD	HL,HL	ADD	HL,HL	ADD	HL,HL	ADD	HL,HL	ADD	HL,HL		; *32	LD	A,C		; C=Day	OR	L	LD	C,A	LD	B,H		; BC=(A*15+B)*32+C	POP	HL	XOR	A		; Set Z	RET			; Done	DB	'AugSepOctNovDec' ; Garbage*LIST	OFF	ENDIF			;<--- 6.3.1L*LIST	ONBLANKS	DB	'        '	DB	'   'FTFLG	DB	00HFMPAKD	DS	2TOPAKD	DS	2LILBUF$	DS	4FCB1$	DS	27;;	Parameter Table;PRMTBL$	DB	80H		; Ver 6.x table	DB	53H,'INV',0	DW	IPARM+1	DB	53H,'SYS',0	DW	SPARM+1	DB	73H,'MPW',0	DW	PWPARM+1	DB	55H,'QUERY',0	DW	QPARM+1	DB	34H,'DATE',0	DW	DATPRM+1	DB	00HFCB	DS	32;	ORG	$<-8+1<+8;BUFFER	DS	256GATBUF	DS	256HITBUF	DS	256;LAST	EQU	$-1;	END	PURGE