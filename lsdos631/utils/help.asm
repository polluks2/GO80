; ***************************************************************; * Filename: HELP/ASM						*; * Revision: 06.03.01						*; * Rev Date: 05 Dec 97						*; ***************************************************************; * System Help file display utility				*; *								*; ***************************************************************;	TITLE	<HELP/CMD - LS-DOS 6.3>M0000	EQU	0000HM0005	EQU	0005HM0008	EQU	0008HM000D	EQU	000DHM0018	EQU	0018HM164F	EQU	164FHM2000	EQU	2000H;*GET	SVCMAC			; System SVC macros*GET	VALUES			; Misc equates*GET	COPYCOM			; Copyright message;	ORG	2600H;HELP	@@CKBRKC		; Check & clear break	JR	Z,HELPA		; Go if not set	LD	HL,-1		; Set error return	RET;;	Start of HELP routine;HELPA	@@FLAGS			; IY => system flags	LD	A,(IY+OFLAG$)	; Get OPREG$ - mem & vid ctl byte	LD	(SVOPRG),A	LD	A,(IY+TFLAG$)	; Get system type	LD	C,47H		; Model 2 cursor char thing	CP	02H		; Is it model 2?	JR	Z,CHGCURS	; Go if model 2	CP	0CH		; Model 12?	JR	Z,CHGCURS	; Go if 12	CP	10H		; Model 16?	JR	Z,CHGCURS	; Go if 16	;	LD	C,5FH		; Use underline for cursor if Mod 4/4pCHGCURS	LD	B,08H		; Change cursor char & get old	@@VDCTL	LD	(SVCURC),A	; Save old cursor char;;	Scan command line for parameters and such;	LD	IY,OPTBITS	; Options bit array;;	Count the command line characters;	LD	BC,0CNTCLCH	LD	A,(HL)		; Get cmd line char	CP	0DH		; End of line?	JR	Z,CNTCL1	; Done if so	INC	C		; Bump count	INC	HL		; Bump pointer	JR	CNTCLCH		; Loop until done;CNTCL1	LD	A,C		; Get count of cmd line chars	PUSH	HL		; Save cmd line ptr	CP	00H		; None entered?	JP	Z,SAVEVID	; Continue if so	POP	HL		; Recover cmd line ptr	XOR	A		; Clear CF	SBC	HL,BC		; Point back to start	LD	DE,LINEBUF	; Our save location	LDIR			; Move cmd line to it	LD	A,0DH		; Tack CR onto end	LD	(DE),A;;	Scan command line for filename, keyword and parameters;SCANCMD	LD	HL,LINEBUF	; Point to local copySCANCM1	LD	A,(HL)		; Get char	CP	' '		; Space?	JR	NZ,SCANCM2	; Jump if not	INC	HL		; Bump cmd line ptr	JR	SCANCM1		;   and loop for moreSCANCM2	CP	0DH		; ENTER?	PUSH	HL	JP	Z,SAVEVID	; Go if done	CP	'*'		; Scan global for keyword?	JP	Z,SAVEVID	; Go if got it	POP	HL	CP	'('		; Start of parameters?	JR	NZ,PARSEFS	; Skip if not;;	Parse possible command parameter - "(parm)";PRSCMDL	INC	HL		; Bump input pointer	LD	A,(HL)		; Get character	CP	0DH		; Is it enter?	JP	Z,CMDLNDN	; Go one end of line	CP	')'		; End of params?	JP	Z,CMDLNDN	; Go if so	RES	5,A		; Force to upper case;;	Check for (P) - Send output to printer;	CP	'P'		; Print specified?	JR	NZ,CHKVPRM	; Go if not	CALL	PRMTEST		; Test parameter	JP	NZ,PRMERR	; Quit on error	PUSH	HL		; Save cmd pointer	LD	DE,'RP'		; Get *PR DCB	@@GTDCB	EX	DE,HL		; DE => DCB+0	POP	HL		; Get cmd line back	JP	NZ,ERREXIT	; Go on error	LD	C,00H		; Get device status	@@CTL	LD	A,08H		; Init "Device not avail	JP	NZ,ERREXIT	; Go if error	SET	7,(IY+00H)	; Turn on printer flag;;	Check for (V) - turn off video restoration;CHKVPRM	CP	'V'		; (V)ideo specified?	JR	NZ,CHKSPRM	; Go if not	CALL	PRMTEST		; Test parameter	JP	NZ,PRMERR	; Quit on error	RES	6,(IY+00H)	; Reset video flag;;	Check for (S) - Scan partial keyword match;CHKSPRM	CP	'S'		; (S)can specified?	JR	NZ,CHKRPRM	; Skip if not	CALL	PRMTEST		; Test parameters	JP	NZ,PRMERR	; Quit on error	SET	4,(IY+00H)	; Set Scan flag;;	Check for (R) - Turn off reverse video routines;CHKRPRM	CP	'R'		; (R)everse inhibit?	JR	NZ,PRSCMDL	; Not found, loop back	CALL	PRMTEST		; Test parameter	JP	NZ,PRMERR	; Go if error	RES	5,(IY+00H)	; Set reverse vid off	JR	PRSCMDL		; Back for more params;;	Get filespec into FCB, if specified;	And copy it to our save location;PARSEFS	LD	DE,FCB1		; Point to FCB	@@FSPEC			; Get filespec	JP	NZ,CMDLNDN	; Jump if error	SET	2,(IY+00H)	; Flag we found one	PUSH	HL		; Save terminator ptr	PUSH	DE		; Save FCB	LD	BC,LINEBUF	; Get buffer start	XOR	A	SBC	HL,BC		; Get length of filename	PUSH	HL	POP	BC		; Get length into BC	LD	A,08H		; 8 chars is max	CP	C		; User entered MORE??	JR	NC,PARSFS1	; No	LD	BC,8		;   else force 8 charsPARSFS1	LD	HL,SAVFNAM	; Where to save name	EX	DE,HL		; HL=filename, DE=dest	LDIR	LD	A,0DH		; Stuff CR at end	LD	(DE),A	POP	DE		; Get FCB ptr back	POP	HL		; Get cmd line back	BIT	3,(IY+00H)	; Found some help files?	JR	Z,SKIPSPC	; Go if we haven't	LD	HL,KWDBUF	; HL => Keyword buffer	JR	UCASKWD		; Move word into keyword buffer;;	Routine to skip spaces in command line;SKIPSPC	LD	A,(HL)		; Get keyword char	CP	0DH		; Enter?	JP	Z,SAVEVID	; Go if it was	CP	'('		; Start of params?	JP	Z,PRSCMDL	; Yes, go check them	CP	' '		; Space?	JR	NZ,UCASKWD	; No - move word to buffer	INC	HL		; Bump cmd line ptr	JR	SKIPSPC		; and loop until done;;	Force keyword entered to upper case;UCASKWD	PUSH	HL		; Transfer buff ptr to DE	POP	DE	LD	BC,0		; Init counter to 0UCASKW1	LD	A,(DE)		; Get character	CP	'a'		; Convert to upper case	JR	C,UCASKW2	CP	'z'+1	JR	NC,UCASKW2	RES	5,A		; Force upper case	LD	(DE),AUCASKW2	CP	0DH		; Is character Enter?	JR	Z,MOV2KWB	; Yes, done	CP	'('		; Start of params?	JR	Z,MOV2KWB	; Yes, done	INC	C		; Increment count	INC	DE		; Increment pointer	JR	UCASKW1		; Loop until done;;	Move keyword entered into keyword buffer;MOV2KWB	LD	DE,KWDBUF	; Point to keyword buffer	LDIR			; Move chars into it	DEC	DE		; Back up one	LD	A,(DE)		; Get last char of keyword	CP	' '		; Was it space?	JR	Z,MOV2KW1	; Go if it was	INC	DE		; Bump DE past non-spaceMOV2KW1	LD	A,0DH		; Stuff CR into buffer	LD	(DE),A	SET	1,(IY+00H)	; Flag we have keyword;;	Skip over chars until params or end of line found;SKP2PRM	LD	A,(HL)		; Get input char	CP	0DH		; Enter?	JR	Z,SAVEVID	; Go if it was	CP	'('		; Start of params?	JP	Z,PRSCMDL	; Go test if so	INC	HL		; Bump pointer	JR	SKP2PRM		; Loop until done;;	Done with command line;CMDLNDN	BIT	2,(IY+00H)	; Got filename?	JR	NZ,SAVEVID	; Go if not	PUSH	HL		;   else save cmd ptr;;	Save video screen, if necessary;SAVEVID	BIT	6,(IY+00H)	; Vid restore turned off?	JR	Z,M2774		; dont' bother if so	BIT	0,(IY+00H)	; Have screen saved already?	JR	NZ,M2774	; Go if we do	LD	B,06H		; Move screen to buffer	LD	HL,VIDBUF$	; 2K video buffer area	@@VDCTL	LD	B,04H		; Get cursor position	@@VDCTL	LD	(SVCURP),HL	; Save it	SET	0,(IY+00H)	; Set flag saying it's saved;;;M2774	BIT	2,(IY+00H)	; Have file in FCB?	JP	Z,GTHLPFI	; Get list of all /HLP files	LD	HL,HLPEXT$	; Point to /HLP extension	LD	DE,FCB1		; Get FCB	@@FEXT			; Set default extension	LD	B,01H	LD	HL,DISKBUF	PUSH	IY		; Save flag pointer	@@FLAGS			; Get system flag table	SET	0,(IY+'S'-'A')	; Inhibit file open bit	POP	IY		; Get our flags back	@@OPEN			; Attempt to open file	JP	NZ,GTHLPFI	; Get list of all /HLP filesM279A	@@PEOF			; Go to end of file	CP	1CH		; EOF error?M279F	JP	NZ,READERR	; Expect it, others are error	@@BKSP			; Back up two bytes to the	@@BKSP			;   pointer to the directory	JR	NZ,M279F	; Go if problem	CALL	SETUPIO		; Set up file reading registers	CALL	PSN2ADR		; Read address from file and go there	BIT	1,(IY+00H)	; Do we have a keyword to find?	JP	Z,SHOWKWD	; Show available ones if not	BIT	4,(IY+00H)	; Doing a global scan?	JP	NZ,SHOWKWD	; Go if we are scanning;;	Don't have keyword.  Not doing global scan;;	First, force our entry to upper case;	LD	HL,KWDBUF	; Point to keyword bufferM27C1	LD	A,(HL)		; Get char from buffer	CP	0DH		; Done with entry?	JR	Z,M27D3		; Jump if we are	CP	'a'		; Otherwise, convert it to	JR	C,M27D0		;   upper case	CP	'z'+1	JR	NC,M27D0	RES	5,(HL)		; Force upper caseM27D0	INC	HL		; Bump pointer	JR	M27C1		;   and loop until done;;	Loop to read help file keyword entries;	Trying to match string at (HL);M27D3	LD	HL,KWDBUF	; Point to keyword wanted	LD	C,00H		; Init not at end of keywordM27D8	CALL	RDBYTE		; Read a byte	CP	80H		; Check for high bit	JR	C,M27E3		; Go if not set	XOR	80H		; Turn it off	LD	C,01H		; Init found end of keyword in file;M27E3	CP	(HL)		; Compare char with keyword char	JR	NZ,M27F2	; Jump if they're not the same	INC	HL		; Bump pointer to next	LD	A,(HL)		; Get next char	CP	0DH		; Is it Enter?	JR	Z,M280D		; May have found what we wanted	INC	C		; Were we at the end of this entry?	DEC	C	JR	NZ,SKIPADR	; Skip address over address of so	JR	M27D8		;   else go back for more chars;M27F2	JP	NC,SHOWKWD	; Jump if char higher than (HL)	INC	C		; Did we find the end of the keyword in	DEC	C		;   the help file?	JR	NZ,SKIPADR	; Found entry if we did;M27F9	CALL	RDBYTE		; Read a byte	CP	1CH		; End of file?	JP	Z,SHOWKWD	; Go if EOF	CP	80H		; High bit set?	JR	C,M27F9		; Loop back if notSKIPADR	CALL	RDBYTE		;   else skip over address	CALL	RDBYTE	JR	M27D3		; Go back for more;;	Show a help screen entry;M280D	INC	C		; Test high bit flag	DEC	C	JR	Z,M27F9		; Go if not set	CALL	PSN2ADR		; Position to the record	@@CLS			; Clear screen	LD	HL,KWDBUF	; Point to buffer	@@DSPLY			; Display it	BIT	7,(IY+00H)	; Print flag?	JR	Z,DSPLUP	; Go if not set	LD	HL,KWDBUF	; Buffer again	@@PRINT			; Print it;;	Help entry display loop;DSPLUP	CALL	RDBYTE		; Read a byte	LD	C,A		; Store in C	LD	B,04H		; Get cursor position	@@VDCTL	CALL	CHKVPOS		; Check if prompt needed	LD	A,C		; Get char	CP	0CH		; End of entry?	JP	Z,M291D		; Go if it is	CP	7FH		; Toggle reverse video?	JR	NZ,REVSPC	; Skip if not	BIT	5,(IY+00H)	; Reverse video enabled?	CALL	NZ,TGLRVID	; Call sub if it is	RES	0,(IY+01H)	; Set "Last was not hi-bit"	JR	DSPLUP		; Loop back for more;REVSPC	CP	0FFH		; Rev vid and space?	JR	NZ,SHOWCHR	; No, show character	BIT	5,(IY+00H)	; Rev video enabled?	CALL	NZ,TGLRVID	; Call if it is	SET	0,(IY+01H)	; Set "last was hi-bit"	JR	SHOWSPC		; Add a space;;SHOWCHR	CP	80H		; High bit set?	JR	C,M28AE		; Go if not	XOR	80H		; Toggle it off	BIT	0,(IY+01H)	; Bit 7 last time?	JR	NZ,M28C2	SET	0,(IY+01H)	; Set bit 7 found	LD	C,A	@@DSP			; Display character	CALL	PRINTCH		; Print char if (P);;	Add a space and go back for more;SHOWSPC	LD	C,' '		; Output a space, too	INC	HL		; Bump pointer	CALL	CHKVPOS	@@DSP	CALL	PRINTCH	JR	DSPLUP;;;PRINTCH	BIT	7,(IY+00H)	; Print flag on?	RET	Z		; Return if not;	PUSH	BC	LD	A,(PRNCNT)	; Get print char count	CP	81		; End of line yet?	JR	NZ,PRINTC1	; Go if not	LD	C,0DH		; End printer line	@@PRT	LD	A,01H		; Store 1 in char counter	LD	(PRNCNT),APRINTC1	POP	BC		; Get BC back	PUSH	BC	@@PRT			; Print char in C	POP	BC	LD	A,C		; Get char we printed	CP	0DH		; Was it enter?	LD	A,01H		; Init in case it was	JR	Z,PRINTC2	; Go if we printed CR	LD	A,(PRNCNT)	; Get current char count	INC	A		; Increment itPRINTC2	LD	(PRNCNT),A	; Save char count	RET;;	Handle space compression codes;M28AE	BIT	1,(IY+01H)	; Is compressed flag set?	CALL	NZ,M2CC5	; Output a space & reset flag	@@DSP			; Display char	RES	0,(IY+01H)	; Last char not hi-bit	CALL	PRINTCH	JP	DSPLUP		; Back for more chars;;	Got high-bit char, and last time we had one, too;	It must be a space compression code.;M28C2	LD	B,A		; Save char	BIT	1,(IY+01H)	; Compressed flag?	JR	Z,M28CE		; Go if so	RES	1,(IY+01H)	; Reset flag	INC	B		; Bump countM28CE	LD	C,' '		;	INC	HL		; Bump video position	CALL	CHKVPOS		; Check for csr adjust	@@DSP			; Display & print space	CALL	PRINTCH	DJNZ	M28CE		; Loop for # of chars	RES	0,(IY+01H)	; Reset flag	JP	DSPLUP		; Back for next char;;	Adjust cursor position in HL if needed;CHKVPOS	LD	A,L		; Get cursor column position	SUB	79		; Column less than 79?	JR	C,CHKVP1		; Go if okay	LD	L,A		; Adjust column	INC	H		; Point to next lineCHKVP1	LD	DE,22<8!79	; Line 22, col 79 - M164F	OR	A		; Clear carry	PUSH	HL		; Save position	SBC	HL,DE		; Need a prompt?	POP	HL		; Get vid loc back	RET	C		; Return if not needed;;	At end of page;	LD	A,C		; Get char to display	CP	0DH		; Enter?	JR	Z,M2917		; Go if so	CP	0AH		; Linefeed?	JR	Z,M2917		; go of lineefeed	CP	8DH		; CR with high bit?	JR	NZ,CHKVP2	; Go if not	BIT	0,(IY+01H)	; Test if bit 0 set	JR	NZ,CHKVP2	; Go if not else	SET	0,(IY+01H)	;  set bit 0 of ??	SET	1,(IY+01H)	;  and bit 1 if ??	JR	M291C;CHKVP2	LD	A,L		; Get column	CP	79		; 79?	LD	A,C		; Get char to show	JR	Z,M291D		; Go if at 79	RET			;   else return;M2917	LD	A,C		; Get character to display	RES	0,(IY+01H)	; Reset last was hi-bitM291C	XOR	A		; Clear the characterM291D	LD	(SAVCHAR),A	; Store 0 (or 12) in mem	BIT	7,(IY+00H)	; (P)rint specified?	JR	NZ,M2936	; Go if set	LD	B,04H		; Get current cursor pos	@@VDCTL	XOR	A		; Clear carry (and A)	LD	DE,22<8!79	SBC	HL,DE		; Need to wait for a key?	JR	C,M2936		; Skip if we don't	@@KEYM2936	CP	80H		; Break key?	JP	Z,DOEXIT	; Won't be if via (P) test	LD	C,0DH		; Next line on printer	CALL	PRINTCH	RES	2,(IY+01H)	LD	A,(SAVCHAR)	; Get value	LD	C,A		; Store in C	CP	00H		; Was it 0?	JR	Z,M2960		; CLS & back to DSPLUP	CP	0CH		; End of help entry?	JP	Z,M2AD9		; Go if at end;;	Clear the screen, return with char count in C;CLSRET	LD	C,1CH		; Home cursor	@@DSP	LD	C,1FH		; Erase to end of line	@@DSP	LD	A,(SAVCHAR)	LD	C,A	RET;;	CLS & Go back to display loop, getting HL from stack;M2960	LD	HL,DSPLUP	; Where CLS should return to	EX	(SP),HL		; Put it on the stack	JR	CLSRET		; And go clear screen;;;SHOWKWD	BIT	3,(IY+00H)	; Found some help files?	JP	NZ,CONTGS1	; go if set	LD	HL,HELLO$	; Display program name/copr.	@@DSPLY	LD	HL,HLPDIR$	; "Directory for help:"	@@DSPLY			; Display it	BIT	7,(IY+00H)	; Should we print it?	JR	Z,M2982		; Jump if not	@@PRINT			;   else print it, tooM2982	LD	HL,SAVFNAM	; Point to help file nameM2985	LD	A,(HL)		; Get a character	CP	0DH		; Is it enter?	JR	Z,M2994		; Yes, we're done	LD	C,A		; Load char	@@DSP			; Display it	CALL	PRINTCH		; Print if necessary	INC	HL		; Bump input pointer	JR	M2985		; Loop until doneM2994	LD	C,0DH		; New line	@@DSP	CALL	PRINTCH		; And on printer?	EXX			; Swap in file registers	@@PEOF			; Position to EOF	CP	1CH		; At EOF?	JP	NZ,READERR	; Go on error	@@BKSP			; Back up to contents addres	@@BKSP	JP	NZ,READERR	; Quit on error	EXX			; Swap regular regs back in	LD	DE,LINEBUF	; Point to buffer	CALL	PSN2ADR		; Read address and go there	LD	C,00H		; Nothing read from file yet;;	Read directory of help file's keyword entries;M29B7	CALL	RDBYTE		; Read byte from entry	CP	1CH		; End of file?	JP	Z,M2AD9		; Go if soM29BF	CP	80H		; High-bit set?	JR	C,M29C7		; Go if it wasn't	XOR	80H		; Toggle high bit off	JR	M29CCM29C7	INC	C		; Inc count of bytes in name	LD	(DE),A		; Store in buffer	INC	DE		; Bump pointer	JR	M29B7		; Loop back for more;;	End of keyword in "directory" entry found;M29CC	PUSH	AF		; Save char read from file	CALL	RDBYTE		; Read a byte from file	JR	Z,M29DA		; Go if okay	CP	1CH		; At end of file?	JR	NZ,M29DA	; Go if not	POP	AF		; Recover flags	JP	M2AD9		; Done with file - go;M29DA	EXX	@@BKSP			; Backspace input file	EXX	INC	C		; Inc count of bytes read	LD	B,04H		; Get cursor position	@@VDCTL	POP	AF		; Get AF back	LD	(DE),A		; Store char in buffer	BIT	4,(IY+00H)	; Scan global flag?	CALL	NZ,MATCHIT	; Look for match if we are	JR	C,M2A35		; Go if not found;;	Need to space over?;	LD	A,13H		; 19 bytes per entry	SUB	C		; Subtract how many we read	LD	(IY+02H),C	; Save count for later	JR	C,M2A4E		; Go if  more than 19	INC	A	LD	B,A		; # of spaces needed	LD	A,' 'M29FC	INC	DE		; Fill out entry with spaces	LD	(DE),A	DJNZ	M29FC;;	Set next column to display a keyword entry at;	LD	C,14H		; Next column 20 chars from last	ADD	HL,BC		; Next position to display at;;	Check if we're overflowing the keyword screen;	LD	A,H		; Get cursor line	CP	16H		; is it 22?	JR	NZ,M2A26	; Go if not	LD	A,L		; Get cursor column	CP	79		; At end yet?	JR	C,M2A26		; Go if ???;;	Yes, we are overflowing keyword directory screen!;	SET	2,(IY+01H)	; Flag that there are more	LD	B,(IY+02H)	; Get char count into B	LD	HL,LINEBUF	; Point to buffer;;	Loop to display a page of keywords;M2A17	LD	C,(HL)		; Get character	@@DSP			; Display	CALL	PRINTCH		;   and print	INC	HL		; Bump pointer	DJNZ	M2A17		; Loop for # of chars;;;	LD	C,0FFH		; Set flag "Enter keyword or break"	JP	M2AC7		; and jump;;	Display 20 chars worth of buffer;M2A26	LD	B,14H		; 20 chars	LD	HL,LINEBUF	; Point to bufferM2A2B	LD	C,(HL)		; Get char	@@DSP	CALL	PRINTCH	INC	HL		; Bump buff pointer	DJNZ	M2A2B		; Loop for 20 chars;;	Set up for next page of keywords;M2A35	LD	B,03H		; Skip over address and getM2A37	CALL	RDBYTE		;   1st byte of next keyword	DJNZ	M2A37	CP	1CH		; End of file?	JP	Z,M2AD9		; Go if it was	CP	80H		; High bit?	JP	NC,M2AD9	; Go if not	LD	DE,LINEBUF	; Point to buffer	LD	C,00H		; Reset # of chars read	JP	M29BF		; Jump back into keyword display;;;M2A4E	LD	A,L		; Get column	ADD	A,(IY+02H)	; Add curr col	CP	80		; Past end?	JR	NC,M2A95	; Go if higher	LD	B,A		; Get column in B	XOR	AM2A58	ADD	A,14H		; Add 20	CP	B		; At that location?	JR	C,M2A58		; Go if we're not yet	JR	Z,M2A58		; Or exactly there	SUB	B		; Get difference	LD	B,A		;   and save in B	ADD	A,(IY+02H)	; Add in char count	LD	(IY+02H),A	; And save it back	LD	A,' ';;	Stuff buffer with (B) spaces;M2A69	INC	DE	LD	(DE),A	DJNZ	M2A69	LD	B,04H		; Get cursor position	@@VDCTL	ADD	HL,BC		; Add in new position	LD	A,H		; Get line number	CP	16H		; On line 22?	JR	NZ,M2A83	; Go if we're not	LD	A,L		; Get column number	CP	79	JR	C,M2A83		; Go if less than col 79	SET	2,(IY+01H)	; At more than line 22, col 79	JR	M2AC7;M2A83	LD	HL,LINEBUF	; Point to buffer	LD	B,(IY+02H)	; Get # of bytes to showM2A89	LD	C,(HL)		; Get char from buffer	@@DSP			; Display	CALL	PRINTCH		;   and print it	INC	HL	DJNZ	M2A89		; Loop for # of chars	JR	M2A35;;;M2A95	LD	B,04H		; Get cursor position	@@VDCTL	LD	B,00H	LD	C,(IY+02H)	; Get # of chars left to show	ADD	HL,BC		; Will we go too far?	LD	A,H	CP	16H		; See if on line 22	JR	NZ,M2AB6	; Go if not	LD	A,L		; Get column	CP	79		; Still room?	JR	C,M2AB6		; Go if so	SET	2,(IY+01H)	; Say we have more keywords	SET	3,(IY+01H)	PUSH	DE	PUSH	BC	JR	M2AC7;;;M2AB6	LD	C,0DH		; Carriage return	PUSH	DE		; Save DE	@@DSP			; Display it	CALL	PRINTCH		;   and print it	POP	DE		; Get DE back	LD	B,04H		; Get cursor position	@@VDCTL	JR	M2A4E;;;M2AC7	LD	A,C		; Get flag	CP	0FFH		; Set?	JR	NZ,M2AD9	; Go if not	LD	HL,M2BA2	; Get alt place to jump	LD	(M2BA0),HL	; and store in command	BIT	7,(IY+00H)	; (P)rint specified?	JP	NZ,M2B87	; Jump if it wasn't;M2AD9	LD	C,0DH		; Carriage return	CALL	PRINTCH		; Print it	BIT	3,(IY+00H)	; Do we have some /HLP files?	JP	NZ,CONTGS	; Yes, continue global scan;	LD	HL,ENTKWD$	; "Enter keyword	@@DSPLY			; Display it	RES	4,(IY+00H)	; Force global scan off	LD	BC,32<8		; Max 32 chars	LD	HL,KWDBUF	; User input buffer	@@KEYIN	JR	C,DOEXIT	; Quit if break	INC	B		; How many chars entered?	DEC	B	JP	Z,CKMORKW		; Go if user just pressed enter	LD	A,L		; Buffer start	ADD	A,B		; Add in # chars entered	JR	NC,M2B04	; Went past page boundary?	INC	H		; Bump high byte if soM2B04	LD	L,A		; Set L to end of entry	LD	A,0DH		; Terminate with CR	LD	(HL),A	BIT	3,(IY+01H)	; ??	JR	Z,M2B10	POP	DE	POP	DEM2B10	LD	DE,FCB1		; Point to FCB	RES	3,(IY+01H)	; Reset bit	BIT	2,(IY+00H)	; Have file in FCB?	JP	Z,SCANCMD	; Go scan inp buf if not	SET	1,(IY+00H)	; Say we have keyword	JP	M279A;;	Error handler;ERREXIT	LD	L,A		; Error code to HL	OR	0C0H		; Short msg, return	LD	C,A		; Stuff in C for SVC	@@ERROR			; Log error	LD	H,00H		; Set high byte to 0	@@EXIT			; Exit the program;;;DOEXIT	@@CLS			; Clear the screenDOEXIT1	LD	A,(SVOPRG)	; Get old OPREG$ value	BIT	3,A		; Bit 3 set?	JR	NZ,DOEXIT2	; Go if it was	LD	C,11H		; Turn off reverse video	JR	DOEXIT3DOEXIT2	LD	C,10H		; Turn on reverse videoDOEXIT3	@@DSP			; Display appropriate byte	LD	A,(SVCURC)	; Get original cursor char	LD	C,A		; Move for SVC	LD	B,08H		; Change cursor function	@@VDCTL	PUSH	IY		; Save IY	@@FLAGS	POP	HL		; Our flags to HL	BIT	6,(HL)		; Restore video on exit?	JP	Z,DOEXIT5		; Skip if we aren't	LD	B,05H		; Move memory to to screen	LD	HL,VIDBUF$	; Address of saved screen	@@VDCTL	LD	HL,(SVCURP)	; Get cursor position	BIT	1,(IY+'C'-'A')	; @CMNDR executing?	JR	NZ,DOEXIT4	; Go if it is	DEC	H		; Back up 4 lines	DEC	H		;   to put DOS prompt	DEC	H		;   where it was before	DEC	HDOEXIT4	LD	B,03H		; Set cursor position	@@VDCTLDOEXIT5	LD	C,0DH		; Display/print C/R	CALL	PRINTCH	@@CKBRKC		; Clear break bit	LD	HL,0		; Set exit code	@@EXIT			;   and exit HELP;;	Check if there are more keywords to display;CKMORKW	BIT	2,(IY+01H)	; More keywords to display?	JP	Z,SHOWKWD		; No, go back;;	Have 2nd (or 3rd) page of keywords to display;M2B87	@@CLS			; Clear the screen	LD	C,0DH		; print a new line	CALL	PRINTCH	LD	B,(IY+02H)	; Get # of bytes left	LD	HL,LINEBUF	; Point to input buffer	RES	2,(IY+01H)	; Reset more keywords flag	BIT	3,(IY+01H)	JR	NZ,M2BAE	JP	M2A89M2BA0	EQU	$-2M2BA2	LD	HL,M2A89	; Fix where we came from	LD	(M2BA0),HL	; Reset that jump	LD	HL,0	JP	M2A35;M2BAE	RES	3,(IY+01H)	POP	BC	POP	DE	JP	M2A4E;;	Read directory entries of all /HLP files on all disks;GTHLPFI	LD	HL,HLPDBUF	; Dir buffer start	CALL	STUFHLP		; Set HLP into buffer	LD	B,08H		; Init for 8 drivesM2BBF	LD	A,08H		; Start with 0 (8-8)	SUB	B	LD	C,A		; Store drive in C	PUSH	BC		; Save it	@@CKDRV			; Check availability	JR	NZ,M2BD4	; Go if not available	LD	B,03H		; Get DIRRECs matching extension	@@DODIR			; Read it	CALL	FDIREND		; Find end of directory records	CALL	STUFHLP		; Stuff HLP at end of it for next timeM2BD4	POP	BC		; Get BC back	DJNZ	M2BBF		; Loop for all 8 drives	LD	(HL),0FFH	; Stuff an FF at the end	POP	HL		; Recover start of buffer	LD	A,(HL)		; Get DIR+0	CP	2AH	JR	Z,M2C3C		; Go if so	LD	HL,HELLO$	; Welcome message	@@DSPLY	LD	HL,HOWTO$	; How to use help	@@DSPLY	LD	HL,HLPDBUF	; Point to DIR buffer;;	Loop to display category names;SHOCATL	LD	A,(HL)		; Get DIR$+0	CP	0FFH		; At end of the list?	JR	Z,GETUCAT	; Go get category from user	LD	BC,5		; Point to filename	ADD	HL,BC	LD	B,08H		; Init 8 chars for nameSHOCAT2	LD	C,(HL)		; Get char	@@DSP			; Display	INC	HL		; Bump pointer	DJNZ	SHOCAT2		; Loop for 8 chars	PUSH	HL		; Save end of name ptr	LD	B,04H		; Get current cursor pos	@@VDCTL	LD	BC,8	ADD	HL,BC		; Move over 8 spaces	LD	A,L	CP	80		; Past end of line?	JR	C,SHOCAT3	; Go if not	LD	L,00H		; Else position to start	INC	H		;   of next lineSHOCAT3	LD	B,03H		; Move the cursor	@@VDCTL	POP	HL		; Get end of name back	LD	BC,5		; Move over 5 positions	ADD	HL,BC	JR	SHOCATL;;	Get help category from the user;GETUCAT	LD	HL,ENTCAT$	; Enter category (filename)	@@DSPLY			; Display prompt	LD	HL,LINEBUF	; Point to category buffer	LD	BC,32<8		; 32 chars max	@@KEYIN			; Get user input	JP	C,DOEXIT	; Quit if break	INC	B		; Test # of chars entered	DEC	B	JP	Z,DOEXIT	; Go if none	RES	2,(IY+00H)	; Reset file in FCB bit	JP	SCANCMD		; Go scan user entry;;	Have some files.  Set flag & move keyword into buffer;M2C3C	SET	3,(IY+00H)	LD	DE,KWDBUF	; Point to keyword bufferM2C43	INC	HL		; Bump pointer	LD	A,(HL)		; Get next char	CP	0DH		; Was it enter?	JR	Z,M2C4D		; Yes, done with keyword	LD	(DE),A		; Save char in buffer	INC	DE		; Bump keyword buf ptr	JR	M2C43		; Loop back for more;M2C4D	LD	(DE),A		; Stuff CR into keyword buf	LD	HL,HLPDBUF	; HL => /HLP dir buffer;;	Show we're global scanning;SHOGSCN	PUSH	HL		; Save help dir buffer	LD	HL,GSCAN$	; "glob scan in file:"	@@DSPLY	POP	HL		; Get dir buffer back	LD	A,(HL)		; Get char from buffer	CP	0FFH		; At end of file list?	JR	Z,ENDGS		; Go if done with list	LD	BC,5		; Point to the filename	ADD	HL,BC	PUSH	HL		; Save filename ptr	PUSH	HL		; Twice	LD	HL,0<8!24	; Row 0, col 24 - 0018H	LD	B,03H		; Move cursor position	@@VDCTL	POP	HL		; Get filename back	LD	B,08H		; Init 8 chars in nameM2C6F	LD	C,(HL)		; Display category name	@@DSP	INC	HL	DJNZ	M2C6F	POP	HL		; Get filename back	LD	BC,13		; Point to next name	ADD	HL,BC	PUSH	HL		; Save start of next	XOR	A	SBC	HL,BC		; Point to beginning	LD	C,0DH	@@DSP	LD	BC,8		; 8 chars in name	LD	DE,LINEBUF	; Filename buffer	LDIR			; Move it	LD	HL,LINEBUF	; Set HL to buffer	JP	PARSEFS		; "Parse" filespec;;	Ask user if we should continue the global scan;CONTGS	LD	HL,CONTGS$	; Continue global scan?	@@DSPLY	@@KEY			; Get key	CP	80H		; Break?	JP	Z,DOEXIT	CP	0DH		; Enter?	JR	NZ,CONTGS	; Go if notCONTGS1	POP	HL	JR	SHOGSCN;;	Tell the user we're done global scanning;ENDGS	LD	HL,ENDGS$	; "End of global scan	@@DSPLY	RES	3,(IY+00H)	; Reset "found /hlp file" flag	LD	HL,ENTBYE$	; "Press enter to exit	@@DSPLY	RES	2,(IY+00H)	; Reset "have keyword"	RES	1,(IY+00H)	; Reset "have file in FCB	@@KEY			; Get a key	JP	DOEXIT;;	Output a compressed space;M2CC5	PUSH	BC		; Save BC	INC	HL		; Bump pointer	LD	C,' '		; Output a space	@@DSP	CALL	PRINTCH	RES	1,(IY+01H)	; Reset bit	POP	BC	RET;;	Toggle reverse video on or off;TGLRVID	PUSH	BC		; Save BC	BIT	4,(IY+01H)	; Was reverse video on already?	JR	NZ,TGLRV02	; Jump if it was on	LD	C,10H		; Turn on reverse video	SET	4,(IY+01H)	; Set rev vid flagTGLRV01	@@DSP	POP	BC	RETTGLRV02	LD	C,11H		; Turn off reverse video	RES	4,(IY+01H)	; Reset the flag	JR	TGLRV01		; Jump back to display it;;;STUFHLP	LD	DE,HLPEXT$	; Get "HLP" string	LD	B,03H		; Init 3 charsSTUFHL1	LD	A,(DE)		; Get char	LD	(HL),A		; Store in buffer	INC	HL		; Bump pointers	INC	DE	DJNZ	STUFHL1		; Loop for 3 chars	DEC	HL		; Back up buff ptr	DEC	HL	DEC	HL	RET			; Return;;	Find end of directory buffer;FDIREND	LD	A,0FFH		; Init DONE flagFDIREN1	CP	(HL)		; Found it?	RET	Z		; Return if so	INC	HL		;   else bump pointer	JR	FDIREN1		;   and loop until found;;	Check on parameter validity;PRMTEST	INC	HL		; Bump input pointer	LD	A,(HL)		; Get next char	CP	0DH		; Is it enter?	JR	Z,PRMTST1	CP	')'	JR	Z,PRMTST1	CP	','	JR	Z,PRMTST1	LD	A,01H		; Set param error	JR	PRMTST2PRMTST1	DEC	HL		; Adjust pointer back	XOR	A		; Clear A;PRMTST2	INC	A		; Check result of test	DEC	A		;   by setting Z/NZ	RET			; Return with status;;	Set up FCB and Buffer in alternate registers;SETUPIO	EXX			; Get alternate registers	LD	DE,FCB1		; Point to FCB	LD	HL,IOBUFF	; Point to buffer	EXX			; Get normal regs back	RET			;   and return;;	Position file to address stored in next 2 bytes of file;PSN2ADR	CALL	RDBYTE		; Read byte from file	LD	C,A		; Store low order byte in C	CALL	RDBYTE		; Read next byte	LD	B,A		; That would be the high order byte	PUSH	BC		; Push BC	EXX			; Swap alt regs back	POP	BC		; Get position back	@@POSN			; Go to that location	EXX			; Normal regs back	RET	Z		; Return if no error	JP	READERR		;   else read error;;	Read a byte from the input file;RDBYTE	EXX			; Get alternate registers	@@READ			; Read a byte from file	JR	Z,RDBYTE1	; Go if no error	CP	1CH		; End of file?	JR	NZ,RDBYTE1	; Go if not EOF	OR	A		; Set NZ status	JR	RDBYTE2		;   and don't get byteRDBYTE1	LD	A,(HL)		; Get byte from bufferRDBYTE2	EXX			; Swap regs back	RET			;   and return w/status;;	Test buffers at HL and DE for a match;MATCHIT	PUSH	HL		; Save HL and DE	PUSH	DE	LD	DE,LINEBUF	; Buffer 1	LD	HL,KWDBUF	; Buffer 2MCHDEH1	LD	A,(HL)		; Get buf 2 char	CP	0DH		; Enter?	JR	Z,MCHDEH2	; Done if so	LD	B,A		; Save in B	LD	A,(DE)		; Get buf 1 char	CP	B		; the same?	JR	NZ,MCHDEH3	; Go if not	INC	HL		; Bump pointer	INC	DE	JR	MCHDEH1		; Loop for moreMCHDEH2	POP	DE		; Found match - Return NC	POP	HL	RET	NC		; Ret if carry not set	CCF			; else clear carry	RETMCHDEH3	POP	DE		; No match - Return C	POP	HL	RET	C		; Return if carry set	CCF			; else set carry	RET;;	Parameter error occurred;PRMERR	LD	HL,PRMERR$LOGERR	@@LOGOT	LD	(IY+00H),00H	JP	DOEXIT1;;	Error occurred reading input file;READERR	LD	HL,RDERR$	JR	LOGERR;;	Messages and prompts;HELLO$	DB	1CH,1FH,'HELP System'*GET	CLIENTHOWTO$	DB	'   ',10H,' HELP [category] [*] [keyword] [(parameter)] ',11H,0AH	DB	0AH	DB	'Possible syntax combinations:',0AH	DB	0AH	DB	10H,' HELP category '	DB	11H,' Displays list of keywords available in category.',0AH	DB	10H,' HELP category keyword '	DB	11H,' Displays information in category about keyword.',0AH	DB	10H,' HELP *keyword '	DB	11H,' Displays information in each available category about keyword.',0AH	DB	0AH	DB	'Parameters are:',0AH	DB	'   P - Sends output to printer',0AH	DB	'   V - Cancels video restoration',0AH	DB	'   R - Cancels reverse video',0AH	DB	'   S - Lets you enter a partial keyword name. HELP displays a list of all',0AH	DB	'       keywords that begin with the partial name',0AH	DB	0AH	DB	'HELP categories presently on line are:',0DH;HLPDIR$	DB	'Directory for HELP file : ',03HENTKWD$	DB	0AH,'Enter keyword or press <BREAK> to exit: ',03HENTCAT$	DB	0AH,0AH,'Enter category or press <ENTER> to exit: ',03HENTBYE$	DB	0AH,'Press <ENTER> to exit: ',03HPRMERR$	DB	0AH,'Parameter Error - System Aborted',0DHRDERR$	DB	0AH,'Source File Read Error',0DHGSCAN$	DB	1CH,1FH,'Global Search in File: ',03HCONTGS$	DB	0AH,'Press <BREAK> to exit or <ENTER> to continue Global Scan',0DHENDGS$	DB	0AH,'End of Global Scan',0DH;;	Option flags table;OPTBITS	DB	60H	DB	00H	DB	00H;HLPEXT$	DB	'HLP';;SVOPRG	DB	00H		; OPREG$ savedSVCURC	DB	00H		; Original cursor charSVCURP	DW	00H		; Saved cursor positionPRNCNT	DB	01HSAVCHAR	DB	00H;;FCB1	DS	32		;3180H FCB for /HLP file;SAVFNAM	DS	8		;31A0H Place to save name of help file	DB	0DH		;31A8H;LINEBUF	DS	80		;31A9H Save cmd line here (line buffer)	DB	0DH;KWDBUF	DS	66		;31FAH Buffer for keyword entires?	DB	0DH		;323CH;DISKBUF	DS	256		;323DH Disk I/O buffer for file;IOBUFF	DB	00H,0DH		;333DH Buffer 2?VIDBUF$	DS	256*8		;333FH 4K buffer space;HLPDBUF	DB	00H,00H		;3B3FH;	END	HELP