;****************************************************************;* Filename: SYS9/ASM						*;* Rev Date: 30 Nov 97						*;* Revision: 6.3.1						*;****************************************************************;* Extended system debugger					*;*								*;****************************************************************;	TITLE	<SYS9 - LS-DOS 6.3>;*LIST	OFF*GET	SYS5/EQU*LIST	ONLF	EQU	10CR	EQU	13;*GET	COPYCOM;;	ORG	0A0H;SAVONE	DS	1SAVTWO	DS	1	DS	1		; Space for saved byte (1)NXTADR	DS	2NXTBYT	DS	1DSPADR	DS	2AFREG	DS	2		; AF  Register save area	DS	2		; BC	DS	2		; DEHLREG	DS	2		; HL	DS	8		; AF', BC', DE', HL'IXREG	DS	2		; IXIYREG	DS	2		; IYSPREG	DS	1		; SPREGSAV	DS	1PCREG	DS	2		; PC;	ORG	1E00H;SYS9	AND	70H	RET	Z		; Return on zero entry	LD	HL,(EXTDBG$)	; Get hook address	XOR	A		; See if already resident	LD	DE,-ORARET@	ADC	HL,DE		; ADD does not affect Z	RET	NZ		; Return if already resident	LD	HL,(HIGH$)	; Change HIGH$ to provide	LD	(DEBUGE+2),HL	; Stuff last byte used	LD	BC,LAST-DEBUGE	; Room for relocating	XOR	A		;   this module high	SBC	HL,BC	LD	(HIGH$),HL	; Save new HIGH$	INC	HL		; Pt to new entry point	PUSH	HL		; Save it for later	LD	DE,DO@PRT-DEBUGE ; Pt to @PRT caller	ADD	HL,DE		; Add in new offset	EX	DE,HL		; Swap HL and DE	LD	IX,RELTAB	; Point to relocation tableRELP1	LD	L,(IX+00H)	; Move old addr to HL	INC	IX	LD	H,(IX+00H)	INC	IX	LD	A,H		; Done when HL=0	OR	L	JR	Z,RELP2		; Go if done	LD	(HL),E		; Save new address	INC	HL	LD	(HL),D	JR	RELP1		; Loop back for moreRELP2	POP	DE		; Get entry point back	PUSH	DE		; Save it again	LD	HL,DEBUGE	; Point to code	LDIR			; Move it into position	POP	HL		; Get entry point again	LD	(EXTDBG$),HL	; Save it in SYSRES	RET			;    and return;;	Relocation table;RELTAB	DW	REL14,REL01,REL02,REL03,REL04,REL05	DW	REL06,REL07,REL08,REL09,REL10,REL11	DW	REL12,REL13,REL15,REL16,REL17,0;;	Start of extended debugging utility;DEBUGE	JR	NEXT		; Module header thingie	DW	$-$	DB	06H,'EXTDBG'	DW	0,0;;	'n'ext aaaa - position to next relative block;	used in stepping through a program file;	dumped to core in load module format;NEXT	CP	'n'-'0'	JR	NZ,ENTER	LD	HL,(NXTADR)	; init if no further input	CALL	HEXIN@		; Arg aaaa entered?	INC	HL		; Bump from type to length	LD	D,0	LD	E,(HL)		; Get block length	LD	A,E	CP	03H		; LEN=0,1 or 2?	JR	NC,NEX1		; If len=0,1,2 (256-258)	INC	D		;   next block is +257-259NEX1	INC	DE		; Inc past length byte	ADD	HL,DE		; Add length to index	LD	(NXTADR),HL	; Next block	LD	A,L		; Now set up the display	AND	0C0H		; Address	LD	L,A	LD	(DSPADR),HL	RET;;	Enter Hex data into memory;ENTER	CP	'e'-'0'		; 'e'nter <addr>	JR	NZ,LOCATE	LD	HL,(NXTADR)	; Pt to current address	CALL	HEXIN@		; Get new address to enter	LD	(NXTADR),HL	RET	C		; Back on ENTER	JR	NZ,ENT1		; Go if new address	CALL	WR2HEX@		;  else dsply default	CALL	WRSPA@ENT1	LD	A,1EH		; Clear the line	CALL	@DSPENT2	CALL	WR1HEX@		; Set up the display	DEC	HL	LD	A,'-'	CALL	@DSP	EX	DE,HL	CALL	HEXIN@		; Get the modify info	EX	DE,HL	JR	Z,ENT3		; No change if no new data	LD	(HL),E		;   else update byteENT3	RET	C		; Back if ENTER pressed	INC	HL	LD	(NXTADR),HL	; Index to next address	JR	ENT2;;	'l'ocate aaaa,ddLOCATE	CP	'l'-'0'	JR	NZ,TYPE	LD	HL,(NXTADR)	; Default current address	INC	HL	CALL	HEXIN@		; Prompt new address	LD	(NXTADR),HL	JR	NZ,LOC1		; Go if new address	PUSH	AF		; Save flags	CALL	WR2HEX@		; Display default	LD	A,','	CALL	@DSP	POP	AF	LD	A,(NXTBYT)	; Get default byte	LD	L,ALOC1	JR	C,LOC2		; Go if ENTER used	CALL	HEXIN@		;   else get new byte	JR	Z,LOC2		; Go if none entered	LD	A,L	LD	(NXTBYT),A	;   else set byte to find	JR	LOC3LOC2	LD	A,L		; Display byte info	CALL	CV2HEX@LOC3	LD	HL,(NXTADR)	; Set up for search	LD	A,(NXTBYT)	LD	BC,0		; Set loop to 64k	CPIR			; Find a match	RET	NZ		; Back if none	DEC	HL	LD	(NXTADR),HL	; Store new mod addr	LD	A,L	AND	0C0H	LD	L,A	LD	(DSPADR),HL	RET;;	't'ype aaaa - Type ASCII into memory;TYPE	CP	't'-'0'	JR	NZ,VERIFY	LD	HL,(NXTADR)	; Default current address	CALL	HEXIN@		; Prompt for new address	LD	(NXTADR),HL	RET	C		; Back on <ENTER>	JR	NZ,TYP1		; Go if new addr	CALL	WR2HEX@		;   else dsply defaultTYP1	LD	A,1EH		; Clear to end of line	CALL	@DSPTYP2	CALL	WRSPA@	CALL	DSPASC@		; Display current contents	LD	A,'-'	CALL	@DSP	PUSH	HL		; Provide lower/uppper	CALL	GETASC@		;   case entry	POP	HL		;   conversion	RET	C	CP	20H		; Advance on space	JR	Z,TYP5	LD	(HL),A		; Store new infoTYP5	INC	HL	LD	(NXTADR),HL	; Advance the location	JR	TYP2;;	'v'erify aaaa,bbbb,lth - Verify block;VERIFY	 CP	 'v'-'0'	JR	NZ,WORD	LD	HL,(DSPADR)	; 1st default start of dsp	CALL	HEXIN@		; Prompt new start	LD	(DSPADR),HL	JR	NZ,VER1		; Go if address entered	PUSH	AF	CALL	WR2HEX@		;   else display default	LD	A,','	CALL	@DSP	POP	AFVER1	JR	C,VER2		; Jump if ENTER used prev.	LD	HL,(NXTADR)	; 2nd default current mod addr	CALL	HEXIN@		; Prompt new 2nd start	LD	(NXTADR),HL	JR	NZ,VER2		; Go if entered	PUSH	AF	CALL	WR2HEX@		;   else dsply default	LD	A,','	CALL	@DSP	POP	AFVER2	LD	HL,0		; Default length to verify	JR	C,VER3		; Go if ENTER used prev	CALL	HEXIN@		; Get new length	JR	NZ,VER3		; Go if new len entered	PUSH	HL	CALL	WR2HEX@		; Display default len	POP	HLVER3	LD	B,H		; Xfer length to BC	LD	C,L	LD	HL,(DSPADR)	; Set up for compare	LD	DE,(NXTADR)VER4	LD	A,(DE)	CP	(HL)		; Compare the two locations	JR	NZ,VER5		; Go on non-match	INC	DE		;   else incr pointers	INC	HL		;   and loop for length	DEC	BC	LD	A,B	OR	C	JR	NZ,VER4VER5	LD	(NXTADR),DE	; Store non-match or end of	LD	(DSPADR),HL	;   block	RET;;	'w'ord aaaa,dddd - search for word dddd;WORD	CP	'w'-'0'	JR	NZ,PRINT	LD	HL,(NXTADR)	; Default current address	INC	HL		;  but bypass next word	INC	HL	CALL	HEXIN@		; Get new start	LD	(NXTADR),HL	JR	NZ,WOR1		; Go if value entered	PUSH	AF		;   else dsply default	CALL	WR2HEX@	LD	A,','	CALL	@DSP	POP	AF	LD	A,(NXTBYT)	; Get next default	LD	L,A	LD	A,(SAVTWO+1)	LD	H,AWOR1	JR	C,WOR2		; Go if ENTER	CALL	HEXIN@		; Get next value	JR	Z,WOR2		; Go if default	LD	A,L		; Store new value	LD	(NXTBYT),A	LD	A,H	LD	(SAVTWO+1),A	JR	WOR3WOR2	CALL	WR2HEX@		; Display valueWOR3	LD	HL,(NXTADR)	; Start looking here	LD	BC,0		; Init count to 64kWOR4	LD	A,(NXTBYT)	CPIR			; Find first match	RET	PO		; Return if none	LD	A,(SAVTWO+1)	; Get 2nd half of word	CP	(HL)		; Is it a match?	JR	NZ,WOR4		; Continue if not	DEC	HL	DEC	HL		; Pt 1 byte before	LD	(NXTADR),HL	;   and save that address	LD	A,L	AND	0C0H	LD	L,A	LD	(DSPADR),HL	; New display start	RET;;	'p'rint aaaa,bbbb - print memory;PRINT	CP	'p'-'0'		; If command not 'p'	RET	NZ		;   return to SYS5	CALL	HEXIN@		; Get start	RET	Z		; Back if no start addr	PUSH	HL	CALL	HEXIN@		; Get end	EX	(SP),HL	POP	BC		; Start in HL, end in BC	RET	Z		; Back if no end addr	LD	A,L		; Round to multiple of 16	AND	0F0H	LD	L,A	LD	A,0DH		; Send 2 blank lines to	CALL	DO@PRT		;   the printerREL01	EQU	$-2	CALL	DO@PRTREL02	EQU	$-2PRI2	PUSH	HL		; Routine to write HL	LD	A,H		;   as 4 hex digits	RRA	RRA	RRA	RRA	AND	0FH	ADD	A,90H	DAA	ADC	A,40H	DAA	CALL	DO@PRT		; 1st one doneREL03	EQU	$-2	LD	A,H	AND	0FH	ADD	A,90H	DAA	ADC	A,40H	DAA	CALL	DO@PRT		; 2nd one doneREL04	EQU	$-2	LD	A,L	RRA	RRA	RRA	RRA	AND	0FH	ADD	A,90H	DAA	ADC	A,40H	DAA	CALL	DO@PRT		; 3rd one doneREL05	EQU	$-2	LD	A,L	AND	0FH	ADD	A,90H	DAA	ADC	A,40H	DAA	CALL	DO@PRT		; 4th one doneREL06	EQU	$-2	LD	A,' '		;   and 2 spaces	CALL	DO@PRTREL07	EQU	$-2	CALL	DO@PRTREL08	EQU	$-2	JR	PRI4;;	Write a byte in hex;PRI3	JR	PRI2PRI4	LD	A,(HL)	RRA	RRA	RRA	RRA	AND	0FH	ADD	A,90H	DAA	ADC	A,40H	DAA	CALL	DO@PRT		; Output itREL09	EQU	$-2	LD	A,(HL)	AND	0FH	ADD	A,90H	DAA	ADC	A,40H	DAA	CALL	DO@PRT		; Output itREL10	EQU	$-2	LD	A,' '	CALL	DO@PRT		;   and a spaceREL11	EQU	$-2	INC	HL		; Pt to next byte	LD	A,L		; Test multiple of 16	AND	0FH	JR	Z,PRI5	AND	03H		; Space on multiple of 4	LD	A,' '	CALL	Z,DO@PRTREL12	EQU	$-2	JR	PRI4PRI5	LD	A,' '		; Space at end of 16	CALL	DO@PRTREL13	EQU	$-2	POP	HLPRI6	LD	A,(HL)		; Print in ASCII if	CP	' '		;   printable, else	JR	C,PRI7		;   convert to '.'	CP	80H	JR	C,PRI8PRI7	LD	A,'.'PRI8	CALL	DO@PRTREL14	EQU	$-2	INC	HL		; Loop until 16 chars	LD	A,L	AND	0FH	JR	NZ,PRI6	LD	A,0DH		;   then a new line	CALL	DO@PRTREL15	EQU	$-2	PUSH	HL	LD	A,L		; Check if HL is 0000	OR	H	JR	NZ,PRI9		;   is okay > continue	POP	HL	JR	PRI10		; Get out nowPRI9	XOR	A		; Check on finished	SBC	HL,BC	POP	HL	JR	C,PRI3PRI10	LD	A,0DH		; 3 new lines if done	CALL	DO@PRTREL16	EQU	$-2	CALL	DO@PRTREL17	EQU	$-2DO@PRT	PUSH	AF	CALL	@PRT	POP	AF	RETLAST	EQU $	IFGT	$,DIRBUF$	ERR	'Module too big'	ENDIF	ORG	MAXCOR$-2	DW	LAST-SYS9	; Overlay size;	END	SYS9