;BACKUP2/ASM - Mirror Image Backup;*MOD;	CALL	DSTDRV$		; Prompt for dest but	CALL	PMTDST		;   don't test yet	LD	HL,BUF3$	LD	D,L		; Set cyl to 0	LD	E,1		; Read sector 1 for step	CALL	RDSEC		; Read boot	JP	NZ,EXIT3	; Quit on read error	LD	A,(BOOTST$)	; Get boot step rate	LD	L,A	LD	A,(HL)	AND	03H		;   from bits 0-1	LD	(BSMIR+1),A	; Save for later	LD	A,(BUF3$+02H)	; Get dir cylinder	LD	D,A		;   into D	LD	HL,BUF2$	; Use this buffer now	LD	E,L		; Set sector 0	CALL	RDSEC		; Read GAT sector	CP	06H		; Expect error 6	LD	A,14H		; Init GAT read error	JP	NZ,EXIT3	; Abort if not 6	LD	HL,BUF1$+0CEH	; Compare pack names	LD	DE,BUF2$+0CEH	;   and passwords	LD	B,0AH		; 8 + 2CPRID	LD	A,(DE)	CP	(HL)	JR	Z,IDMATCH;; No match - move disk name into message;	LD	HL,BUF2$+0D0H	; Disk name	LD	DE,PACKID$+5	; Move name into	LD	BC,8		;   display msg field	LDIR	LD	DE,PACKID$+20	; Move date into	LD	C,08H		;   message field	LDIR	LD	HL,DIFID$	; "Diff pack ids...	@@LOGOT	@@FLAGS			; If <DO>ing, don't	BIT	5,(IY+'S'-'A')	JR	NZ,PACKNDO	; Abort if JCL going;;	If MPW = "PASSWORD" (or Bit 7 of NFLAG$),;	just query Y,N;	BIT	7,(IY+'N'-'A')	; Test bit 7 of NFLAG$	JR	NZ,PMTYN	; Get Y/N if set	LD	HL,(BUF2$+0CEH) ; Get disk MPW	LD	DE,PASSWORD	; Get hash for "PASSWORD"	XOR	A		; Clear CF	SBC	HL,DE		; Do they match?	JR	Z,PMTYN		; Go get Y/N if so;;	User must enter current disks MPW to proceed;	LD	HL,OLDMPW$	; "What's the old MPW?	LD	DE,0		; Force prompt of message	CALL	GETMPW		; Get user input to match;;	Routine to test master password for match;	EX	DE,HL		; Xfer hashed MPW to DE	LD	HL,(BUF2$+0CEH) ; Get disk MPW	XOR	A		; Clear carry flag	SBC	HL,DE		; Did user enter right MPW?	LD	HL,BADMPW$	; Init "Bad MPW" just in case	JP	NZ,EXIT4	; Abort if no match	JR	$A1		; PW good, continue backup;PMTYN	LD	HL,PMTYN$	; "Backup anyway?	@@DSPLY	LD	HL,LILBUF$	; Prompt to continue	LD	BC,3<8		;   since IDs differ	@@KEYIN	JP	C,ABRTBU	; Quit on break	LD	A,(HL)		; Force upper case	RES	5,A	CP	'Y'		; Was answer yes?	JR	Z,$A1		; Go if soPACKNDO JP	ABRTBU		;   else abort;IDMATCH INC	DE	INC	HL	DJNZ	CPRID;$A1	LD	HL,BUF2$+60H	; Dest lockout table	LD	DE,BUF1$+60H	; Source lockout table	LD	B,60H		; Init to compare 96 posnsCPRLOK	LD	A,(DE)		; Get src lockout byte	CPL			; Reset all used bits	LD	C,A		;   save result	PUSH	DE	LD	A,E		; Position to GAT byte	SUB	60H		;   for that track	LD	E,A	LD	A,(DE)		; Get free/used	POP	DE		; Point back to lockout	AND	C		; Merge non-locked & in use	AND	(HL)		; That must be free on dest	JP	NZ,NOTMIR	;   else "dest disk flawed	INC	DE	INC	HL	DJNZ	CPRLOK		; Loop thru all cyls;;	Dest can take backup, insert HALT for swap test;	CALL	PMTDST		; Prompt dest if needed	LD	HL,BUF3$	; Set up to read	LD	D,L		;   Track 0	LD	E,L		;   Sector 0	CALL	RDSEC	JP	NZ,EXIT3	; Quit on read error	LD	(HL),76H	; Insert HALT to guard	LD	HL,BUF3$	;   against incomplete B/U	CALL	WRSEC	JP	NZ,EXIT3	; Quit on write error	LD	A,(BUF3$+02H)	; Get current dest dir	LD	(STRDIR$+1),A	; Store it for later;;	User source directory track for destination;	CALL	PMTSRC		; Prompt for source	LD	A,(IY+09H)	; Get source dir cyl	LD	(DSTDIR+1),A;;	Calculate the number of sectors per cylinder;	LD	A,(IY+07H)	; Get secs/cyl	LD	B,A		; Save # heads also	AND	1FH		; Mask off heads	LD	C,A	INC	C		; Adjust for 0 offset	XOR	B		; Get # heads	RLCA			; Shift to bits 0-2	RLCA	RLCA	INC	A		; Adjust for 0 offset	LD	B,A		; Init loop counter	XOR	A		; Set sector count to 0	ADD	A,C		; Multiply secs/track	DJNZ	$-1		;   by heads/cyl	BIT	5,(IY+04H)	; If 2 sided diskette	JR	Z,$+3	ADD	A,A		; Double the sector count	LD	(LDCYL4+1),A	; Store in many places	LD	(DUCYL5+1),A	LD	(VECYL4+1),A	LD	(RESMF6+1),A	LD	(RESMF2+1),A;;	Calculate the amount of core mem available;	LD	B,A		; Put sector count in B	LD	HL,0		; Set up to get HIGH$	PUSH	BC		; Save the count	LD	B,L	@@HIGH$			; Get HIGH$	POP	BC		; Recover sector count	INC	HL		; Get highest full page	DEC	H	LD	DE,(BUFFER$)	; Get buffer address	LD	A,H		; Now sub buffer start	SUB	D		;   from the top	LD	C,-1$A2	INC	C		; Count how many cyls	SUB	B		;   will fit in this space	JR	NC,$A2	LD	A,C		; This is the number of full	LD	(LDCYL6+1),A	;   cylinders to move per pass;;	Get source and initialize;	CALL	PMTSRC		; Prompt source if needed	XOR	A		; Init starting cylinder	LD	(LDCYL5+1),A	;   to 0	LD	D,A		; Set current track to 0	CALL	CKSWDD;;	Here each time a new load cycle;LDTKS	LD	HL,(BUFFER$)	; Pt to buffer start	LD	A,D		; Get cylinder to move	LD	(DUCYL+1),A	; Save start for dump cycle;;	Here on each track loaded;LDTKS1	@@CKBRKC		; Check for break	JP	NZ,ABRTBU	;   and abort if so;	PUSH	HL		; Save buffer	LD	H,BUF1$<-8	; Pt to source GAT	LD	L,D		;   for this cylinder	LD	C,(HL)		; Get free/used byte	LD	A,D	ADD	A,60H		; Pt to lockout byte	LD	L,A		; If source track is	LD	A,(HL)		;   locked out, don't	CPL			;   back up up - BUT	AND	C		;   show dest is "in use"	LD	H,BUF2$<-8	; Pt to dest lockout	LD	C,(HL)		; Get dest lockout byte	OR	C		; Merge with source	LD	L,D		; Xfer pattern to FREE	LD	(HL),A		;   field of dest	CP	C	POP	HL		; Recover buffer	JP	Z,LDCYL7	; Go if ignore this track;;	Get source disk and load;	CALL	PMTSRC		; Prompt source if needed	PUSH	HL		; Save buffer	LD	E,00H		; Start at sector 0 of track	PUSH	DE		; Save location	LD	HL,CYL$		; Message posn to hold	CALL	CVTDEC		;   ASCII cylinder number	LD	HL,LDCYL$	; "loading cyl...	@@DSPLY	LD	HL,CYL$		; cyl # in ascii	@@DSPLY	POP	DE		; Now set up to	POP	HL		;   read the cylinderLDCYL2	CALL	RDSEC		; Read a sector	JR	Z,LDCYL3	; Go if no error	CP	06H		; Okay if reading DIR	JP	NZ,EXIT3LDCYL3	INC	H		; Bump buffer and	INC	E		;   sector number	LD	A,ELDCYL4	CP	0		; High sector number	JR	NZ,LDCYL2	; Loop until cyl finishedLDCYL5	LD	A,00H		; Get current cyl	INC	A	LD	(LDCYL5+1),A	; Store next cyl	LD	B,ALDCYL6	LD	A,00H		; Get last for this pass	CP	B		; See if memory full	JR	Z,LDCYL8	;   and go if soLDCYL7	INC	D		; Bump cyl to use	LD	A,D	CP	60H		; Highest track?	JP	NZ,LDTKS1	; If not, do another	LD	A,(LDCYL5+1)	; Were any moved?	OR	A		; Don't dump if not	JP	Z,MOVIDLDCYL8	LD	A,(LDCYL5+1)	; Get last cyl loaded	LD	(VECYL5+1),A	;   and save for VERIFY;;	Get ready to dump to destination;	LD	HL,(BUFFER$)	; Get start of bufferDUCYL	LD	D,00H		; Init starting cylinder;DUCYL1	@@CKBRKC		; Check for break	JP	NZ,ABRTBU	;   and abort if hit;;	Start by making dest GAT bytes;	PUSH	HL		; Save buffer ptr	LD	H,BUF1$<-8	; Pt to source GAT	LD	L,D		;   at current cyl	LD	C,(HL)		; Get free/used byte	LD	A,D	ADD	A,60H		; Get the lockout byte	LD	L,A		;   for this cylinder	LD	A,(HL)	CPL			; Merge non-locked and	AND	C		;   in use bits	LD	H,BUF2$<-8	; Pt to dest GAT	LD	C,(HL)		; Get its lockout byte	OR	C		; Merge in source info	LD	L,D		; Store in dest free/used	LD	(HL),A	CP	C		; Check if any in use	POP	HL	JP	Z,DUCYL6	;   and go if not	CALL	PMTDST		; Set up to write dest disk	LD	E,00H		; Init to sector 0	LD	A,D		; Get current cyl	PUSH	HL		; Save buffer ptr	PUSH	DE		; Save DE	LD	HL,CYL$		; "xxx"	CALL	CVTDEC		; Convert cyl to decimal	LD	HL,DUCYL$	; "Writing cyl...	@@DSPLY	LD	HL,CYL$		; Display cyl number	@@DSPLY	POP	DE		; Get cyl/sec	POP	HL		; Get bufferDUCYL2	LD	A,D		; Get track # & bypass	OR	A		;   if not cyl=0	JR	NZ,DUCYL2B;	IF	@MOD2	LD	A,(BACKUP0)	; Get system flag	OR	A		; System disk?	JR	NZ,DUCYL2B	; Yes, bypass!	ENDIF	OR	E		; Merge to test for sec=2	CP	02H	JR	NZ,CKBOOT	; if not 2, ck 1 or 0	LD	L,0C6H		; Point to backup count	LD	A,(HL)		; Get it	INC	A		; If FFh, leave as is	JR	Z,SET0	DEC	A		; If 00, leave as is	JR	Z,SET0	LD	(HL),0FFH	; Set to FFh	JR	SET0;CKBOOT	AND	0FEH		; Sector 0 or 1?	JR	NZ,DUCYL2B	; Go if not	OR	E		; If sector 0, just	JR	Z,DUCYL2A	;   bother with HALT;;	Keep the boot track step rate;	LD	A,(BOOTST$)	; Get step pointer	LD	L,A		;   & update buffer ptr	LD	A,(HL)		; Get this step rate	AND	0FCH		; Strip off other stuffBSMIR	OR	00H		; Merge with the step	LD	(HL),ASET0	LD	L,00H		; Reset buffer ptr	DB	1		; Ignore next with LD BC,xxDUCYL2A LD	(HL),76H	; Keep HALT in destDUCYL2B LD	A,D		; Get the cyl numberDSTDIR	CP	00H		; Is this the DIR cyl?	JR	Z,DUCYL3	; Go if it is	CALL	WRSEC		; Write non-dir sector	JP	NZ,EXIT3	; Quit on write error	JR	DUCYL4DUCYL3	CALL	WRSYS		; Write DIR sector	LD	A,12H		; Init "Dir write error	JP	NZ,EXIT3	;   and quit if errorDUCYL4	INC	H		; Advancd buffer and	INC	E		;   the sector #	LD	A,EDUCYL5	CP	00H		; At end of the cylinder?	JR	NZ,DUCYL2	; Go if not	LD	A,(LDCYL5+1)	; Count down one more	DEC	A		;   cylinder dumped	LD	(LDCYL5+1),ADUCYL6	INC	D		; Bump cylinder #	LD	A,(LDCYL5+1)	OR	A	JP	NZ,DUCYL1	; Loop if more to do;;	Prepare to verify;	LD	A,(DUCYL+1)	; Get cyl # to start	LD	D,AVECYL1	@@CKBRKC		; Check if break hit	JP	NZ,ABRTBU	; Abort on break;	LD	H,BUF1$<-8	; Pt to source GAT	LD	L,D		;   at current cyl	LD	C,(HL)		; Get free/used byte	LD	A,D	ADD	A,60H		; Pt to lockout byte for	LD	L,A		;   current cylinder	LD	A,(HL)		; Get locked out info	CPL			; Merge locked out and	AND	C		;   the free/used	LD	H,BUF2$<-8	; Point to dest GAT	LD	C,(HL)		; Get lockout for dest cyl	OR	C		; Merge source info	LD	L,D		; Pt to dest free/used	LD	(HL),A		;   and store new value	CP	C		; See if in use	JP	Z,VECYL6	; Skip verify if not	LD	E,00H		; Init to sector 0	PUSH	DE		; Save DE	LD	HL,CYL$		; Location for ASCII	CALL	CVTDEC		; Convert it	LD	HL,VECYL$	; "Verifying...	@@DSPLY	LD	HL,CYL$		; Show cyl #	@@DSPLY	POP	DE		; Get cyl/sec backVECYL2	CALL	VERSEC		; Verify a sector	JR	Z,VECYL3	; Go if no error	CP	06H		; Error 6 is okay	JP	NZ,EXIT3	; Others aren'tVECYL3	INC	E		; Inc sector num	LD	A,EVECYL4	CP	00H		; Check end of cylinder	JR	NZ,VECYL2	; Loop if notVECYL5	LD	A,00H		; Count down another	DEC	A		;   cyl just verified	LD	(VECYL5+1),AVECYL6	INC	D		; Bump cyl # by 1	LD	A,(VECYL5+1)	; Loop if more cylinders	OR	A		;   to verify, else go	JP	NZ,VECYL1	;   back to loading	JP	LDTKS;;	All cylinders backed up, move ID info;MOVID	LD	C,0DH		; Print a new line	@@DSP	LD	HL,BUF1$+0CDH	; Move in the pswd,name	LD	DE,BUF2$+0CDH	;   date,auto buffer	LD	BC,33H		;   & config byte	LDIR	LD	HL,DATFLD$	; Move in today's date	LD	DE,BUF2$+0D8H	LD	C,08H	LDIR;;	Get destination disk and write new GAT;	CALL	PMTDST		; Set up to use dest disk	LD	A,(DSTDIR+1)	; Get DIR cylinder	LD	D,A		; Set to track dir	LD	E,00H		;   sector 0	LD	HL,BUF2$	; Write the GAT back	CALL	WRSYS	LD	A,15H		; Init "GAT write error	JP	NZ,EXIT3	;   and go if bad	LD	HL,BUF3$	CALL	VERSEC		;   else verify GAT	CP	06H		; Expect error 6	LD	A,14H		; Init "GAT read error	JP	NZ,EXIT3	;   and quit if verify bad	LD	A,(DSTDIR+1)	; Get cyl to use for DIR	LD	D,A		; Set track = DIR	LD	E,02H		; Skip GAT and HIT;;	Reset all MOD flags on destination;RESMF	LD	HL,(BUFFER$)	; Use this for sector buffer	CALL	RDSEC		; Read in dir record	CP	06H		; Expect error 6	JP	NZ,DIRERR	; Any other is errorRESMF0	BIT	7,(HL)		; Is it in use?	JR	NZ,RESMF1A	INC	L		; Dir+1 holds MOD flagRESMF1	RES	6,(HL)		; Reset the flag	DEC	L		; Back to DIR+0RESMF1A LD	A,L	ADD	A,20H		; Next dir entry	LD	L,A	JR	NZ,RESMF0	; Loop through all 8	LD	L,00H	CALL	WRSYS		; Write record back out	LD	A,12H		; Init "Dir write error	JP	NZ,EXIT3	; Quit if error	INC	E		; Inc sector #	LD	A,ERESMF2	CP	00H		; Compare highest sec this cyl	JR	NZ,RESMF	; Loop until complete;	IF	@MOD2	LD	A,(STRDIR$+1)	; Get old dir cyl	LD	B,A		; Pass for jump	LD	A,(BACKUP0)	; Get system backup flag)	OR	A		; System disk?	JR	NZ,CNTBAK1	; Yes, check if dir change	ENDIF;;	Clear the HALT instruction from dest;	LD	HL,BUF3$	; Use this buffer	LD	D,L		; Point to BOOT sec	LD	E,L	CALL	RDSEC	JP	NZ,EXIT3	; Quit if couldn't read it	LD	(HL),00H	; Clear the HALT	INC	HL	INC	HL		; Point to old DIR cylSTRDIR$ LD	B,00H		; Get old dir cyl	LD	A,(DSTDIR+1)	; Update the dir cyl	LD	(HL),A		;   in case it changed	DEC	HL		; Back to buffer start	DEC	HL	CALL	WRSEC		; Write back the boot	CALL	Z,VERSEC	;   and then verify it	JP	NZ,EXIT3	; Quit on any error	INC	E		; Point to sector 1	CALL	RDSEC		; Read it	JP	NZ,EXIT3	LD	A,(DSTDIR+1)	; Do the same thing again	INC	HL	INC	HL	LD	(HL),A		; Store new dir cyl	DEC	HL	DEC	HL	CALL	WRSEC		; Write it back	CALL	Z,VERSEC	; Verify it if written okay	JP	NZ,EXIT3	; Quit if we couldn't;CNTBAK1 LD	H,BUF2$<-8	; Destination GAT	LD	A,B		; Get old DIR cyl	ADD	A,60H		; Point to lockouts	LD	L,A	LD	C,(HL)		; Check lockout byte	LD	L,B		; Pt to GAT byte	LD	A,(HL)		; Get GAT byte	OR	C	CP	C		; Anything allocated?	JR	NZ,RESMF2B	; Bypass if yes	LD	A,B		; Save cylinder	LD	HL,BUF3$	; Write E5s to cylinder	LD	DE,BUF3$+01H	;   to remove system DAM	LD	BC,255	LD	(HL),0E5H	LDIR	LD	L,C		; Pt back to BUF3$	LD	D,A		; Set cylinder # in D	LD	E,C		; Start with sector 0	LD	A,(LDCYL4+1)	; Get # of cylinders	LD	B,A		; Set loop counterRESMF2A CALL	WRSEC		; Write normal sector	JP	NZ,EXIT3	INC	E		; Step to next sector	DJNZ	RESMF2A		; Loop for sector countRESMF2B CALL	RESTOR		; Restore to track 0;;	Attempt to clear MOD flags of source;	CALL	PMTSRC		; Set up for source disk	LD	D,(IY+09H)	; Get dir track;	LD	E,02H		; Skip GAT and HITRESMF3	LD	HL,(BUFFER$)	; Use this as buffer	CALL	RDSEC		; Read source sector	CP	06H		; Expect error 6	JP	NZ,DIRERRRESMF4	BIT	7,(HL)		; Is entry an FXDE?	JR	NZ,RESMF4A	; Go if so	INC	L		; Point to flags	RES	6,(HL)		; Reset MOD flag	DEC	L		; Back to DIR+0RESMF4A LD	A,L	ADD	A,20H		; Pt to next DIREC	LD	L,A	JR	NZ,RESMF4	; Loop 8 times/sector	LD	L,00H		; (but it should be, huh?	CALL	WRSYS		; Write back DIR sector	JR	Z,RESMF5	; Go if no error	CP	0FH		; Write protected source?	LD	A,12H		; Init "Dir write error	JP	NZ,EXIT3	; Exit if not WP error	LD	HL,CCMOD$	; "Can't clear mod flags	@@LOGOT	JR	RESMF7RESMF5	INC	E		; Bump sector #	LD	A,ERESMF6	CP	00H		; Compare highest sector	JR	NZ,RESMF3	; Do another if more leftRESMF7	EQU	$;	IF	@MOD4	JP	EXIT1		; Backup is complete	ENDIF;	IF	@MOD2CKWRTK0 LD	A,(BACKUP0)	; Get flag	OR	A		; Anything?	JP	Z,EXIT1		; Nope, go!	CALL	PMTSRC		; Prompt for source	CALL	READ0		; Read cyl 0	JP	NZ,EXIT3	; Quit on error	CALL	PMTDST		; Prompt for dest drive	CALL	FORMAT0		; Format cylinder 0	JP	NZ,EXIT3	; Go on disk error;;	Pass original step rate to new disk;	LD	HL,(BUFFER$)	; Get I/O buffer	INC	HL		; Bump to step rate	INC	HL	INC	HL	LD	A,(BSMIR+1)	; Get step	LD	(HL),A		; Pass to buffer	LD	BC,80H		; Offset to sector 1	ADD	HL,BC		; Point to it	LD	(HL),A		; Pass to buffer	CALL	PMTDST		; Re-fetch DCT	CALL	WRITE0		; Write cylinder 0	JP	NZ,EXIT3	; Go on disk error	CALL	PMTDST		; Fetch DCT	LD	A,(DSTDIR+1)	; Get new dir cyl	LD	(IY+9),A	; Update DCT	CALL	UPGAT0		; Update GAT table	JP	NZ,EXIT3	; Go on disk error	JP	EXIT1		; Program completed	ENDIF;;	Routine to convert cylinder # & message stuff;CVTDEC	LD	E,D		; Move value to DE	LD	D,00H	EX	DE,HL		; Swap DE and HL	LD	B,03H		; 3 char buffer	@@HDEC			; Do it	RET			; and return;;	Abort if destination not mirror image;NOTMIR	LD	HL,NOTMIR$	JP	EXIT4;;;LDCYL$	DB	1DH,'Reading < cylinder ',3DUCYL$	DB	1DH,'Writing > cylinder ',3VECYL$	DB	1DH,'Verifying cylinder ',3CYL$	DB	'000',3NOTMIR$ DB	LF,'Backup aborted, destination not mirror-image',CRDIFID$	DB	'Destination disk ID is different: 'PACKID$ DB	'Name=XXXXXXXX  Date=mm/dd/yy',CROLDMPW$ DB	'  Enter its Master Password or <BREAK> to abort: ',3PMTYN$	DB	'Are you sure you want to backup to it <Y,N> ? ',3;M32C2	DC	64,0		; Patch space;	END