;LBFREE/ASM - FREE command	TITLE	<FREE - LS-DOS 6.3>;TPL	EQU	8		; Tracks per line;*GET	SVCEQU			; SVC call equates*GET	VALUES			; Misc Equates;	ORG	2400H;FREEMAP	EQU	$;	LD	(SAVESP+1),SP	; Save stack pointer	LD	A,@CKBRKC	; Check break key down	RST	28H	SCF			; Set carry	JR	NZ,ABORT	; Jump if BREAK	CALL	FREE		;   else call FREE;;	Exit the program (or abort it) here;EXIT	XOR	AABORT	SBC	HL,HLSAVESP	LD	SP,$-$		; Recover stack pointer	LD	A,@CKBRKC	; Clear break	RST	28H	RET;;	Error handler - display message and abort;IOERR	LD	L,A		; Move error code to HL	LD	H,0	OR	0C0H		; Short error & return	LD	C,A		; Error code to C for SVC	LD	A,@ERROR	RST	28H	JR	SAVESP		; Exit;;	FREE - Display free disk space;FREE	LD	A,@FLAGS	RST	28H;;	Stuff address of SFLAG$ into routine;	LD	DE,SFLAG$	ADD	IY,DE	LD	(SFLAG+1),IY;;	Position to parameters or end of line;	PUSH	HL		; Save command pointerSKPLP	LD	A,(HL)		; Load character	CP	'('		; Parameter(s)?	JR	Z,GETPRMS	; Yes - get them	CP	CR		; End of line?	JR	Z,GETHL		; Yes - get cmd ptr back	INC	HL		; Bump cmd pointer	JR	SKPLP		; Loop back for more;;	Process any parameters if entered;GETPRMS	LD	DE,PRMTBL$	; Point to param table	LD	A,@PARAM	; Parse the params	RST	28HGETHL	POP	HL		; Get cmd line ptr back	JP	NZ,IOERR	; Go on parameter error;;	Anything after FREE command entered?;	LD	A,(HL)		; Get cmd char	CP	'('+1		; End of line?	JR	C,FREE0		; Display lines;;	Get next char if it's a colon;	CP	':'		; Drivespec?	JR	NZ,CKIFDRV	; No - check if numeric	INC	HL		;   else bump pointer	LD	A,(HL)		;   and get next char;;	Convert drive # to binary (if legal) and save;CKIFDRV	SUB	'0'		; Legal drive #?	CP	7+1	JR	C,MAP		; Good - show mapILDRNUM	LD	A,32		; Illegal drive #	JP	IOERR;;	Output a C/R to *PR if output is to *PR;FREE0	LD	HL,(PPARM+1)	; Get P param	INC	L	JR	NZ,FREE0A	LD	C,' '		; Print a space	CALL	PRT	LD	C,0DH		;   then a c/r	CALL	PRTFREE0A	LD	C,00H		; Init drive to :0;;	Is there a disk in the drive;FREE1	PUSH	BC		; Save drive #	LD	A,@GTDCT	RST	28H	LD	A,(IY+00H)	; Drive on line?	CP	0C3H	JR	NZ,NXTDRV	; No - get next drive	LD	A,@CKDRV	; Disk in drive?	RST	28H;;	Check if BREAK was hit;	PUSH	AF		; Save @CKDRV result	CALL	CKBREAK		; Check BREAK	POP	AF;;	Display <No disk> if @CKDRV fails;	JR	Z,DOINF		; Disk in - use header	CALL	NO_DISK		; No - display no disk	JR	NXTDRV		; Get next drive;;	Create header string and display if successful;DOINF	CALL	GETINFO;;	Get next drive number;NXTDRV	POP	BC		; Get drive # back	INC	C		; Next drive	BIT	3,C		; Finished?	JR	Z,FREE1		; No - do this drive	RET			; else finished;;	MAP - Display free space map;MAP	LD	C,A		; Move drive # to C	LD	A,@GTDCT	; Get drive ctl table	RST	28H	LD	A,(IY+00H)	; Get enable/disable	CP	0C3H		; Enabled?	JP	NZ,ILDRNUM	; No - illegal drive	LD	A,@CKDRV	; Disk in drive?	RST	28H	JR	Z,DISKIN	; Good - disk in drive;;	No disk in drive - display message and abort;	CALL	NO_DISK		; Show <no disk>	JP	EXIT		;   and exit;;	Create header/footer strings and output header;DISKIN	CALL	CKBREAK		; Check for BREAK	CALL	GETINFO		; Get GAT, create header	CALL	DISPUND		; Display underline	CALL	CLRLN		; Clear line buffer;;	Transfer "  0-  7" string into line buffer;	LD	HL,MTRK		; Initial track #s	LD	DE,LINBUF	LD	BC,7		; Len track # display	LDIR;;	Point HL to GAT+0, C=cyl-1 (gets INC'd);	LD	HL,GAT		; Point to stored GAT	DEC	C		; Init to cyl-1;;	Loop to display each line of cylinders;NEXTLIN	LD	B,TPL		; Max track per line count	LD	IX,LINBUF+8	; Point to display buffer;;	Bump cyl number and display gran info;DSPSC	INC	C		; Current cylinder	CALL	DFRE		; Display free grans	INC	HL		; Point to next track;;	Finished displaying all the cylinders?;	LD	A,(IY+06H)	; Get max cylinder	CP	C		; Finished?	JR	Z,ENDRET	; Yes - display footer;;	Calculate offset (9-grans/cyl) to next track;	LD	A,(GRANS+1)	; Get grans/cyl	NEG	ADD	A,TPL+1		; Offset to next;;	Add offset to line buffer pointer (IX);	LD	D,00H		; Stuff in DE	LD	E,A	ADD	IX,DE		; Where to dsp next track	DJNZ	DSPSC		; Loop current 6 tracks;;	Finished 8 cylinders - display the line;	PUSH	HL		; Save buffer location	PUSH	BC		; Save current cylinder	CALL	DSPLINE		; Display current line;;	Clear granule display line buffer;	CALL	CLRLN		; Clear line buffer	POP	BC		; Get cyl back to C;;	Change cylinder numbers in line buffer;	CALL	DSPTRK		; Calc new track #s	POP	HL		; Restore GAT pointer	JR	NEXTLIN		; Loop for next line;;	Finished with drive - Display current line;ENDRET	CALL	DSPLINE		; Display tracks in buffer	CALL	DISPUND		; Display underline;;	Display footer message;	LD	HL,FOOTER	; HL => footer message	CALL	DSPMSG		; Display footer string;;	If footer will cause a scroll - wait for key;	LD	A,(CKPAGE+1)	; Get # lines left	CP	02H		; At least 2 lines left?	JR	NC,FRET		; lprint, free to return	CALL	KEY		; Wait for charFRET	LD	(HL),CR		; Scroll	CALL	DSPMSG		; Display line	JP	EXIT;;	Stuff drive number into string header;GETINFO	LD	A,C		; Get drive #	ADD	A,'0'		; Convert to ASCII	LD	(HDRIVE),A	; Stuff in header string;;	Read in the diskettes GAT;	LD	A,@GTDCT	; IY => DCT+0	RST	28H	LD	D,(IY+09H)	; Get directory cyl	LD	E,00H		; Sector zero is GAT	LD	HL,GAT		; Point to GAT buffer	LD	A,@RDSSC	; Read DIR sector	RST	28H	LD	A,14H		; Init to "GAT read error"DERR	JP	NZ,IOERR	; Jump on GAT error	CALL	CKBREAK		; Check for BREAK;;	Read in the diskette's HIT;	INC	E		; Sector 1	INC	H		; HL => HIT buffer	LD	A,@RDSSC	RST	28H	LD	A,16H		; Init to "HIT read error	JR	NZ,DERR		; Go if so	CALL	CKBREAK		; Check for BREAK;;	Get quantity of sectors / granule;	LD	A,(IY+08H)	; Bits 0-4 contain the	AND	1FH		;   # sectors per gran	INC	A		; Adjust for zero offset;;	Convert sectors/gran to K & stuff in string;	PUSH	AF		; Save it first	LD	HL,0		; Set HLA = # sec/gran	LD	DE,FGRAN	; DE => Destination	LD	BC,CVT2D	; Only 2 digits possible	CALL	CALCK2		; Convert to K	POP	AF		; A = secs/gran again	LD	E,A		; Transfer to E;;	 Get number of cylinders in HL;	LD	L,(IY+06H)	; Get # cylinders	LD	H,0	INC	HL		; Adjust for offset;;	Calc quantity of grans per cylinder;	PUSH	AF		; Save sectors/gran	LD	A,(IY+08H)	; Get grans/cyl	AND	0E0H		;   which is in	RLCA			;   bits 7-5	RLCA	RLCA	INC	A		; Adjust for 0 offset	BIT	5,(IY+04H)	; Double sided?	JR	Z,FREE2		; Bypass if one sided	ADD	A,A		; Else double the countFREE2	LD	(GRANS+1),A	; Save # grans/cyl	LD	C,A		; Save in C for @MULT8;;	Calc number of sectors / cylinder;	LD	A,@MUL8		; Multipy E * C	RST	28H;;	A = sectors per cylinder;	PUSH	AF		; Save sec/cyl	PUSH	HL		; Save cylinders;;	File slots available = 256 if more than 32 sectors;	LD	HL,256		; 256 files maximum	SUB	2		; Set a = #secs in dir	CP	32		; More than 32?	JR	NC,FREE3	; Yes - use default of 256;;	Calculate number of directory slots available;	ADD	A,A		; Multiply # of sectors	ADD	A,A		;   in directory by 8	ADD	A,A		;   to get # of slots	LD	L,A		; Stuff in HL	LD	H,0FREE3	LD	(FREE7+1),HL;;	Stuff # entries (in HL) into header string;	LD	DE,HPOSSF	; Destination	CALL	CVT3D		; Convert HL to ASCII	POP	HL		; Get cyl count back	POP	AF		; Get sec/cyl back, too;;	Calculate total # of sectors HL * A;	LD	C,A		; Set C = sec/cyl	OR	A	JR	Z,SKIPMUL	; Don't multiply if zero	LD	A,@MUL16	; Multiply HL * C	RST	28H;;	Convert # of sectors to K and stuff in string;SKIPMUL	LD	DE,HPOSSK	; Destination	CALL	CALCK		; Convert to string;;	Transfer disk name from GAT into string;	LD	HL,GAT+0D0H	; Point to disk name	LD	DE,HNAME	; Destination	LD	C,08H		; 8 chars to move	LDIR;;	Transfer diskette date from GAT into string;	LD	DE,HDATE	; Destination	LD	C,08H		; 8 chars	LDIR			; Transfer it;;	Pt HL to GAT, DE = Free gran count, B = cyls;	LD	HL,GAT		; Point to start of GAT	LD	D,B		; Init gran counter	LD	E,B	LD	A,(GAT+0CCH)	; Get excess cyls	ADD	A,35		; Add in base amount	LD	B,A		; Set loop counter;;	Calculate number of free grans left;FREE4	LD	A,(HL)		; Get GAT byte & setFREE5	SCF			;   carry so bit 7 stays 1;;	Is the granule in use?;	RRA			; Slide gran bit to carry	JR	C,FREE6		; Ignore if in use;;	Free granule - add to free gran count;	INC	DE		; Inc gran countFREE6	CP	0FFH		; End of byte?	JR	NZ,FREE5	; Loop if not;;	Finished with one cylinder - advance to next;	INC	L		; Bump gat pointer	DJNZ	FREE4		; Loop for # of cyls;;	Multiply # grans by sectors per gran;	EX	DE,HL		; Move grans to HL	POP	AF		; Get secs/gran back	LD	C,A		; Put in C for mult	LD	A,@MUL16	; Do HL * C	RST	28H;;	Convert free grans to K and put in string;	LD	DE,FREEK	; Destination	CALL	CALCK		; Convert to ASCII in string;;	Build footer string in case of map;	LD	A,'5'		; Init 5" media	BIT	5,(IY+03H)	; Is it 5"?	JR	Z,FIVEIN	; Yes - use it	LD	A,'8'		;   else set 8"FIVEIN	LD	(FSIZE),A	; Set size into footer;;	Get number of heads from DCT and put in footer;	LD	A,(IY+07H)	; Bits 7-5 = heads	RLCA	RLCA	RLCA	AND	07H		; Mask off other junk	INC	A		; Relative to zero	OR	'0'		; Make it ascii	LD	(FHEADS),A	; Store in footer;;	If this is a hard drive, ignore sides check;	BIT	3,(IY+03H)	; Is it hard?	JR	Z,DOSIDES	; No - check sides;;	Hard drive - overwrite "floppy" in footer;	LD	HL,HARD		; String to write over	LD	DE,FTYPE	; "floppy" in footer	LD	BC,6		; 6 chars	LDIR	LD	HL,RIGID	; HL => "RIGID"	JR	D3		; Xfer to footer;;	Floppy disk - stuff # sides into footer;DOSIDES	LD	A,'1'		; Init to one sided	BIT	5,(IY+04H)	; Get sides from DCT	JR	Z,ONESIDE	; Go if it is	INC	A		; Else make it "2"ONESIDE	LD	(FHEADS),A;;	If floppy is double density, pt HL to string;	BIT	6,(IY+03H)	; Test SDEN/DDEN	JR	Z,FREE7		; Go if single (default)	LD	HL,MDDEN	; DDen message;;	Transfer "Single", "Double" or "Rigid" to footer;D3	LD	DE,FDENS	; Point to destination	LD	BC,6		; 6 chars	LDIR			; Move it;;	Calculate number of free HIT positions available;FREE7	LD	DE,0		; Get possible entries	LD	HL,HIT		; Point to hit tableFREE8	DEC	DE		; Dec count in case of SYS;;	Check SYS slots if this is a data disk;	LD	A,(GAT+0CDH)	; Bit 7 set if data disk	RLCA	JR	C,DATDISK	; Set - ignore SYS check;;	Is this a SYS slot - 00-07 or 20-27?;	LD	A,L		; Get HIT offset	AND	0D8H		; Reserved slot?	JR	Z,FREE9		; Yes - can't use it;;	Not reserved - is the HIT position open?;DATDISK	LD	A,(HL)		; File in use?	OR	A	JR	NZ,FREE9	; Yes - don't bump count;;	Slot not in use - bump free slot count;	INC	DE		; Bump free countFREE9	INC	L		; Bump HIT pointer	JR	NZ,FREE8	; Loop if not through;;	Stuff available files into string;	EX	DE,HL		; Move value to HL	LD	DE,FREEF	; Destination	CALL	CVT3D		; Convert to ASCII;;	Display header string and return;	LD	HL,HEADER	; Point to string	JR	DSPMSG		; Display it and RET;DSPLINE	LD	HL,LINBUF	; Point to line buffer;;	Display message pointed to by HL;DSPMSG	CALL	CKBREAK		; Check for BREAK	CALL	DSPLY		; Display to screenPPARM	LD	DE,$-$		; Get (P) parameter	INC	E	JR	NZ,CKPAGE	; No - check page pause	JP	PRINT		;   else output line to printer;;	Display no disk;NO_DISK	LD	A,C		; Get drive number	ADD	A,'0'		; Convert to ASCII	LD	(NODISKN),A	; Stuff in string	LD	HL,NODISK	; Point to message	JP	DSPMSG		; And display it;;	Decrement lines printed count;CKPAGE	LD	A,22		; Ck for display pause	DEC	A		; Count down	LD	(CKPAGE+1),A	; Save count	RET	NZ		; Return if page not full;;	Printed a full page - reset count to max;	LD	A,23		; Max lines	LD	(CKPAGE+1),A	; Reset to max;;	Do not stop if a <DO> is in effect;SFLAG	LD	A,($-$)		; Get SFLAG$	AND	20H		; DO in effect?	RET	NZ		; Return if so;;	Wait for key - then clear screen;	CALL	KEY		; Wait for key entryCLRLN	LD	A,' '		; Fill it with spacesBUFSTUF	LD	HL,LINBUF	; Point to line buffer	LD	B,79		; 79 chars to clearCLRLN1	LD	(HL),A		; Stuff char in line	INC	HL		; bump line pointer	DJNZ	CLRLN1		; loop	LD	(HL),0DH	; Stuff CR in last position	RET			; Return to caller;;	Check if <BREAK> key was pressed;CKBREAK	LD	A,@CKBRKC	; Check for BREAK	RST	28H	RET	Z		; Return if not set	SCF			; Else set carry	JP	ABORT		; for abort;;	CVTDEC - Convert hext number to decimal ASCII;	CVD2D-CVD4D - Convert to 2, 3 or 4 digits;;	HL => Hex number to convert;	DE => Buffer to receive characters;;CVT2D	LD	B,02H		; 2 char buffer	JR	CVD1CVT3D	LD	B,03H		; 3 char buffer	JR	CVD1CVT4D	LD	B,04H		; 4 char buffer	JR	CVD1CVTDEC	LD	B,05H		; 5 char bufferCVD1	LD	A,@HDEC		; Conversion routine	RST	28H	RET;;	DFRE - Stuff  a cylinder's gran symbols into buffer;DFRE	PUSH	BC		; Save C, curr cyl locGRANS	LD	B,00H		; Get grans/cyl;;	Is this cylinder the directory?;	LD	A,(IY+09H)	; Get dir cyl from DCT	CP	C		; Is it the dir?	JR	Z,DDIR		; Yes - use 'D's;;	Not the directory cyl - use "x", "." & "*";	PUSH	IX		; Save buffer ptr	PUSH	BC		; Save grans/cyl;;	Is the granule in use?;DF1	RRC	(HL)		; Get next granule	LD	A,'x'		; Init to in use	JR	C,DF2		; Set - use 'x';;	Gran isn't in use - stuff a '.' in the buffer;	LD	A,'.'		; freeDF2	LD	(IX+00H),A	; Stuff the character;;	Bump pointer and decrement G/C count;	INC	IX		; Next location	DJNZ	DF1		; Loop through all grans;;	Recover buffer pointer, grans/cyl;	POP	BC		; B = grans/cyl	POP	IX		; IX = start of track;;	Position HL to lockout table;	PUSH	HL		; Save HL	LD	DE,60H		; Offset to lockout	ADD	HL,DE		; Point to it;;	There is no lockout table if hard disk;LO1	BIT	3,(IY+03H)	; Is this a hard drive?	JR	NZ,LO2		; Never mind...;;	Go through lockout and overwrite if locked out;	RRC	(HL)		; Gran locked out?	JR	NC,LO2		; No - bump buff pointer	LD	(IX+00H),'*'	; Else flag as locked;;	Bump buffer pointer and loop until done;LO2	INC	IX		; Next gran dsp location	DJNZ	LO1		; Loop;;	Recover pointers and return;	POP	HL	POP	BC	RET;;	DDIR - Use "D"s for directory instead of 'x';DDIR	LD	(IX+00H),'D'	; Stuff in a "D" char	INC	IX		; Loop through all DIR grans	DJNZ	DDIR	POP	BC	RET;;	DISPUND - Display a line of "-";DISPUND	LD	A,'-'		; Character to display	CALL	BUFSTUF		; Stuff line	JP	DSPLINE		; And display it;;	DSPTRK - Stuff cylinder numbers into line buffer;DSPTRK	PUSH	DE		; Save registers used	PUSH	BC;;	Stuff starting cylinder # in line buffer;	LD	DE,LINBUF	; Display buffer	INC	C		; Bump to next cylinder	CALL	DSPTK4		; Display cylinder number;;	Is this the only cylinder in the line?;	LD	A,(IY+06H)	; Get max cylinders	CP	C		; Are we at the top?	JR	Z,DSPTK3	; Go if we are;;	More than one cyl - stuff "-" in buffer;	PUSH	AF		; Save max cyl	LD	A,'-'		; Stuff this char	LD	(DE),A		; Right here	POP	AF		; Get cyl back;;	Get ending cylinder for this line in C;	INC	DE		; Adjust line pointer	LD	B,TPL-1		; Need 7 more on a line;DSPTK1	INC	C		; Bump until 7 or max	CP	C	JR	Z,DSPTK2	DJNZ	DSPTK1;;	Stuff ending cylinder number into line buffer;DSPTK2	CALL	DSPTK4		; Stuff ending cyl on lineDSPTK3	POP	BC		; Recover registers	POP	DE	RET			; Return to caller;;	Convert cylinder # (C) to ASCII at DE;DSPTK4	LD	L,C		; Move cylinder to HL	LD	H,0	PUSH	BC		; Save cyl num	CALL	CVT3D		; Conver to ASCII	POP	BC	RET;;	CALCK - Calculate # of K and stuff in string;;	HLA = Total # of sectors;	DE = Destination string;CALCK	LD	BC,CVTDEC	; 4 digit defaultCALCK2	LD	(CONVERT+1),BC	; Save itDIVHLA	LD	H,L		; Per disk pack	LD	L,A	SRL	H		; Divide total sectors	RR	L		;   by 4 to calculate	SRL	H		;   space in K	RR	L;;	Convert K free (HL) to ASCII and put in string;	PUSH	AF		; Save offsetCONVERT	CALL	$-$		; Call the right one	POP	AF		; Recover offste;;	Stuff hundredths value into string;	INC	DE		; Go past decimal point	AND	03H		; Modulo 4	ADD	A,A		; Multiply by 2	LD	B,00H		;   to position to	LD	C,A		;   hundredths string	LD	HL,HUNDTAB	; Point to table	ADD	HL,BC		;   at the correct position	LD	C,02H		; 2 chars to move	LDIR			; Put it into the string	RET;;	KEY/DSP/DSPLY/PRT/PRINT - SVC routine handlers;KEY	LD	A,@KEY		; Wait for key	DB	11H;DSP	LD	A,@DSP		; Display a byte	DB	11H;DSPLY	LD	A,@DSPLY	; Display a string	DB	11H;PRINT	LD	A,@PRINT	; Print a string	DB	11H;PRT	LD	A,@PRT		; Print a byte;DO_OUT	RST	28H		; Do SVC and check error	RET	Z	JP	IOERR;;	Messages;MDDEN	DB	'DOUBLE'RIGID	DB	'RIGID 'HARD	DB	'Hard  'MTRK	DB	'  0-  7';;HEADER	DB	'Drive :'HDRIVE	DB	'd  'HNAME	DB	'diskname  'HDATE	DB	'dd/mm/yy   Free Space ='FREEK	DB	'nnnnn.nnK/'HPOSSK	DB	'nnnnn.nnK  Files = 'FREEF	DB	'ddd/'HPOSSF	DB	'ddd',0DHFOOTER	DB	'Type =>  'FSIZE	DB	's" 'FTYPE	DB	'Floppy    Heads = 'FHEADS	DB	'n   Density = 'FDENS	DB	'SINGLE   Note - 1 Position = 'FGRAN	DB	'nn.nnK',CR;NODISK	DB	'Drive :'NODISKN	DB	'd  [No  Disk]',0DH;HUNDTAB	DB	'00255075';;	Parameter Table;PRMTBL$	DB	80H		; Ver 6.x @PARAM	DB	41H	DB	'P'	DB	00H	DW	PPARM+1	DB	00H;	ORG	$<-8+1<+8;GAT	DS	256HIT	DS	256LINBUF	EQU	$	END	FREEMAP