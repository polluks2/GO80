;****************************************************************;* Filename: SYS2/ASM						*;* Rev Date: 30 Nov 97						*;* Revision: 6.3.1						*;****************************************************************;*  Several file and device related routines			*;*								*;****************************************************************	TITLE	<SYS2 - LS-DOS 6.32>;;	This SYS module performs the following functions:;	- OPENs an existing file or device;	- INITs a new file;	- Checks availability of an specified drive;	- Hashes an 11 byte field (filename and extension);	- Hashes an 8 byte field (password);	- Renames a filespec/devspec;	- Gets the address of a device control block;CR	EQU	13*LIST	OFF*GET	SYSRES/EQU*LIST	ON*GET	COPYCOM;	ORG 1E00H;SYS2	AND	70H		;Strip all but entry	RET	Z		;Back on zero entry	CP	10H		;Check for OPEN	JP	Z,OPEN	CP	20H		;Check for INIT	JP	Z,INIT	CP	70H		;Check for rename	JP	Z,RENAME	CP	30H		;Get a DCB?	JR	Z,GTDCB	CP	40H		;Drive availability?	JR	Z,CKDRV	CP	60H		;Check password hash	JR	Z,HASHPSWD;;	Routine to hash a file name;;	HL => Pointer to 11 char buffer w/ filename;	A  <= returns with file's hash code;HASHNAME	LD	B,0BH		;Init for 11 chars	XOR	A		;Clear for startHNAME1	XOR	(HL)		;Modulo 2 addition	INC	HL		;Bump to next char	RLCA			;Rotate bit structure	DJNZ	HNAME1		;  & loop for field len	OR	A		;Do not permit a zero	JR	NZ,HNAME2	;  hash code	INC	AHNAME2	LD	(FILEHASH),A	;Stuff code for later	RET;;	Hash a password;;	DE => Pointer to 8 char buffer w/ password;	A  <= returns with password hash code;HASHPSWD	LD	HL,0007H	;Hashing will be from	ADD	HL,DE		;  right to left so	EX	DE,HL		;  point to lo-order	LD	HL,0FFFFH	;Init shift reg to 1s	LD	B,08H		;Init for 8 char stringHPSWD1	LD	A,(DE)		;Get next byte	PUSH	DE		;  & save pointer	LD	D,A	LD	E,H	LD	A,L		;Modulo 2 add bits 0-2	AND	07H		;  to bits 4-6 of the	RRCA			;  16-bit shift register	RRCA	RRCA	XOR	L	LD	L,A		;Shift shift-register	LD	H,00H		;  left by 4 bits to	ADD	HL,HL		;  isolate bits 4-7	ADD	HL,HL	ADD	HL,HL	ADD	HL,HL	XOR	H		;Mod 2 add SR bits 4-7	XOR	D		;Mod 2 add new byte	LD	D,A		;Save tempy for hi order	LD	A,L	ADD	HL,HL	XOR	H	XOR	E	LD	E,A	EX	DE,HL		;SR result to HL	POP	DE		;Get pointer to string	DEC	DE		;  & point to next byte	DJNZ	HPSWD1		;Loop for field length	XOR	A	RET;;	Routine to locate a Device Control Block;GETDCB	LD	E,(IX+01H)	;Get the 2 character	LD	D,(IX+02H)	;  Device nameGTDCB	LD	HL,KIDCB$	;Point to 1st DCBDEV1	PUSH	HL	LD	A,L		;Point to device	ADD	A,06H		;  name field	LD	L,A	LD	A,(HL)		;Get 1st char of name	INC	L		;Point to 2nd	CP	E		;Compare for match	JR	NZ,DEV2		;No match? then loop	LD	A,(HL)		;1st matches, does 2nd?	CP	D	JR	NZ,DEV2		;Loop if no match	POP	HL		;Get start of DCB	RETDEV2	POP	AF		;Pop last DCB start	INC	L		;Inc to start of next DCB	JR	NZ,DEV1		;Bypass if not at end;;	Device not found in tables;	LD	A,08H		;"Device not available"	OR	A	RET;;	Check a drive for availability;CKDRV	PUSH	IY		;We use IY in disk I/O	CALL	@GTDCT		;Get driver routine addr	LD	A,(IY+00H)	;Get drive vector	CP	0C3H		;Check for enabled	JP	NZ,CKDR5	;Bypass if disabled	PUSH	HL	PUSH	DE	BIT	3,(IY+03H)	;Test for HARD drive	JR	NZ,CKDRV1A	;If so, bypass range check	LD	A,(IY+06H)	;Make sure current	CP	(IY+05H)	;  cylinder is in range	JR	NC,CKDRV1	;Go if in range	CALL	@RSTOR		;Restore drive	JP	NZ,CKDR7A	;Go if error;CKDRV1	LD	D,(IY+05H)	;Get current track	LD	E,00H		;Set for sector 0	CALL	@SEEK		;Set track info to FDC	JP	NZ,CKDR7A	;Go if errorCKDRV1A CALL	@RSLCT		;Wait until not busy	JP	NZ,CKDR7A	;Not there - ret NZ	BIT	3,(IY+03H)	;If hard drive, bypass	JR	NZ,CKDR2B	;  GAT data update	BIT	4,(IY+04H)	;If "alien" bypass	JR	NZ,CKDR2B	;  test of index pulses	LD	A,(FDDINT$)	;Check 'SMOOTH' state	OR	A	LD	A,09H		;Set MSB of count down	JR	Z,INTRON	;Go if not SMOOTH	SRL	A		;Divide the count by 2	DIINTRON	LD	(CDCNT+1),A	;Store in LD H instruction	LD	HL,0020H	;Set up count (short);;	Test for diskette in drive and rotating;CKDR1	CALL	INDEX		;Test index pulse	JR	NZ,CKDR1	;Jump on index	BIT	7,(IY+04H)	;Check CKDRV inhibit bit	JR	NZ,CKDR2B	;If on, skip index testCDCNT	LD	H,00H		;CKDRV counter (long) set aboveCKDR2	CALL	INDEX		;Test index pulse	JR	Z,CKDR2		;Jump on no index pulse	EI			;OK for INTs now	LD	HL,0020H	;Index off wait (short)CKDR2A	CALL	INDEX		;	JR	NZ,CKDR2A	;Jump on index;;	Diskette is rotating;CKDR2B	PUSH	AF		;Save FDC status	CALL	@DIRCYL		;Get directory track in D	LD	HL,SBUFF$	;Point to HIT buffer	LD	E,L		;Sector 0 for GAT	CALL	@RDSSC		;Read the GAT	JR	NZ,CKDR7	;Jump on error	LD	DE,(SBUFF$+0CCH) ;Get excess tracks	LD	A,C	RLCA	RLCA	RLCA	OR	0C6H	BIT	3,D	JR	NZ,M1F03	XOR	40HM1F03	LD	(M1F0B+1),A	LD	HL,0082HM1F0B	RLC	B	BIT	3,(IY+3)	JR	NZ,CKDR3	LD	A,22H		;Add offset	ADD	A,E	LD	(IY+06H),A	;Max track # to DCT	RES	5,(IY+04H)	;Set side 0	BIT	5,D		;Test double sided	JR	Z,CKDR3		;Jump if only single	SET	5,(IY+04H)	;Set for side 2CKDR3	POP	AF		;Recover FDC statusCKDR3A	RLCA			;Shift write prot to 7	OR	(IY+03H)	;Merge soft WP bit	AND	80H		;Strip all but 7	LD	(OPNCB9+1),A	;Save WP status for OPNCB	ADD	A,A		;Write prot to carry flag;CKDR4	EI	POP	DE	POP	HLCKDR5	POP	IY	RETINDEX	LD	A,H	OR	L	JR	Z,CKDR7	DEC	HL	CALL	@RSLCT	BIT	1,A	RETCKDR7	POP	AF;CKDR7A	OR	A		;Set NZ return	JR	CKDR4		;  and exit;;	OPEN a device;	Device Control Blocks are from 0208h to 02ffh;DEVOPEN CALL	GETDCB		;Find the DCB named	RET	NZ		;  in the IX pointer;;	Found the needed Device Control Block;DEV4	LD	B,H		;Xver DCB vector to BC	LD	C,L	PUSH	IX		;User DCB to HL	POP	HL	LD	(HL),10H	;Show routed	INC	HL	LD	(HL),C		;Stuff DCB vector	INC	HL	LD	(HL),B	INC	HL	XOR	A		;Zero next 3 bytes	LD	(HL),A	INC	HL	LD	(HL),A	INC	HL	LD	(HL),A	INC	HL	LD	(HL),E		;Stuff DCB name	INC	HL	LD	(HL),D	RET;;;	OPEN a file;	HL <- Address of a 256 byte buffer;	DE <- Address of a 32 byte FCB;	 B <- Logical record length (LREC);OPEN	CALL	LNKFCB@		;Set up link to DCBOPEN1	LD	A,(SFLAG$)	;Stuff current sys flag	LD	(OPEN14+1),A	;  to check later then	AND	0F8H		;  remove bits 0,1 and 2	LD	(SFLAG$),A	LD	A,(IX+00H)	CP	'*'		;If name starts with "*"	JR	Z,DEVOPEN	;  it is a device spec	LD	A,B		;Get LRL requested	LD	(LREC$),A	LD	(OPNCB4+1),HL	;Stuff disk I/O buffer	PUSH	IX		;Transfer the filespec	POP	HL		;  into the system	CALL	XFRSPEC		;  buffer area	RET	NZ		;Return if bad name	LD	HL,NAME$EXT	;Point to name/ext field	CALL	HASHNAME	;  & hash it (11 chars)	LD	DE,PSWDBUF	;Point to the password	CALL	HASHPSWD	;  & hash it, too	LD	(PW$HASH1),HL	;Stuff owner password	LD	(PW$HASH2),HL	;Stuff user passwordOPEN2	LD	A,00H		;Get drive (ff-07)	LD	C,A	INC	A		;Jump if :d entered	JR	NZ,OPEN3	LD	C,AOPEN3	CALL	CKDRV		;Drive available?	JR	NZ,OPEN6	;Jump if not	CALL	@HITRD		;Get hash index table	RET	NZ		;Return if read error;;	Compare hashed filename/ext with each entry;	in the HIT to see if file is on this drive;OPEN4	LD	A,(HL)		;Bypass HIT entry if	OR	A		;  unused	JR	Z,OPEN5	PUSH	HL		;Not vacant	LD	HL,FILEHASH	;Point to DEC	CP	(HL)		;Compare with HIT entry	POP	HL	JR	Z,OPEN9		;Jump if a match elseOPEN5	INC	L		;  bump to next entry	JR	NZ,OPEN4	;Loop until 256 bytes;;	File not on this drive;OPEN6	CALL	TESTDRV		;Bump drive if we can	JR	C,OPEN3		;Loop if another to testOPEN7	LD	A,24		;File not found error	OR	A	RETTESTDRV LD	A,(OPEN2+1)	;If drive still 0FFH	INC	A		;  then advance to next	OR	A		;Reset carry for ret w/o	RET	NZ		;  affecting Z/NZ result	INC	C		;Bump drive counter	LD	A,C	CP	08H		;Loop end, 8 max	RET;;	Although the HIT entry matched, the filename/ext;	did not (due to a collision).  Continue to scan;	the rest of the hash index table.;OPEN8	POP	BC		;Remove ret address	POP	HL		;  and excess regs	POP	BC	CALL	@HITRD		;Re-read the HIT	POP	HL	RET	NZ		;Go on i/o error	JR	OPEN5;;	The hashed name exists, read the directory;OPEN9	PUSH	HL	PUSH	BC	LD	B,L		;Set up the DEC	CALL	@DIRRD	JR	Z,OPEN10	;Jump if no error	POP	BC		;  else pop returns	POP	HL	RET			;  & exit;;	Verify that directory entry is this file;OPEN10	PUSH	HL	PUSH	BC		;Save drive (reg C);;	If bit 7 is set, it denotes an extended;	directory entry whch does not include;	the filename.  Go to next HIT entry if set.;	BIT	7,(HL)		;Test for FXDE	JR	NZ,OPEN8	;Jump if extended	BIT	4,(HL)		;If DIR record spare,	JR	Z,OPEN8		;  continue the search	LD	A,05H		;Point to filename/ext	ADD	A,L		;  field in directory	LD	L,A	LD	DE,NAME$EXT	;Point to entered name	LD	B,0BH		;Init to check 11 charsOPEN11	LD	A,(DE)		;Verify a match	CP	(HL)		;  or no match	JR	NZ,OPEN8	;Go to next HIT entry	INC	HL		;  if no match, else bump	INC	DE		;  pointers and then loop	DJNZ	OPEN11	POP	BC		;Matches!  Get drive #	LD	A,C		;  & stuff it	LD	(OPEN2+1),A	POP	HL	POP	AF	POP	AF	PUSH	BC		;Save DEC and drive	PUSH	HL		;Save ptr to dir record	LD	A,(HL)		;Get 1st byte of dir rec	LD	(DIR$INIT),A	;Stuff it	AND	07H		;Strip all but protection	LD	C,A	LD	B,00H	LD	A,10H		;Point to update password	ADD	A,L	LD	L,A	LD	DE,(PW$HASH2)	;Get password hash	LD	A,(HL)		;Get owner pwrd lo-byte	INC	HL	PUSH	HL	LD	H,(HL)		;Get owner pwrd hi-byte	LD	L,A	LD	A,(NFLAG$)	;Get NFLAG	BIT	7,A		;Check network active bit	JR	Z,USEPWD	LD	D,H	LD	E,LUSEPWD	XOR	A		;Compare password entry	SBC	HL,DE		;  with owner password	POP	HLWASMAT	JR	Z,OPEN16	;Grant access if match	LD	A,C		;Recover protection	CP	07H		;Abort if "no access"	JR	NZ,OPEN13	POP	HL	POP	BC	LD	A,25		;"File access denied"	OR	A	RET;;	Check if protection is Exec Only;OPEN13	LD	A,C	CP	06H		;Check for exec only	JR	NZ,OPEN16	;Jump if notOPEN14	LD	B,00H		;Get SFLAG$ entry state	BIT	2,B		;Did RUN request open?	JR	Z,OPEN15	;Bypass if NOT from run	LD	HL,SFLAG$	SET	1,(HL)		;Show RUN & EXEC file	LD	A,05H		;Set read access for nowOPEN15	LD	HL,SET@EXEC	;Set RST vector to turn	LD	(HL),0C9H	;  off debugOPEN16	LD	(OPNCB1+1),A	;Stuff access level	POP	HL		;ptr to direc record	POP	BC		;get DEC and drive;;	Routine to open up the fcb from the directory;OPNCB	PUSH	IY		;Save IY	PUSH	HL		;Transfer direc record	POP	IY		;  to IY	PUSH	BC		;Save DEC and drive	CALL	OPNCB0		;Create opened FCB	POP	BC	LD	HL,OPEN14+1	;If from LOAD, don't do	BIT	0,(HL)		;  any further checks	JR	Z,OPNEX1	XOR	AOPNEX	POP	IY	RETOPNEX1	BIT	5,(IY+01H)	;If file already open	JR	Z,OPNCB8	;  then set read-only	POP	IY		;  & return "file open"OPNEX2	LD	A,(IX+01H)	;Get current attributes	AND	0F8H		;Mask off current prot	OR	05H		;  & replace with READ	LD	(IX+01H),A	;Reset access to READ	LD	A,29H		;Set "File already open"	RET;;	If access level is > read, set file open flag in;	the directory & note close authority in the FCB;OPNCB8	LD	A,(IX+01H)	;get FCB file access level	AND	07H		;Mask off other junk	CP	05H		;Check READ, EXEC, NONE	JR	NC,OPNCB10	;Go if one of the aboveOPNCB9	LD	A,00H		;Get CKDRV status	RLCA			;Was drive write prot?	JR	C,FRCREAD	;CF = WProt	SET	5,(IY+01H)	;Set file open in dir	LD	A,(NFLAG$)	;Get NFLAG	BIT	0,A		;Check for function on	CALL	NZ,@DIRWR	;Write the directory	JR	NZ,OPNEX	SET	6,(IX+00H)	;Set close authority;;	Check if passed LRL matches directory;OPNCB10 LD	A,(IX+09H)	;Get LRL from FCB and	CP	(IY+04H)	;  compare with directory	LD	A,42		;Init "LRL open fault"	JR	OPNEX;;	Disk write protected - Change access to READ;FRCREAD CALL	OPNEX2		;Change access to read	JR	OPNCB10;;	This routine creates the open file control block;OPNCB0	EX	DE,HL		;Transfer FCB pointer	PUSH	IX	POP	HL	LD	A,(DE)		;Get DIR+0	AND	20H		;Keep "PDS" bit & show	OR	80H		;  FCB as open	LD	(HL),A		;Shove into FCB+0	INC	HL	LD	A,(LREC$)	;Get LRL	OR	A		;Test for 0 (256)OPNCB1	LD	A,00H		;Now start byte 2 with	JR	Z,OPNCB2	;  that set with OPEN16	OR	80H		;Show sector or byte I/OOPNCB2	OR	20H		;Show buffer is empty;;	Set bit 3 if filespec ended in an;	exclamation point.  This causes the;	directory to be updated on every;	file write where the EOF is extended.;OPNCB3	OR	00H		;Init FCB+1	LD	(HL),A	INC	HL	XOR	A	LD	(HL),A		;Init FCB+2 with 0	INC	HL	PUSH	DE		;Put address of disk I/OOPNCB4	LD	DE,0000H	;  buf into FCB+3 and FCB+4	LD	(HL),E	INC	HL	LD	(HL),D	INC	HL	POP	DE		;FCB+5 with 0 for	LD	(HL),A		;  low order next	INC	HL	LD	(HL),C		;FCB+6 with drive	INC	HL	LD	(HL),B		;FCB+7 with DEC	INC	HL	INC	DE		;Point to DIR EOF byte	INC	DE	INC	DE	LD	A,(DE)		;Get dir low order EOF	LD	(HL),A		;  & stuff into FCB+8	INC	HL	INC	DE	LD	A,(LREC$)	;Get LRL & stuff	LD	(HL),A		;  into FCB+9	INC	HL	XOR	A	LD	(HL),A		;Init FCB+10 & FCB+11	INC	HL		;  with 0 for NRN	LD	(HL),A	INC	HL	SET	4,E		;Point to file EOF	LD	BC,0002H	;Move ERN	EX	DE,HL	LDIR			;  and zero BC reg	EX	DE,HL	LD	A,05H		;Max 5 extents	PUSH	AFOPNCB5	LD	A,(DE)		;Move starting track	LD	(HL),A	INC	HL	INC	DE	LD	A,(DE)		;Move grans and offset	LD	(HL),A	INC	HL	AND	1FH		;Strip out grans	INC	A		;Bump for zero offset;;	Add reg A to reg pair BC;	ADD	A,C		;Add previous count	LD	C,A		;Update C	JR	NC,L20EC	;Go if no carry into B	INC	BL20EC	POP	AF		;Recover counter	DEC	A		;Decrement loop	RET	Z		;Done if moved in 5	PUSH	AF	INC	DE	LD	A,(DE)		;Test for end of extents	CP	0FEH		;Extent in use?	JR	NC,OPNCB6	;Jump if not	LD	(HL),C		;Stuff # of cumulative	INC	HL		;  grans to this	LD	(HL),B		;  allocation into FCB	INC	HL	JR	OPNCB5		;Loop for next;;	Unused extents - Put 0FFFFH in remaining fields;OPNCB6	POP	AF		;Recover counter	RLCA			;Make time 4 and	RLCA			;  fill remaining	LD	B,A		;  extent bytes withOPNCB7	LD	(HL),0FFH	;  0FFh	INC	HL	DJNZ	OPNCB7	RET;;	INIT a file;	HL -> Address of 256 byte buffer;	DE -> Address of 32 byte FCB;	 B -> Logical record length;INIT	CALL	LNKFCB@		;Link to FCB	LD	(OPNCB1+1),A	;Start FCB+1 with 0	LD	A,10H	LD	(M2131+1),A	PUSH	HL	LD	HL,SFLAG$	;Reset called by RUN bit	RES	2,(HL)	POP	HL	CALL	OPEN1		;Can we "OPEN" the file?	RET	Z		;Return if file existing	CP	18H		;Return if error not	RET	NZ		;  "file not found"M2131	LD	A,10H		;Set dir rec to show	LD	(DIR$INIT),A	;  assigned	LD	A,(OPEN2+1)	;Get the drive entry	LD	C,A		;Jump if a drive entry	INC	A	PUSH	AF	JR	NZ,INIT1	;  was made	LD	C,AINIT1	POP	AF		;Stack integrity	CALL	CKDRV		;Is this drive available?	JR	NZ,INIT2	;Jump if not	JR	C,INIT2		;  or if write protected	CALL	@HITRD		;Read hash index table	RET	NZ		;Return if read error	CALL	SPRHIT		;Locate spare entry	JR	Z,INIT4		;Jump if space	XOR	A		;Set status of CKDRV=ZINIT2	PUSH	AF		;Save last CKDRV status	CALL	TESTDRV	JR	C,INIT1		;Loop if not at end	LD	A,(OPEN2+1)	;If drivespec not entered	INC	A		;  then "directory full"	JR	NZ,INIT2A	POP	AF		;Stack integrity	JR	ERR26INIT2A	POP	AF		;  else if no drive then	JR	NZ,ERR32	;  "illegal drive"	JR	C,ERR15		;  else if write protectERR26	LD	A,1AH		;  "dir space full"	DB	1ERR15	LD	A,15		;"Write prot"	DB	1ERR32	LD	A,32		;"Illegal drive"	OR	A	RET;;	Found a spare HIT entry position;INIT4	LD	B,L		;Save DEC	LD	A,(FILEHASH)	;Get filespec hash	LD	(HL),A		;  and store in HIT	CALL	@HITWR		;Write updated HIT	CALL	Z,@DIRRD	;Read that dir record	RET	NZ		;Return if read error	PUSH	HL	PUSH	BC	EX	DE,HL	LD	BC,0005H	;Move 1st 5 bytes into	LD	HL,DIR$INIT	;  directory record	LDIR	LD	C,11H		;Move filename and password	LD	HL,NAME$EXT	;  info into directory	LDIR	EX	DE,HL	LD	B,0AH		;Put 0FFFFh into 5 ext'sINIT5	CALL	OPNCB7		;4 for the ext's & 1 for	POP	BC		;  starting info	CALL	@DIRWR		;Write updated directory	POP	HL	RET	NZ		;Return if write error	CALL	OPNCB		;  else open the FCB	SCF			;Indicate new file	RET;;	Xfer the file spec system buffer area;XFRSPEC LD	B,13H	LD	DE,PSWDBUF	LD	A,20H		;Blank out the filenameXSPEC1	LD	(DE),A		;  field in system buffer	INC	DE	DJNZ	XSPEC1	LD	A,0FFH		;Set drive to 0FFH for	LD	(OPEN2+1),A	;  checking user entry	LD	E,NAME$EXT&0FFH ;Xfer file name	CALL	M21EE	LD	C,A	LD	A,B	SUB	08H		;Any valid chars found?	JR	NZ,XSPEC3	;Jump if valid name;;	Filename was invalid format;	OR	13H		;"Illegal file name"	RET;;	Continue to check file spec;XSPEC3	LD	A,C	CP	'/'		;Ext entered?	LD	E,FILE$EXT&0FFH	LD	B,03H	CALL	Z,XSPEC8A	;Xfer the ext	CP	'.'		;Password entered?	LD	E,PSWDBUF&0FFH	CALL	Z,M21E9	       ;Xfer the password	CP	':'		;Drive entered?	JR	NZ,XSPEC6	LD	A,(HL)		;Get drive #	SUB	30H		;Convert to binary	LD	(OPEN2+1),A	;Stuff drive #	AND	0F8H		;Must be 0-7	LD	A,20H		;"Illegal drive #"	RET	NZ		;Return error if out	INC	HL		;  of range	LD	A,(HL)		;Does filespec end inXSPEC6	SUB	21H		;  exclamation point?	LD	A,08H		;Init to set bit 3 of	JR	Z,XSPEC7	;  FCB+1 & jump if "!"	XOR	A		;  else reset if notXSPEC7	LD	(OPNCB3+1),A	RET;;;M21E9	LD	A,17H	LD	(M2131+1),AM21EE	LD	B,08HXSPEC8A LD	A,(HL)		;Get a filespec character	INC	HL		;  & first test for A-Z	JR	XSPEC10XSPEC9	LD	A,(HL)		;Get a filespec character	INC	HL		;Advance to next one	CP	'0'		;Check for 0-9	RET	C	CP	'9'+1	JR	C,XSPEC11XSPEC10 CP	'A'		;Check for A-Z	RET	C	CP	'Z'+1	RET	NCXSPEC11 LD	(DE),A		;Character is valid	INC	DE		;Advance to next one	DJNZ	XSPEC9		;  & loop	LD	A,(HL)		;Get following character	INC	HL	RET;;	Routine to find a spare HIT entry;	Calculate the number of directory sectors;	= (#sectors * #heads) - 2 for GAT and HIT;SPRHIT	LD	A,28H	CALL	NHIT4@	RET;;	Routine to rename a filespec / devspec;REN0	LD	A,18H	LD	(WASMAT),A	OR	A		;Denote "File not in dir"	RETRENAME	CALL	LNKFCB@		;Save regs & link to IX	LD	A,(IX+00H)	;If a device, use the	SUB	'*'		;  "device" routine	JR	Z,RENDEV	CP	'R'!80H-'*'	;Special open condition?	JR	Z,REN0		;Go if so	PUSH	HL		;Save new pointer	LD	HL,SFLAG$	;Set don't test flags	SET	0,(HL)	CALL	OPEN1		;Open the "old" spec	POP	HL	RET	NZ		;Exit on error	LD	A,(IX+01H)	;Make sure user has	AND	07H		;  permission to rename	CP	03H	JR	C,REN1	LD	A,25H		;"Illegal access"	OR	A	RET;;	User has access to rename - locate drivespec;REN1	PUSH	HL		;Save startREN2	LD	A,(HL)		;Get char of new spec	INC	HL	CP	0DH	JR	Z,REN3		;Go on ENTER	CP	03H	JR	Z,REN3		;Go on ETX	CP	':'	JR	NZ,REN2		;Loop on colonREN3	DEC	HL		;Backup to where colon	LD	(HL),':'	;  should go	INC	HL		;  & force the drivespec	LD	A,(IX+06H)	;  to the same as the old	LD	C,A		;Keep drivespec in C	AND	07H	ADD	A,'0'		;Make it an ASCII digit	LD	(HL),A	INC	HL	LD	(HL),0DH	LD	B,(IX+07H)	;Get DEC	POP	IX		;Put "new" FCB into IX	PUSH	BC		;  & save DEC & drive	LD	HL,SFLAG$	;Set don't test flags	SET	0,(HL)	CALL	OPEN1		;Open the "new" spec	POP	BC	JR	NZ,REN4		;Should error hereREN3A	LD	A,13H		;  or else return	OR	A		;  if "new" is existing	RET			;  & we opened itREN4	CP	18H		;If not "file not found"	RET	NZ		;  then it's an error	CALL	@DIRRD		;Read "old"s directory	RET	NZ	PUSH	BC		;Save drive spec	LD	D,H		;Xfer buffer hi	LD	A,L	ADD	A,05H		;Point to name field	LD	E,A		;Set buffer low	LD	HL,NAME$EXT	;Point to where the	LD	BC,000BH	;  new name is stored	LDIR			;Move in new name	POP	BC	CALL	@DIRWR		;Rewrite the directory	CALL	Z,@HITRD	;Read the HIT	RET	NZ	LD	D,H		;Set the buffer hi	LD	E,B		;Set the exact HIT low	LD	HL,NAME$EXT	;This doesn't change C	CALL	HASHNAME	;Hash the new name	LD	(DE),A		;Stuff code into HIT	JP	@HITWR		;Rewrite and exit;;	Routine to rename a device;RENDEV	PUSH	HL		;Save new pointer	CALL	GETDCB		;Locate old in tables	POP	IX		;Recover pointer to new	RET	NZ		;Back if it's not there	LD	A,L	CP	DCBKL$		;Check if protected device	LD	A,28H		;"Protected system device"	RET	C	LD	A,(IX+00H)	;"new" must be a device	CP	'*'	JR	NZ,REN3A	;"Illegal filename"	PUSH	HL		;Save address of "old"	CALL	GETDCB		;Check if new is unused	POP	HL		;Recover old's address	JR	Z,REN3A		;	LD	BC,0006H	;Point to name field	ADD	HL,BC		;  of old device	LD	(HL),E		;Stuff new name into	INC	HL		;  device control block	LD	(HL),D	XOR	A		;Set Z flag	RET			;return;;	Parameter storage area;PSWDBUF		DS	8NAME$EXT	DS	8FILE$EXT	DS	3PW$HASH1	DS	2PW$HASH2	DS	2		DW	0	;ERN initDIR$INIT	DB	0,0,0,0;LAST	EQU	$;LREC$	DS	1FILEHASH	DS	1;	IFGT	$,DIRBUF$	ERR	'Module too big'	ENDIF	ORG	MAXCOR$-2	DW	LAST-SYS2	;Overlay length;	END	SYS2