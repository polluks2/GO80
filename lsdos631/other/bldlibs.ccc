/*-------------------------------------------------------------------  BLDLIBS/CCC - Version 01.02.06  Program to create system libraries from assembled /CMD files for the  LS-DOS version 06.03.01 operating system.  -------------------------------------------------------------------  Copyright (c) 1997, Peter W. Cervasio  Permission to distribute this file freely is granted.  All other rights reserved  -------------------------------------------------------------------  Revision history:  27 Nov 97 pwc - Initial coding.  02 Dec 97 pwc - Initial testing.  03 Dec 97 pwc - Clean up and reformatting of code layout.  11 Jan 98 pwc - Added supprort for X patch blocks in /CMD input file  -------------------------------------------------------------------*/#option INLIB#option REDIRECT 0#option WILDCARD 0#option MAXFILES 4#option FIXBUFS#include <stdio.h>#include <stdlib.h>#include <fcntl.h>#define CHAR char#define UINT unsigned intstruct libdir {	CHAR itype;		/* 08 for SYSx/SYS modules */	CHAR dlen;		/* 06 for data length */	CHAR entry;		/* ISAM overlay # */	UINT tra;		/* Transfer address */	UINT nrn;		/* record number of start */	CHAR offset;	/* byte offset of start */};struct libdir entries[40];		/* dir entries for overlay */int filenums[40];				/* files for each dir entry */int nrns[20];					/* next rec nums for each file */int fofs[20];					/* file offsets for each file */int outfile;		/* output file */FILE *indata;		/* input data file (buildsys/dat) */int currentry;		/* current dir entry number */int numinputs;		/* number of input files for current output */int baseisam;		/* base ISAM number for this library */int totalcmds;		/* total number of commands */long dirposn;		/* Position of the directory in the file */int diritem;		/* dir item we're working on now */long currfpos;		/* where we are in the file */int curnrn;			/* Current rec # for NRN calc */CHAR curofs;		/* Current offset in sector */int tmp00;CHAR blktyp;int tmp01;CHAR blklen;int tmp02;int loadaddr;int tmp03;int bsize;int infile;			/* handle of binary input file */char datname[22];	/* data filename */char infname[22];	/* Input filename */char outfname[22];	/* Output filename */char *inputnames[20];	/* input filenames for library *//* Data used for the header at the start of the output file */char *cmthdr = "\x05\x06";char *fheader = "sysx  ";char *fcomment = "\x1f\x17(C) 1982-4,6,90 MISOSYS";char *dirend = "\x0a\x01\x00";char *modend = "\x04\x01\x00";char *filend = "\x02\x02\x00\x00";char buffer[266];	/* block I/O buffer */void showtitle();void showusage();int opendatafile();void builddir();int writecomment();int writedirectory();int main (argc, argv)	int argc; char *argv[];{	int iresult;		/* Temporary integer for func result */	int i;	int done = 0;	if (argc != 2)	{		showusage();		return -1;	}	strcpy (datname, argv[1]);		/* set input filename	/* show title */	showtitle();	if ((iresult = opendatafile()) != 0)	{		/* show error and exit */		printf ("Unable to open %s - aborting program\n",datname);		return -1;	}	printf ("Building initial directory\n");	/* read data file to create prelim directory */	builddir();		printf ("Opening output file: %s\n",outfname);	if ((outfile = creat(outfname, 0777)) == EOF)	{		printf("Unable to create file!\n");		return -1;	}	close (outfile);	outfile = open(outfname, O_RDWR);	if (outfile==EOF)	{		printf("Re-opening for read/write failed!\n");		return -1;	}	/* write header of output file (comment blocks) */	printf("Writing initial comment record\n");	dirposn = writecomment();	/* get position of the directory */	printf ("Directory located at %lx\n", dirposn);	/* Write the preliminary directory to disk */	currfpos = dirposn + writedirectory (totalcmds);	currfpos += write (outfile, dirend, 3);	currfpos += write (outfile, modend, 3);		printf("Library code starts at position %lx\n", currfpos);	diritem = 0;		/* currently working on command 0 */	/* loop through the files again, writing them to the output file */	/* As each is being processed, update the isam entries with the  */	/* proper NRN and OFFSET values for that file */	printf("Processing %d input files\n", numinputs);	for (i = 0; i < numinputs; i++)	{		/* Open the input file and write it to the output */		if ((infile = open (inputnames[i], O_RDONLY)) == EOF)		{			printf("Error opening %s\n", inputnames[i]);			exit(1);		}		printf ("Processing file %s: ", inputnames[i]);		/*set entries[i].nrn and entries[i].offset to curr file position */		nrns[diritem] = currfpos >> 8;		fofs[diritem] = currfpos & 0xff;		done = 0;		while (done == 0)		{			read (infile, &blktyp, 1);			switch (blktyp)			{				case 0x05:	/* Comment Record */				case 0x1f:	/* Copyright record */					read (infile, &blklen, 1);					bsize = blklen;					read (infile, buffer, bsize);					break;				case 0x01:	/* Load block */					/* write block to output file */					read (infile, &blklen, 1);					read (infile, &loadaddr, 2);					bsize = blklen;					bsize = bsize - 2;					if (bsize < 1) bsize = bsize + 256;					read (infile, buffer, bsize);					currfpos += write (outfile, &blktyp, 1);					currfpos += write (outfile, &blklen, 1);					currfpos += write (outfile, &loadaddr, 2);					currfpos += write (outfile, buffer, bsize);					break;									case 0x02:	/* Transfer address */					read (infile, &blklen, 1);					read (infile, &loadaddr, 2);					printf (" - TRAADR = %x", loadaddr);					currfpos += write (outfile, modend, 3);					done++;					break;				case 0x07:	/* X Patch block */					read (infile, &blklen, 1);					bsize = blklen;					read (infile, buffer, bsize);					currfpos += write (outfile, &blktyp, 1);					currfpos += write (outfile, &blklen, 1);					currfpos += write (outfile, buffer, bsize);					break;				default:					/* Don't know what it is! */					printf ("- Block %d - ABORT\n", blktyp);					close (outfile);					close (infile);					fclose (indata);					exit (-1);			}		}		close (infile);		printf (" - done\n");		diritem += 1;	}	/* fix up the NRNs and offsets */	for (diritem = 0; diritem < totalcmds; diritem++)	{		entries[diritem].nrn = nrns[filenums[diritem]];		entries[diritem].offset = fofs[filenums[diritem]];	}	/* Done with all the modules. End the file and rewrite the directory */	write (outfile, filend, 4);	printf("Finished writing modules - rewriting directory\n");	lseek (outfile, dirposn, 0);	write (outfile, entries, sizeof(entries[0]) * totalcmds);	close (outfile);	fclose (indata);	printf ("Done\n");	return 0;}void showtitle(){	printf ("BLDLIBS - Create SYS6/SYS7/SYS8 from CMD files - Ver 01.02.06\n");	printf ("Copyright 1997, Peter W. Cervasio (cervasio@airmail.net\n");	printf ("Permission to distribute freely.  All other rights reserved.\n");}void showusage(){	showtitle();	printf ("\nUsage: BUILDLIB datfilename\n");}int opendatafile(){	/* open the input data file */	if ((indata = fopen(datname,"r")) == NULL)	{		return 1;	}	return 0;}/* read input file and start to build directory */void builddir(){	char tempbuf[23];	/* temporary string buffer */	int  i;	int  tmpint;	long saveposn;	int curritem;	/* no commands exist yet */	totalcmds = 0;	/* read output filename */	fgets(tempbuf, 22, indata);	sscanf(tempbuf, "%s", outfname);	fheader[3] = outfname[3];	/* Set proper # in file header */	/* read base library ISAM number */	fgets (tempbuf, 22, indata);	sscanf(tempbuf, "%x", &baseisam);	/* read number of cmd files */	fgets(tempbuf, 22, indata);	numinputs = atoi (tempbuf);	if (numinputs > 20)	{		printf ("Error: Only 20 input files allowed per library!\n");		fclose (indata);		exit (-1);	}	printf("Number of input files: %d\n", numinputs);	/* loop to read cmd files */	for (i=0; i<numinputs; i++)	{		/* allocate space for the input cmd filename */		inputnames[i] = malloc(23);		/* read filename from the data file */		fgets (tempbuf, 22, indata);		sscanf(tempbuf, "%s", inputnames[i]);		printf("Learning about %s : ", inputnames[i]);		/* read the number of lib commands in this file */		fgets (tempbuf, 22, indata);		tmpint = atoi(tempbuf);		printf("%d commands ", tmpint);		for (curritem=0; curritem<tmpint; curritem++)		{			/* Make sure we're not out of range */			if (totalcmds > 40)			{				printf ("\nERROR! More than 40 commands in library!\n");				fclose (indata);				exit (-1);			}			/* init defaults */			filenums[totalcmds] = i;			entries[totalcmds].itype = 0x08;			entries[totalcmds].dlen = 0x06;			entries[totalcmds].entry = 0;			entries[totalcmds].tra = 0;			entries[totalcmds].nrn = 0;			entries[totalcmds].offset = 0;			/* read entries for this cmd file */			fgets (tempbuf, 32, indata);	/* read ISAM number */			sscanf(tempbuf, "%x", &entries[totalcmds].entry);			printf(" %x", entries[totalcmds].entry);			fgets (tempbuf, 32, indata);	/* read TRA ADDR */			sscanf(tempbuf, "%x", &entries[totalcmds].tra);			totalcmds++;		}		printf("\n");	}	return;}int writecomment(){	int tmpval;	tmpval = write (outfile, cmthdr, 2);	tmpval += write (outfile, fheader, 6);	tmpval += write (outfile, fcomment, 25);	return tmpval;}int writedirectory(numentries)	int numentries;{	int tmpval;	/* Calc total size of data to write to file */	tmpval = sizeof(entries[0]) * numentries;	printf ("Writing %d entries (size=%d)\n", numentries, tmpval);	if (write (outfile, entries, tmpval) != tmpval)	{		printf ("Error writing directory!\n");		exit (-1);	}	return tmpval;}/* EOF: bldlibs/ccc */