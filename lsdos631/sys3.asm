;****************************************************************;* Filename: SYS3/ASM						*;* Rev Date: 30 Nov 97						*;* Revision: 6.3.1						*;****************************************************************;* Handles closing a file or device, and restoring original	*;* file- or device- spec					*;****************************************************************;	TITLE	<SYS3 - LS-DOS 6.3>;*LIST	OFF*GET	SYSRES/EQU*LIST	ONLF	EQU	10CR	EQU	13;*GET	COPYCOM;	ORG	1E00H;SYS3	AND	70H	RET	Z		;Back on zero entry	CP	10H	JR	Z,CLOSE		;Jump if close	CP	20H	JP	Z,FNAME		;Jump if filespec recover	CP	30H	JP	Z,M2136		; --- New in 6.3.1	RETCLOSE	LD	A,(DE)		;Test for device	BIT	7,A	JP	Z,CLOSDEV	;Jump if closing device	CALL	CKOPEN@		;Test for open file	LD	C,(IX+06H)	;Get drive;;	Special MINI check drive routine;	PUSH	IY		;Save IY	CALL	@GTDCT		;Get DCT for driveCKAGN	CALL	@RSLCT		;Wait until not busy	JP	NZ,HOLDUP	;Go to error handler	BIT	3,(IY+03H)	;If hard drive, bypass	JR	NZ,SAWBLK	BIT	4,(IY+04H)	;If "alien" bypass	JR	NZ,SAWBLK	BIT	7,(IY+04H)	;Check if CKDRV inhibit	JR	NZ,SAWBLK	;Go if so;;	Test for diskette in drive (no index);	PUSH	DE	LD	D,(IY+05H)	;Get current track	LD	E,00H		;Set sector to 0	CALL	@SEEK		;Do a command	POP	DE	LD	B,30H		;Set up count (short)BLACK	CALL	@RSLCT		;Check for index pulse	BIT	1,A		;Test index	JR	Z,SAWBLK	;Saw black, seems okay	DJNZ	BLACK	JP	HOLDUP		;Close fault handler;;	Diskette is there, let's continue;SAWBLK	POP	IY		;Restore IY	LD	B,(IX+07H)	;Get DEC of FPDE	CALL	@DIRRD		;Read the directory	RET	NZ		;Quit if error there	BIT	4,(HL)		;Check for killed file	RET	Z		;Quit if killed file	PUSH	HL	PUSH	BC	CALL	RWRIT@		;Write last buffer?	POP	BC	POP	HL	RET	NZ		;Ret on I/O error	BIT	6,(IX+00H)	;If user does not have	JP	Z,RCVN0		;  close authority...	INC	L		;  else reset possible	RES	5,(HL)		;  file-open bit in DIR+1	INC	L		;Determine if the EOF	INC	L		;  byte has changed	LD	A,(IX+08H)	;Get EOF byte offset	PUSH	HL		;Save ptr to DIR+3	CP	(HL)	JR	NZ,CLOS1	;Go if moved	LD	A,11H	ADD	A,L	LD	L,A	LD	A,(IX+0CH)	;Get low order ERN	CP	(HL)	JR	NZ,CLOS1	;Go if moved	INC	L	LD	A,(IX+0DH)	;Get high order ERN	CP	(HL)	JR	NZ,CLOS1	;Go if moved	POP	AF	JR	CLOS2		;Didn't move;;	Routine to change the 3-byte EOF offset;CLOS1	POP	HL		;Pop DIR+3	LD	A,(IX+08H)	;Xfer the eof offset	LD	(HL),A	LD	A,11H	ADD	A,L	LD	L,A	LD	A,(IX+0CH)	;  and the ERN from the FB	LD	(HL),A	INC	L	LD	A,(IX+0DH)	;  to the dir entry	LD	(HL),A	BIT	2,(IX+00H)	;If file was updated	JR	NZ,CLOS3	;  then update mod date	JR	CLOS5		;  else don't;;	Three byte EOF marker did not change;CLOS2	BIT	2,(IX+00H)	;If file was updated	JR	NZ,CLOS3	;  then update mod date	BIT	6,(IX+00H)	;If close authority then	JR	NZ,CLOS5	;  write back the dir	JR	CLOS6		;  else continue;;	Routine to insert packed date into directory;CLOS3	PUSH	HL		;Save ptr to DIR+21	LD	A,L		;Pt to start of dir rec	AND	0E0H	LD	L,A		;Save back in HL	INC	L		;Pt to DIR+1	SET	6,(HL)		;Set the MOD flag	LD	DE,DATE$	;Point to year	LD	A,(DE)		;Get year in A;;; -------- New code in 6.3.1;;	PUSH	AF		; Save AF and BC	PUSH	BC	INC	DE		; Point to year+1	INC	L		; Point to DIR+2	AND	07H		; Mask off	LD	B,A		; Store it in B	LD	A,(DE)		; Get year	RLCA			; Rotate it	RLCA	RLCA	OR	B		; Merge in B	LD	(HL),A		; Save it in DIR+2	DEC	L		; Point to DIR+1	INC	DE		; Inc date ptr	LD	A,(DE)		; Get month	LD	B,A		; Save it in B	LD	A,(HL)		; Get char from dir	AND	0F0H		; Mask other stuff	OR	B		; Merge month in	LD	(HL),A		; Save it back	LD	A,C		; Get day?	AND	07H		; Mask stuff off	LD	B,A		; Store in B	INC	B		; Increment it*LIST	OFF	IFLT	@DOSLVL,'L'	;---> Before changes for 6.3.1L*LIST	ON	LD	A,3FH		; InitialM1EDF	ADD	A,08H		; Do stuff	DJNZ	M1EDF	LD	(M1EEA),A	; Store in instruction	LD	A,(YFLAG$)	; Get YFLAG$	BIT	0,A		; Bit set?M1EEA	EQU	$-1	JR	NZ,M1EF1	; Jump if not	POP	BC		; Get BC and	POP	AF		;   AF regs back	JR	CLOS4		; And skip the restM1EF1	LD	A,L		; DIR+2 ptr	ADD	A,11H		; Point to year	LD	L,A		; Save it back	LD	DE,(TIME$+1)	; Pt to minutes	LD	A,D		; Get	LD	D,E	LD	E,00H	LD	B,03HM1EFF	SRL	D	RR	E	DJNZ	M1EFF	RLCA	RLCA	RLCA	OR	D	LD	D,A	POP	BC	POP	AF		; Get year back	OR	A		; Was it set?	JR	Z,M1F13		; Jump if not	SUB	50H		; Otherwise subtract 80	OR	E		; OR in what's in E	LD	E,A		; Save back in e*LIST	OFF	ELSE			;<--> 6.3.1L*LIST	ON	LD	A,(YFLAG$)	; Get YFLAG$L1EE0	RRCA	DJNZ	L1EE0		; Check ext date for drive	JR	C,L1EE9		; Go if yes	POP	BC	POP	AF	JR	CLOS4		; do old style closeL1EE9	LD	BC,(TIME$+1)	; point to mins	EX	DE,HL		; save DIR+1 to DE	LD	L,C		; min to L	ADD	HL,HL		;	ADD	HL,HL		; L'bits 2-7 contain min	LD	H,B		; hour to H	ADD	HL,HL	ADD	HL,HL	ADD	HL,HL		; HL = hhhh hmmm mmm0 0000	EX	DE,HL		; save to DE, DIR+1 to HL	POP	BC	POP	AF		; Get year back	OR	A		; Was it set?	JR	Z,L1F0C		; Jump if not	SUB	80		; A contains year-1980	PUSH	AF	AND	1FH		; (Y-1980)%32 -> yyyyy	OR	E		; combine with E	LD	E,A		; DE = hhhh hmmm mmmy yyyy	POP	AF	RLCA			; Divide (Y-1980) by 32	RLCA	RLCA	AND	07H		; A contains (Y-1980)/32	INC	HL		; point to old year & day	XOR	(HL)		; XOR it into (HL)	LD	(HL),A		; (Matthew Reed's trick)	DEC	HL		; point to monthL1F0C	LD	A,L		; point to DIR+19	ADD	A,11H	LD	L,A	NOP	NOP	NOP*LIST	OFF	ENDIF			;<--- 6.3.1L*LIST	ONM1F13	LD	(HL),D		; Save part of year	INC	HL		; Next position	LD	(HL),E		; Rest of year;;; --------- end of new code in 6.3.1;;CLOS4	POP	HL		;Recover DIR+21CLOS5	PUSH	HL	CALL	@DIRWR		;Write back DIR entry	POP	HL	RET	NZCLOS6	INC	L		;Point to DIR+22 which	PUSH	HL		;  is the first extent	LD	A,L	SUB	15H		;Backup to DIR+1	LD	L,A	BIT	7,(HL)		;Test if created	POP	HL	JP	NZ,RCVN0	;Bypass if created	LD	DE,0000H	;Init gran counterCLOS7	LD	A,(HL)		;Get cyl indicator	INC	L		;Pt to gran alloc	CP	0FEH		;Extent in use?	JR	NC,CLOS8	;Jump if spare or FXDE	LD	A,(HL)		;Get gran alloc	INC	L		;point to next extent	AND	1FH		;Strip off # of grans &	INC	A		;  adjust for zero offset	ADD	A,E		;Accumulate the number of	LD	E,A		;  grans in this extent	JR	NC,CLOS7	;Any previous quantity	INC	D	JR	CLOS7CLOS8	JR	NZ,CLOS9	;Found all grans in this	LD	B,(HL)		;  extent, ck for FXDE	CALL	@DIRRD	RET	NZ	LD	A,L		;Point to extents in FXDE	ADD	A,16H	LD	L,A	JR	CLOS7		;Go to continue count;;	Routine to determine need to deallocate;CLOS9	PUSH	HL		;Save ptr to last extent	LD	L,(IX+0CH)	;Get ending record #	LD	H,(IX+0DH)	LD	A,08H		;Get # sectors/gran	CALL	@DCTBYT	AND	1FH		;Remove other data	PUSH	AF		;Save the number	ADD	A,L		;Round up to next	LD	L,A		;  higher gran	JR	NC,CLOS10	INC	HCLOS10	POP	AF		;Recover sectors/gran	INC	A		;Adjust for division	CALL	@DIV16		;Calc # grans in use	XOR	A		;Subtract # of grans	EX	DE,HL		;  used from the # of	SBC	HL,DE		;  grans allocated in the	EX	DE,HL		;  directory, and move DE	POP	HL		;Rcvr ptr to last extent	JP	Z,RCVN0		;Jump if same quantity	JP	C,RCVN0		;  or if now more;;	Need to deallocate space;	CALL	@GATRD		;Read GAT	RET	NZ	JR	BAKUP		;Backup to last used extentCLOS11	PUSH	DE		;Save count of excess grans	LD	A,(HL)		;Get alloc info	AND	0E0H		;Get starting relative	RLCA			;  gran into reg-E	RLCA	RLCA	LD	E,A	LD	A,(HL)		;# of contiguous grans	AND	1FH		;Remove unneeded data	ADD	A,E		;Calculate ending	LD	E,A		;  relative gran #	LD	A,08H		;Get the # of grans	CALL	@DCTBYT		;  per cylinder	RLCA	RLCA	RLCA	AND	07H		;Move into bits 0-2	INC	A		;Adjust for zero offset	LD	D,A		;Save count	LD	A,04H	CALL	@DCTBYT	BIT	5,A		;2 sided disk?	LD	A,D		;Recover count	JR	Z,L1F5A		;Bypass if 1 sided	RLCA			;Double countL1F5A	CALL	@DIV8		;A=quotient, E=remainder	DEC	L		;Pt to starting cylinder	ADD	A,(HL)		;Bump cyl pointer by how	LD	D,A		;  many excessive cyls to	PUSH	HL		;  start from the year	PUSH	BC	LD	H,DIRBUF$<-8	;Pt to that cyl's GAT	LD	L,D	LD	B,(HL)		;Get the GAT allocation	LD	A,E	CALL	CALCBIT		;Deallocate a gran	LD	(HL),B		;Replace GAT byte	POP	BC	POP	HL	INC	L		;Repoint to alloc info	DEC	(HL)		;Reduce by 1 gran	LD	A,(HL)		;Get info on contig grans	INC	A		;Adj for zero offset	AND	1FH		;Strip unneeded	POP	DE		;Rcvr excess gran count	DEC	DE		;  and count down	JR	NZ,CLOS12	;Go if extent still usedBAKUP	LD	(HL),0FFH	;  else extent is spare	DEC	L	LD	(HL),0FFH	DEC	L	LD	A,L		;Check if backed all the	AND	1FH		;  way thru this entry	CP	15H	JR	NZ,CLOS12	;Go if not	XOR	L		;Deallocate this FXDE	LD	L,A	BIT	7,(HL)		;Was it the FPDE	JR	Z,CLOS12	;Bypass if FPDE	LD	(HL),00H	;Show dir is spare	CALL	@DIRWR		;Write back	RET	NZ	LD	A,B		;Get deallocated DEC	AND	0E0H	INC	A		;Point to DIR+1	LD	L,A	LD	A,(HL)		;Get previous DEC	LD	(STUFDEC+1),A	;Save in instruction	CALL	@HITRD		;Read the HIT	RET	NZ	LD	L,B		;Point to deallocated HIT	LD	(HL),00H	;Deallocate space in HIT	CALL	@HITWR		;Write back	RET	NZSTUFDEC LD	B,00H		;Get previous DEC	CALL	@DIRRD		;Read its dir entry	RET	NZ	LD	A,B	OR	1FH		;Pt to end of entry	LD	L,A	LD	(HL),0FFH	;Erase pointer	DEC	L		;  to deallocated FXDE	LD	(HL),0FFH	DEC	L		;Point to previous extent	PUSH	HL		;Save pointer	CALL	@DIRWR		;Write back	POP	HL	RET	NZCLOS12	LD	A,D		;Loop if still more to	OR	E		;  deallocate	JP	NZ,CLOS11	CALL	@DIRWR	JR	Z,CLOS13	;Go if no write error	CP	0FH		;"Write protected...	RET	NZ		;Bad if not	JR	RCVN0;CLOS13	CALL	@GATWR		;Write back the altered GAR	RET	NZ;;	Routine starts to recover file spec;RCVN0	LD	A,(IX+07H)	;Get DEC of FPDE	LD	C,(IX+06H)	;Get drive	XOR	B		;Check if its directory	AND	1FH		;  record is resident	LD	B,(IX+07H)	;Get DEC of FPDE	CALL	NZ,@DIRRD	;Get FPDE dir if needed	RET	NZ	PUSH	IX		;Transfer FCB to DE	POP	DERCVNAM	LD	A,C	AND	07H		;Convert drive to ASCII	OR	'0'	LD	(RCVN5+1),A	;	LD	H,SBUFF$<-8	;Pt to DIR+5 (name)	LD	A,B	AND	0E0H	OR	05H	LD	L,A	PUSH	HL		;Save name start position	LD	B,08H		;Init 8 chars maxRCVN1	LD	A,(HL)		;Move filename from	CP	20H		;  direc to fcb	JR	Z,RCVN2	LD	(DE),A	INC	HL	INC	DE	DJNZ	RCVN1		;Loop up to 8RCVN2	POP	HL	LD	A,L	ADD	A,08H		;Pt to extension	LD	L,A	LD	A,(HL)	CP	20H	JR	Z,RCVN4		;Jump if none	LD	A,'/'	LD	(DE),A		;Stuff separator into FCB	INC	DE	LD	B,03H		;Init 3 char extensionRCVN3	LD	A,(HL)		;Stuff the ext	CP	20H		;  into fcb	JR	Z,RCVN4	LD	(DE),A	INC	HL	INC	DE	DJNZ	RCVN3RCVN4	LD	A,':'		;Stuff drive indicator	LD	(DE),A	INC	DERCVN5	LD	A,00H		;get drive in ASCII	LD	(DE),A		;& stuff it	INC	DE	LD	A,03H		;Close FCB with ETX	LD	(DE),A	XOR	A	RET;;	Routine to recover the filespec;FNAME	PUSH	HL	PUSH	DE;;	Calulate the number of directory sectors;	= (#sectors * #heads) - 2 for GAT & HIT;	LD	A,07H		;Get highest # sector	CALL	@DCTBYT	LD	D,A		;Store heads & sectors	AND	1FH		;Rake off # sectors	LD	E,A		;  & stuff into E	INC	E		;Bump for 0 offset	XOR	D		;Recover # heads	RLCA			;  into bits 0-2	RLCA	RLCA	INC	A		;Adjust for 0 offset	CALL	@MUL8		;Multiply sectors * heads	LD	E,A		;Now check double bit	LD	A,04H	CALL	@DCTBYT	BIT	5,A		;Set if 2-sided	LD	A,E	JR	Z,ONESID	;Go if not set else	ADD	A,A		;  double valueONESID	SUB	02H		;Reduce for GAT and HIT	LD	D,A	LD	A,B	AND	1FH		;Cal req sector #	CP	D	JR	C,FNAM1	LD	A,10H		;"Illegal logical file #"	OR	A	JR	FNAM2FNAM1	POP	DE	PUSH	DE	CALL	@DIRRD	CALL	Z,RCVNAM	;Recover the filespceFNAM2	POP	DE	POP	HL	RET;;	Close a logical device;CLOSDEV CP	10H		;If not open device	LD	A,26H		;  return "file not open...	RET	NZ	CALL	LNKFCB@		;Link to FCB	LD	C,(IX+06H)	;Get device name	LD	B,(IX+07H)	LD	(IX+00H),'*'	;Stuff device indicator	LD	(IX+01H),C	;Stuff 1st char of name	LD	(IX+02H),B	;Stuff 2nd char of name	LD	(IX+03H),03H	;Terminate with ETX	XOR	A	RET;;	Calculate GAT bit to deallocate;CALCBIT AND	07H		;Make binary bit # into	RLCA			;  the proper RES	RLCA			;  opcode	RLCA	OR	80H	LD	(CALC1+1),ACALC1	RES	0,B		;Reset bit in GAT	RET;;	User removed disk with an open file;HOLDUP	PUSH	HL	PUSH	DE	LD	HL,HOLDUP$	;Point to message	CALL	@DSPLY		;Display on console	CALL	@CKBRKC		;Clear out break bitWAITING CALL	@KBD		;Scan the keyboard	JR	NZ,WAITING	;Keep looking	CP	0DH		;Check for ENTER	JR	Z,TRYNOW	CALL	@CKBRKC		;Check for a break	JR	Z,WAITINGABRT	POP	DE	POP	HL	POP	IY		;Restore from above	LD	A,20H		;Show illegal drive #	OR	A		;Set NZ condition	RETTRYNOW	POP	DE	POP	HL	JP	CKAGN		;Try checking again;HOLDUP$ DB	LF,'** CLOSE FAULT **  Drive not ready, '	DB	'<ENTER> to retry, <BREAK> to abort',CR;M2136	RET;LAST	EQU	$	IFGT	$,DIRBUF$	ERR	'Module too big'	ENDIF	ORG	MAXCOR$-2	DW	LAST-SYS3	;Overlay length;	END	SYS3