;LBRENAME/ASM - RENAME command	TITLE	<RENAME - LS-DOS 6.3>;*GET	SVCEQU			; System SVC equates*GET	VALUES			; Misc equates;INH	EQU	0		; Inhibit LRL fault;	ORG	2400H;RENAME	LD	(SAVESP+1),SP	LD	A,@CKBRKC	RST	28H	JR	NZ,ABORT	CALL	RENAM	LD	HL,0	JR	Z,SAVESP;IOERR	LD	L,A	LD	H,00H	OR	0C0H	LD	C,A	LD	A,1AH	RST	28H	JR	SAVESP;SPCERR	LD	HL,SPCERR$	DB	0DDHDUPNAM	LD	HL,DUPNAM$	DB	0DDHTOWHAT	LD	HL,TOWHAT$	LD	A,@LOGOT	RST	28H;ABORT	LD	HL,-1;SAVESP	LD	SP,0	LD	A,@CKBRKC	RST	28H	RET;;	RENAM - Rename a filespec or devspec;RENAM	PUSH	HL		; Save cmd line ptr	LD	DE,TEMPFCB	; Xfer filespec to buffer	LD	A,@FSPEC	RST	28H	POP	HL		; Ignore error;	LD	A,@FLAGS	; Flags to IY	RST	28H;	LD	DE,OLDFCB	; Get filespec	LD	A,@FSPEC	RST	28H	JR	NZ,SPCERR	; Quit if bad source name;	LD	DE,NEWFCB	; Get new name	LD	A,@FSPEC	RST	28H	CALL	NZ,CVRTUC	; Convert partial spec to UC;REN1	LD	A,(NEWFCB)	; If new name starts out	CP	0FH		;   with something less than	JP	C,TOWHAT	;   x'0E' - to what?;	LD	HL,OLDFCB	LD	DE,NEWFCB	LD	A,(HL)		; Check on device rename	CP	'*'	JP	Z,DEVREN	; Go if renaming a device;	LD	A,(DE)		; Old is file, new must be	CP	'*'		;   also.	JR	Z,SPCERR;;	Renaming files - Can we OPEN the old file?;	LD	DE,TEMPFCB	SET	INH,(IY+SFLAG$)	; Inhibit open bit set	LD	A,@OPEN	RST	28H	RET	NZ		; NZ - file not found	LD	BC,(TEMPFCB+6)	; Get drive # and DEC;;	Good open - is there a drivespec in the string?;	PUSH	HL		; Save pointerFLOOP	LD	A,(HL)		; Get character	CP	CR+1		; End of filespec?	JR	NC,CHKDSPC;;	Drivespec wasn't specified - put it on;	LD	(HL),':'	; Append drivespec onto	INC	HL		;   end of filespec	LD	A,C		; Move drive to A	ADD	A,'0'		; Convert to ASCII	LD	(HL),A	LD	(OLD_DRV+1),A	; Self-modify NEW FCB	INC	HL		; Bump	LD	(HL),CR		; End of filespec	JR	DOMATCH		; Get defaults;;	Stop when ":" found or terminator;CHKDSPC	CP	':'		; Already have one?	INC	HL	JR	NZ,FLOOP	LD	A,(HL)		; get drive	LD	(OLD_DRV+1),A	; Self modify NEW FCBDOMATCH	POP	HL		; HL => Old FCB	LD	DE,NEWFCB	; DE => New FCB	CALL	MATCH;;	Make sure new drivespec is same as old one;	PUSH	DE		; Save new FCBF2LOOP	LD	A,(DE)		; Go until ":"	INC	DE	CP	':'	JR	NZ,F2LOOPOLD_DRV	LD	A,$-$		; Get old drivespec	LD	(DE),A		; Overwrite	POP	DE		; Restore DE;;	Does the new filename already exist?;	PUSH	HL		; Save old ptr	PUSH	DE		; Save new ptr	EX	DE,HL	LD	DE,TEMPFCB	; DE => Temp buffer	SET	INH,(IY+SFLAG$)	LD	A,@FSPEC	; Transfer filespec	RST	28H	LD	A,@OPEN		; File already exist?	RST	28H	JP	Z,DUPNAM	; Error if so	POP	DE		; Restore pointers	POP	HLREN2	PUSH	HL		; OLD filename/device	PUSH	DE		; NEW filename/device;;	Transfer the old and new specs to SPEC$ minus passwords;	LD	DE,SPECS$	CALL	MOVSPC		; Move old spec	LD	HL,TO$	LD	BC,4	LDIR			; Move " to "	POP	HL		; Recover new filespec	PUSH	HL	CALL	MOVSPC		; Move new spec	LD	A,CR	LD	(DE),A		; Terminate with CR	LD	HL,RENAM$	; Show names on video	LD	A,@LOGOT	RST	28H	POP	HL		; Recover new	POP	DE		; Recover old	LD	A,@RENAM	; Rename file	RST	28H	RET			; Return with condition;;	MOVSPC	- Create secondary spec;MOVSPC	LD	A,(HL)		; Get spec char	CP	'/'		; Extension?	JR	NZ,CKSPACE	; No - check if space	INC	HL		; Is the next char valid?	LD	A,(HL)	CP	'A'	JR	C,CKSPACE	; No - don't output it	DEC	HL		; back one	LD	A,(HL)		; get slashCKSPACE	CP	' '	RET	C		; Exit on terminator	CP	'.'		; Ignore password	JR	NZ,MOVSPC1SKIPPW	INC	HL	LD	A,(HL)	CP	' '	RET	C		; Back on terminator	CP	':'	JR	NZ,SKIPPWMOVSPC1	LDI			; Move the char	JR	MOVSPC;;	Routine to rename a device;DEVREN	LD	A,(DE)		; Old was device, new must	CP	'*'		;   be one also	JP	NZ,SPCERR	; Abort if bad;;	Does the source devspec exist?;	PUSH	HL		; Save pointers	PUSH	DE	INC	HL		; Bump past "*"	LD	E,(HL)		; Device name to DE	INC	HL	LD	D,(HL)	LD	A,@GTDCB	; Find device	RST	28H	JP	NZ,IOERR	; Go if not found;;	Pick up the Jog Log DCB address (last DCB);	LD	B,H		; save DCB ptr in BC	LD	C,L	LD	DE,'LJ'		; Find *JL	LD	A,@GTDCB	RST	28H	INC	HL		; Pt HL => past protected	OR	A		;   system device table	SBC	HL,BC		; Protected device?	LD	A,40		; Init error code	JP	NC,IOERR	; Jump on error;;	Does the destination device already exist?;	POP	HL		; Get new Devspec	PUSH	HL	INC	HL		; Go past "*"	LD	E,(HL)		; Set DE = device name	INC	HL	LD	D,(HL)	LD	A,@GTDCB	; Already exists?	RST	28H	LD	A,39		; "Device in use"	JP	Z,IOERR		; Abort if it exists	POP	DE		; Get new and old ptrs	POP	HL	JP	REN2;;	Routine xfers partial filespec & converts to U/C;CVRTUC	LD	A,(HL)	CP	0DH	RET	Z		; Ret if no new name	DEC	HL		; Backup to 1st separatorCOP0	LD	A,(HL)	INC	HL	CP	' '		; Skip past spaces	JR	Z,COP0	DEC	HL	LD	B,32		; Max 32 charsCOP1	LD	A,(HL)		; Transfer the partialCOP2	CP	'a'		; Convert l/c to u/c	JR	C,COP3	CP	'z'+1	JR	NC,COP3	SUB	20HCOP3	LD	(DE),A		; Filespec until paren	CP	0DH		;   or enter	RET	Z	CP	'('	RET	Z	INC	HL		;   or end of line	INC	DE		;   or 32 chars max	DJNZ	COP1	RET;;	Match source and destination for defaults;MATCH	PUSH	DE		; Save new spec	PUSH	HL		; Save old spec	LD	A,(DE)		; Get a dest char	CP	'A'	CALL	C,MATCH7	; Match if not a filename	LD	B,'/'	CALL	MATCH2	LD	B,':'	CALL	MATCH2	LD	B,'.'	CALL	MATCH2	POP	HL	POP	DE	RET;MATCH1	INC	DEMATCH2	LD	A,(DE)		; Scan destination until	CP	B		;   the test character is	JR	Z,MATCH3	;   found or until some	CP	'A'		;   other special char	JR	NC,MATCH1	;   is reached	CP	'0'		; Loop on 0-9	JR	C,MATCH4	CP	'9'+1	JR	C,MATCH1	JR	MATCH4MATCH3	INC	DE	RET;;	Found some other special char - Need the field;MATCH4	PUSH	HL		; Save pointer to sourceMATCH5	LD	A,(HL)		; Scan source until the	INC	HL		;   desired field is	CP	ETX		;   found (if it is	JR	Z,MATCH6	;   supplied by the user)	CP	CR	JR	Z,MATCH6	CP	B	JR	NZ,MATCH5	CALL	MATCH9		; Move source fieldMATCH6	POP	HL	RET;;	Routines to move a source field to destination;MATCH7	LD	A,(HL)		; Get source character	CP	'0'		; Back when out of range	RET	C	CP	'9'+1	JR	C,MATCH8	CP	'A'	RET	CMATCH8	INC	HL		; Advance source ptrMATCH9	PUSH	HL		; Save HL and make it	LD	H,D		;   the destination ptr	LD	L,EMATCH10	LD	C,(HL)		; Get char at destination	LD	(HL),A		;   and put in new one	INC	HL		; Next dest location	LD	A,C		; What was there?	CP	ETX		; Go until ETX	JR	Z,MATCH11	CP	CR		;   or end of line	JR	NZ,MATCH10MATCH11	LD	(HL),A	POP	HL	INC	DE	JR	MATCH7;;	Messages;SPCERR$	DB	'Specification error',0DHDUPNAM$	DB	'Duplicate file name',0DHTOWHAT$	DB	'Rename it to what?',0DHTO$	DB	' to ',03HNEWFCB	DB	CR	DS	31OLDFCB	DS	32RENAM$	DB	'Renaming: 'SPECS$	DS	40TEMPFCB	DS	32OLD_FIL	DW	0;LAST	EQU	$;	END	RENAME