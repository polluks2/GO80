; ***************************************************************; * Filename: REPAIR/ASM					*; * Revision: 06.03.01						*; * Rev Date: 19 Dec 97						*; ***************************************************************; * LSDOS Directory Track Repair Utility			*; *								*; ***************************************************************;	TITLE	<REPAIR - LS-DOS 6.3>;LF	EQU	10CR	EQU	13BLNKMPW	EQU	4296HFLAG	EQU	01000000BABB	EQU	00010000B;*GET	SVCMAC			; System SVC macros*GET	COPYCOM			; Copyright message;	ORG	2600H;BEGIN	@@CKBRKC		; Check for break	JR	Z,BEGINA	LD	HL,-1		; Set abort code	RET;BEGINA	LD	(STACK),SP	; Save entry stack	PUSH	HL		; Save ptr to cmd line	LD	HL,HELLO$	; Display the signon	CALL	$DSPLY	POP	HL	CALL	PGRM		; Normal exit is via RET;;	Set exit condition;$EXIT	LD	HL,0		; Init for no errorQUIT$	LD	SP,0		; Get original stack backSTACK	EQU	$-2	@@CKBRKC		; Clear any break	RET;;	Repair main code;PGRM	LD	A,(HL)		; Check for drive entered	CP	':'		; Colon indicator?	JP	NZ,PRMERR	; Quit if not	INC	HL		; Point to drive number	LD	A,(HL)		; Get it	SUB	'0'		; Convert to binary	CP	08H		; Check range	JP	NC,ILLEG	; Quit if out of range;	OR	A		; Can't be drive 0	JP	Z,NOT0	LD	(DRIVE),A	; Save it for later	INC	HL		; Bump past the drive	LD	C,A	@@GTDCT			; What's its DCT$ say?;;	Get any parameters (MPW is the only one);	LD	DE,PRMTBL$	; Point to param table	@@PARAM	JP	NZ,PRMERR	; Quit on param error	LD	A,(MRSP)	; MPW parameter entered?	OR	A	JP	NZ,MPARM	; Go if it was	BIT	3,(IY+03H)	; Can't repair a hard drive	JP	NZ,NIXHARD	;   except for MPW parameter	BIT	4,(IY+04H)	; If not an alien controller	CALL	Z,CKDRV		;   make sure disk present	LD	DE,0		; Read BOOT to get DIR cylinder	CALL	RDSEC	XOR	A	LD	(BUF1),A	; Set 1st byte to 0	LD	A,(BUF1+2)	; Get the DIR cylinder	AND	7FH		; Strip off bit 7	LD	(BUF1+2),A	; Put back into buffer	PUSH	AF		; Save the DIR cylinder	CALL	WRSEC		; Rewrite the BOOT	INC	E	CALL	RDSEC		; Get sector 1 also	POP	AF	LD	(BUF1+2),A	; Update DIR cylinder	PUSH	AF	CALL	WRSEC		; Write sector 1 back	POP	AF		; Get DIR cylinder back in A;	LD	D,A		; Dir cyl to D	LD	E,00H		; Sector 0 (GAT)	LD	(IY+09H),A	; Update DCT with DIR cyl	CALL	RDSEC		; REad the GAT;	RES	5,(IY+04H)	; Show single sided	LD	L,0CBH		; Point to version # byte	LD	A,(HL)		; Get it	CP	40H		; Earlier than 4.0?	JR	C,LC		; Bypass 2 sided check if so	CP	70H		; "Later" than 6.x?	JR	NC,LC		; Again, no sides check	LD	L,0CDH		; Point to config byte	BIT	5,(HL)		; Check 2-sided-ness	JR	Z,LC		; Go if not	SET	5,(IY+04H)	;   else update the DCT;LC	LD	L,0BFH		; Point to end of lockout	LD	B,96		; Max cylinder countALIEN1	LD	A,(HL)		; Get a lockout byte	INC	A		; Locked out?	JR	NZ,ALIEN2	; Exit when in use	DEC	L		; Backup by one	DJNZ	ALIEN1ALIEN2	LD	A,-35		; What's in use?	ADD	A,B		; Convert to excess	LD	L,0CCH		; Point to correct position	LD	(HL),A		; Stuff excess into GAT;;	Construct a config byte;	LD	A,(IY+04H)	; Get number of sides	AND	80H!20H		; Keep these bits	LD	B,A		; Save temporarily	LD	A,(IY+03H)	; Get density	AND	40H		; Mask of other stuff	OR	B		; Merge with other stuff	LD	B,A	LD	A,(IY+08H)	; Get grans per track	RLCA			;   into bits 0-2	RLCA	RLCA	AND	07H		; Mask off the rest	OR	B		; Merge with previous	INC	L		; Point to config byte in GAT	LD	B,A		; Save for a moment	LD	A,(HL)		; Get the old config byte	AND	80H		; Keep only bit 7 (protected??)	OR	B		; Merge with what we built	LD	(HL),A		; Stuff back into GAT buffer	LD	L,00H	CALL	WRSYS		; Write the GAT back out;;	Operate on the HIT;	INC	E		; Bump sector number to 1	CALL	RDSEC		; Read the HIT	INC	L		; Point to DIR/SYS DEC	LD	(HL),0C4H	; "correct" DEC code	DEC	L	CALL	WRSYS		; Write out the HIT	LD	B,08H		; Init for 8 sectorsALIEN3	INC	E		; Bump to next sector	CALL	RDSEC		; Get the sector	CALL	UNOPEN		; Reset file open bits	LD	A,E		; If DIR/SYS sector, then	CP	03H		;   update count and it	JR	NZ,ALIEN4	PUSH	HL	LD	HL,BLNKMPW	; Set DIR/SYS password	LD	(BUF1+12H),HL	;   to blanks	LD	A,(BUF1+14H)	; Get ERN of DIR/SYS	SUB	03H		; Account for first 3 done	LD	B,A		; Update the loop counter	POP	HLALIEN4	CALL	WRSYS		; Write the sector back out	DJNZ	ALIEN3		; Loop for # sectors in DIR;	LD	HL,ALCAO$	; Advise complete - now readable	@@LOGOT	RET;;	MPW parameter to change  disk password on hard drive;MPARM	LD	DE,0		; Get MPW string address	BIT	5,A		; If not string, then error	JP	Z,PRMERR	BIT	3,(IY+03H)	; Can't do if not hard disk	JP	Z,PRMERR	CALL	GETMPW		; Get and hash the entry	JP	NZ,IOERR	; Quit on error	LD	C,00H		; Init to drive requestedDRIVE	EQU	$-1	CALL	GATRD		; Read GAT into BUF1	JP	NZ,IOERR	; Quit on error	LD	(BUF1+0CEH),HL	; Stuff new MPW into GAT	CALL	GATWR		; Write GAT back to disk	JP	NZ,IOERR	; Jump on write error	RET;;	Enter SYS2 and hash the password;GETMPW	CALL	GMPW1		; Get MPW into buffer	RET	NZ	LD	A,0E4H		; Hash password (DE) to HL	RST	28H		; Returns to what called;;	Place entered password into buffer;GMPW1	LD	HL,PSWDBUF	; Point to buffer	PUSH	HL	LD	B,08H		; Init for 8 charactersGMPW2	LD	A,(DE)		; Get a character	CP	0DH		; End of line?	JR	Z,GMPW4		; Go if so	CP	','		; Comma separator?	JR	Z,GMPW4	CP	'"'		; End of string?	JR	Z,GMPW4	INC	DE		; Bump input pointer	LD	(HL),A		; Store char in buffer	INC	HL		; Bump buffer pointer	DJNZ	GMPW2		; Loop for # of chars	JR	CKMPWGMPW4	LD	(HL),' '	; Fill buffer with spaces	INC	HL		;   for any not entered	DJNZ	GMPW4;;	Convert to upper case and check validity;CKMPW	POP	HL		; Recover buffer start	PUSH	HL	LD	B,08H		; 8 chars in password	LD	A,(HL)		; Get 1st character	JR	CKMPW2CKMPW1	INC	HL	LD	A,(HL)	CP	' '		; Got to a space?	JR	Z,CKMPW7	CP	'0'		; Less than '0' is error	JR	C,INVMPW	CP	'9'+1		; 0-9 is okay after 1st char	JR	C,CKMPW3CKMPW2	CP	'A'		; Less than 'A' is error	JR	C,INVMPW	CP	'Z'+1		; A-Z is okay	JR	C,CKMPW3	CP	'a'		; Convert a-z to upper	JR	C,INVMPW	CP	'z'+1	JR	NC,INVMPW	RES	5,(HL)		; Make it upper caseCKMPW3	DJNZ	CKMPW1CKMPW4	POP	DE		; Point to buffer start	XOR	A	RET;CKMPW5	INC	HL	CP	(HL)		; No embedded spaces	JR	NZ,INVMPW;CKMPW7	DJNZ	CKMPW5	JR	CKMPW4;INVMPW	LD	HL,BADMPW$	; "Invalid pw	LD	A,63		; Set extended error	OR	A		; Set NZ condition	POP	DE		; Clean up the stack	RET;;	Reset any file open bits;UNOPEN	PUSH	HL		; Save buffer position	PUSH	BC	LD	B,08H		; 8 entries	INC	L		; DIR+1ZAP	RES	5,(HL)		; Clear file open bit	LD	A,32		; Size of a dir entry	ADD	A,L		; Point to next one	LD	L,A	DJNZ	ZAP		; Do 8 entries per dir sector	POP	BC	POP	HL	RET;$DSPLY	@@DSPLY			; Display a line	RET	Z	JR	IOERR;WRSYS	@@WRSSC			; Write the sector	JR	NZ,IOERR	@@VRSEC			; Verify it	CP	06H		; Must be system sector	RET	Z	JR	IOERR;WRSEC	@@WRSEC			; Write normal sector	RET	Z	JR	IOERR;;	Sector read routine;RDSEC	LD	HL,BUF1		; Point to buffer	@@RDSEC			; Read the sector	RET	Z		; Return if okay	CP	06H		; System sector okay, too	RET	Z;;	Error exits;IOERR	CP	63		; Extended error?	JR	Z,EXTERR	; Log it and quit	LD	H,00H		; Error code to HL	LD	L,A	PUSH	HL		; Save error code	OR	0C0H		; Short message, return	LD	C,A	@@ERROR			; Display error;	LD	HL,ABTJOB$	; "Job aborted...	@@LOGOT			; Log the message	POP	HL		; Recover error code	JR	QUIT$$;;	Internal error handler;NIXHARD	LD	HL,NIXHRD$	; "Can't do hard disk	DB	0DDHNOT0	LD	HL,NOT0$	; "Can'd do drive 0	DB	0DDHPRMERR	LD	HL,PRMERR$	; "Param error	DB	0DDHEXTERR	@@LOGOT			; Display the error	LD	HL,-1		; Set abort codeQUIT$$	JP	QUIT$;;	Read/write the granule allocation table;GATRD	DB	0F6H		; Set NZ for testGATWR	XOR	A		; Set Z for test	PUSH	HL	PUSH	AF	LD	D,(IY+09H)	; Get DIR cylinder	LD	HL,BUF1		; HL => I/O buffer	LD	E,L		; Set to sector 0	POP	AF	JR	Z,GATWR1	; Go if write	@@RDSSC			; Read system sector	LD	A,14H	JR	GATWR3;GATWR1	@@WRSSC			; Write system sector	JR	NZ,GATWR2	; Skip verify if error	@@VRSEC			; Verify the writeGATWR2	CP	06H		; Expect error 6	LD	A,15H		; Init "Gat write errorGATWR3	POP	HL	RET;;	Routine to check on floppy present;CKDRV	LD	A,40		; @@DCSTAT	RST	28H	JR	NZ,ILLEG	; Go on error	LD	A,44		; @RSTOR	RST	28H	LD	HL,BUF1		; Set up for mini ckdrv	PUSH	BC	@@TIME			; Get timer pointer	POP	BC	EX	DE,HL		; Point HL to heartbeat counter	DEC	HL	LD	A,47		; @RSLCT	RST	28H		; Wait until ready	LD	A,(HL)		; Get heartbeat count	ADD	A,20		; Init to + 500 msec	LD	D,A		; Store for timeout checkCK1	CALL	INDEX	JR	NZ,CK1		; Get no pulseCK2	CALL	INDEX	JR	Z,CK2		; Get pulseCK3	CALL	INDEX	JR	NZ,CK3		; Get no pulse	RET;INDEX	LD	A,(HL)		; Get time	CP	D		; Interval expired	JR	Z,ILLG1	LD	A,47		; @RSLCT	RST	28H	BIT	1,A		; Test for index pulse	RET;ILLG1	POP	HL		; Fix stackILLEG	LD	A,32		; 'illegal drive #	JP	IOERR;;	Messages;HELLO$	DB	'REPAIR'*GET	CLIENTALCAO$	DB	'Repair function complete',0DHABTJOB$	DB	'REPAIR aborted',0DHNOT0$	DB	'Can',27H,'t REPAIR drive 0',0DHPRMERR$	DB	'Parameter error',0DHBADMPW$	DB	'Invalid master password',0DHNIXHRD$	DB	'Can',27H,'t repair a hard drive',0DH;;	Parameter table;PRMTBL$	DB	80H	DB	23H	DB	'MPW'MRSP	DB	00H	DW	MPARM+1	DB	00H;;	Buffer areas;PSWDBUF	DS	8	;Password buffer	;EQU	2957HHASHBUF	DS	4	;Owner & user hashesFCB	DS	32;	ORG	$<-8+1<+8BUF1	DS	256	;EQU	2A00H;	END	BEGIN