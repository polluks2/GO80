;LBDUMP/ASM - DUMP command	TITLE	<DUMP - LS-DOS 6.3>;*GET	SVCEQU		; Get SVC macro equates;CR	EQU	13PAR_ERR	EQU	44	; Parameter error codeSINIT	EQU	3000HEINIT	EQU	SINIT;	ORG	2400H;DUMP	LD	A,@CKBRKC	; Check for break	RST	28H	JR	Z,BEGINA	; Go if not	LD	HL,-1		;   else abort	RET;BEGINA	LD	DE,FCB1		; Fetch the filespec	LD	A,@FSPEC	RST	28H	JP	NZ,SPCREQ	; Jump on error	LD	A,(DE)	CP	'*'	JP	Z,SPCREQ	; Cannot be a device	LD	A,@FLAGS	; Get flags table	RST	28H	PUSH	HL		; Save cmd line ptr	LD	H,(IY+26)	; Get SVC table MSB	LD	L,22*2		;   & point to @EXIT	LD	A,(HL)		; Get @EXIT LSB	INC	L	LD	H,(HL)		; Get @EXIT MSB	LD	L,A	LD	(TPARM+1),HL	; Init transfer to @EXIT	POP	HL;;	Search for parameters;	LD	DE,PRMTBL$	; Get the parameters	LD	A,@PARAM	RST	28H	JP	NZ,PRMERR	LD	HL,(EPARM+1)	; Check on end > start	LD	BC,(SPARM+1)	XOR	A	SBC	HL,BC	JP	C,ENLTST	; Jump on start > end	LD	HL,SINIT	; Point to lowest possible	DEC	HL		; Reduce for compare	SBC	HL,BC	JP	NC,STLT30	; Go if start < minimumAPARM	LD	BC,0		; ASCII text or code cim	LD	A,B	OR	C	JR	NZ,DUMPTXT	; Go if ascii	LD	DE,NAMFLD	; Get up to 6 char	LD	HL,FCB1		;   filename to stuff	LD	B,06H		;   as file header$?1	LD	A,(HL)		; Get char	CP	'0'		; Stop on non-alpha	JR	C,$?3	CP	'9'+1		; use if 0-9	JR	C,$?2	CP	'A'		; Check on A-Z	JR	C,$?3	CP	'Z'+1	JR	NC,$?3$?2	LD	(DE),A		; Transfer this char	INC	HL		; Bump input pointer	INC	DE		;   and output pointer	DJNZ	$?1		; Loop 6 chars max	JR	$?4$?3	LD	A,' '		; Place blanks to fill	LD	(DE),A		;   out to 6 chars	INC	DE	DJNZ	$?3$?4	LD	HL,LMFEXT	; Use /LMF extension	JR	DUMPCIMDUMPTXT	LD	HL,TXTEXT	; Use /TXT extensionDUMPCIM	LD	DE,FCB1	LD	A,@FEXT		; Set default extension	RST	28HLPARM	LD	BC,0		; Get LRL parameter	LD	A,B		; Test for > 256	OR	A		; If high-order = 0	JR	Z,LP1		; Just use low order	DEC	A		; Test for high = 1	JP	NZ,PRMERR	; Jump if not!	OR	C		; Get low order	JP	NZ,PRMERR	; Low must be 0!LP1	OR	C		; Merge low order	LD	B,A	LD	HL,BUFFER	; Point to buffer	LD	A,@INIT		; INIT the file	RST	28H	JP	NZ,IOERR	; Go if init error;;	Display the filespec being created;	LD	BC,(FCB1+6)	; Get DEC and drive	LD	DE,FCB2		; Point to FCB area	PUSH	DE	LD	A,@FNAME	; Fetch the name	RST	28H	POP	HL	JP	NZ,IOERR	; Quit on error	LD	A,20H		; Scan until ETX charFNLP	INC	HL	CP	(HL)	JR	C,FNLP	LD	(HL),CR		; Replace with CR	LD	HL,DUMP$	LD	A,@LOGOT	; Display "Dumping...	RST	28H;	LD	DE,FCB1		; Get dump FCB	LD	A,(APARM+1)	; Chk if ASCII param used	OR	A	JR	NZ,SPARM	;   and go if so	LD	A,5		; Name header	CALL	PUTOUT	LD	A,6		; Name length	CALL	PUTOUT	LD	B,6		; Init loop	LD	HL,NAMFLD$?5	LD	A,(HL)	INC	HL	CALL	PUTOUT		; Output the filename	DJNZ	$?5;SPARM	LD	HL,SINIT	; Get starting address$?7	PUSH	HL		; Chk on write of	LD	B,H		;   last byte written	LD	C,LEPARM	LD	HL,EINIT-1	; Where to end	INC	HL	XOR	A	SBC	HL,BC	JR	Z,$?10		; Go if at end	LD	B,254		; 254 byte blocks	LD	A,H		; A full sector left	OR	A		;   to write?	JR	NZ,$?8	LD	A,L	CP	0FFH	JR	NC,$?8		; If less than full	LD	B,L		;   reset len$?8	POP	HL	LD	A,(APARM+1)	OR	A	JR	NZ,$?9		; Bypass if TXT	INC	A		; Init start of block	CALL	PUTOUT	LD	A,B		; Get block length	ADD	A,02H		; Add two for load address	CALL	PUTOUT		;   and write it out	LD	A,L	CALL	PUTOUT		; Write low order load addr	LD	A,H	CALL	PUTOUT		; Write high order load addr$?9	LD	A,(HL)		; Write a load block	INC	HL	CALL	PUTOUT	DJNZ	$?9	JR	$?7		; Loop for more;$?10	POP	HL		; Stack integrity	LD	A,(APARM+1)	; No TRAADR if TXT	OR	A		;   or TRAADR if not TXT	JR	Z,TRAADRETXPARM	LD	BC,3		; Get ETX character	LD	A,C	LD	HL,ETXRESP	BIT	7,(HL)		; Value input means	JR	NZ,PUTETX	;   put the ETX given	LD	A,(BC)		; In case string	BIT	5,(HL)		; String input puts the	JR	NZ,PUTETX	;   given character	BIT	6,(HL)		; Flag input gives ETX=3	JR	Z,CLSFIL	;   if ETX=on	LD	A,3	JR	PUTETXTRAADR	LD	A,02H		; Get traadr header	CALL	PUTOUT	LD	A,02H		; length = 2	CALL	PUTOUTTPARM	LD	HL,0		; Get transfer address	LD	A,L	CALL	PUTOUT		; Write low order	LD	A,HPUTETX	CALL	PUTOUT		; Write high order or ETXCLSFIL	LD	A,@CLOSE	; Close the file	RST	28H	LD	HL,0	RET	Z		; Back on no error	JR	IOERR		; Else show it;PUTOUT	LD	C,A		; Get char in C	LD	A,@PUT		; Test each byte transfer	RST	28H	RET	Z		; Back if no error	POP	HL		; Pop return address	DB	21H		; Skip LD A,## instrPRMERR	LD	A,PAR_ERR	; "Parameter error"IOERR	LD	L,A		; Error code to HL	LD	H,00H	OR	0C0H		; Abbrev and return	LD	C,A	LD	A,@ERROR	; Show the error	RST	28H	RET;;	Internal error routine;STLT30	LD	HL,STLT30$	DB	0DDHENLTST	LD	HL,ENLTST$	DB	0DDHSPCREQ	LD	HL,SPCREQ$	LD	A,@LOGOT	RST	28H	LD	HL,-1	RET;;	Messages;ENLTST$	DB	'START or END error ',CRSTLT30$	DB	'Start less than X',27H,'3000',27H,CRSPCREQ$	DB	'File spec required',CRLMFEXT	DB	'LMF'TXTEXT	DB	'TXT';VAL	EQU	80HSW	EQU	40HSTR	EQU	20HSGL	EQU	10H;PRMTBL$	DB	80H		; 6.X style table;	DB	VAL!SGL!5,'START',0	DW	SPARM+1	DB	VAL!SGL!3,'END',0	DW	EPARM+1	DB	VAL!SGL!3,'TRA',0	DW	TPARM+1	DB	SW!SGL!5,'ASCII',0	DW	APARM+1	DB	VAL!SGL!3,'LRL',0	DW	LPARM+1	DB	VAL!3,'ETX'ETXRESP	DB	0	DW	ETXPARM+1;	DB	00H		; End of param table;DUMP$	DB	'Dumping: '	; FCB2 must followFCB2	DS	32NAMFLD	DS	6FCB1	DS	32;	ORG	$<-8+1<+8;BUFFER	DS	256LAST	EQU	$-1;	END	DUMP