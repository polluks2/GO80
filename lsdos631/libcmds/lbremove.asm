;LBREMOVE/ASM - REMOVE command	TITLE	<REMOVE - LS-DOS 6.3>;*GET	SVCEQU			; System SVC equates*GET	VALUES			; Misc equates;	ORG	2400H;REMOVE	LD	(SAVESP+1),SP	; Save stack pointer	LD	A,@CKBRKC	; Check break key	RST	28H	JR	NZ,ABORT	; Go if down	CALL	REMOV		; Do remove	LD	HL,0		; Set no errorSAVESP	LD	SP,0		; Recover SP	LD	A,@CKBRKC	; Clear BREAK bit	RST	28H	RET			; And leave;;;ABORT	LD	HL,-1		; Set error code	JR	SAVESP		; And exit;;	Special message exit;SPCREQ	LD	HL,SPCREQ$	; Filespec required	LD	A,@LOGOT	RST	28H	JR	ABORT		; Exit;;;IOERR	LD	L,A		; Error code to HL	LD	H,00H	OR	0C0H		; Abbrev & return	LD	C,A	LD	A,@ERROR	; Show message	RST	28H	JR	SAVESP		; And exit;;	REMOV - Remove file(s) or device(s);REMOV	PUSH	HL		; Save INBUF$ pointerREMOV0	XOR	A		; Set Z flag for loopREMOV1	POP	HL	JP	NZ,IOERR;;	Skip leading spaces, exit on terminator;	LD	A,@CKBRKC	; Check for break	RST	28H	JR	NZ,ABORT	; Abort if so;	DEC	HLREMOV2	INC	HL		; Skip past spaces	LD	A,(HL)	CP	' '	JR	Z,REMOV2	RET	C		; Return on terminator;;	Hit a non-space char - is this a filespec?;	LD	DE,FCB		; Fetch the filespec	LD	A,@FSPEC	RST	28H	JP	NZ,SPCREQ	; Jump on spec error	PUSH	HL		; Save INBUF$ pointer;;	Transfer the filespec to buff without password;	PUSH	DE		; Save FCB ptr	EX	DE,HL		; HL => FCB	LD	DE,FILESPC	; DE => Filespec	CALL	MOVSPC		; Move filespec	LD	A,CR		; End it with C/R	LD	(DE),A	POP	DE		; Recover FCB;;	Are we removing a device?;	LD	A,(DE)		; Get spec char	CP	'*'		; Is it a device?	JR	Z,RMVDVC	; Go if it is;;	Removing a file - does it exist?;	LD	A,@OPEN		; Open the file	RST	28H	JR	Z,GOODOPN	; Z - it does exist	CP	42		; LRL open fault?	JR	NZ,REMOV1	; No - abort;;	Successful open - can we remove the file?;GOODOPN	LD	A,(FCB+1)	; Get access level	AND	07H	CP	02H		; REMOVE access?	LD	A,37		; "Illegal access..."	JP	NC,IOERR	; Go if we can't;;	Is there a drivespec in the filespec?;	LD	HL,FILESPC	; Point to itFLOOP	LD	A,(HL)		; Get character	CP	CR+1		; End of filespec?	JR	NC,CHKDSPC;;	Drivespec wasn't specified - put it on;	LD	(HL),':'	; Append drivespec onto	INC	HL		;   end of filespec	LD	A,(FCB+6)	; Get drive in A	ADD	A,'0'		; Convert to ASCII	LD	(HL),A		; Put it on	INC	HL		; Bump pointer	LD	(HL),CR		; Terminate with C/R	JR	SHOWFIL		; Display name & kill it;;	Stop when ":" found or terminator;CHKDSPC	CP	':'		; Already have one?	INC	HL	JR	NZ,FLOOP;;	Display "Removing filespec" and remove it;SHOWFIL	CALL	SHOWIT		; "Removing"	LD	A,@REMOV	; Remove the file	RST	28H	JR	REMOV1		; Loop for more;;	Display filespec or devspec;SHOWIT	LD	HL,SHOW$	; Show what we are	PUSH	DE		; Save FCB pointer	LD	A,@DSPLY	;   for removing	RST	28H	POP	DE		; Get FCB back	JR	NZ,REMOV1	; NZ - abort	RET			; else return Z;;	Routine to remove a device;RMVDVC	PUSH	DE		; Xfer FCB ptr to IX	POP	IX	LD	E,(IX+01H)	; Get device name	LD	D,(IX+02H)	;   in DE;;	Routine to find a device in the device tables;	LD	A,@GTDCB	; Find this DCB	RST	28H	JR	NZ,REMOV1	; Abort if not found;;	Found device in tables - is it killable?;DEV4	LD	(RENDEV+1),DE	; Try to rename it	PUSH	HL		; Save address pointer	LD	HL,RENDEV	LD	E,L	LD	D,H	LD	A,@RENAM	RST	28H	POP	HL		; Recover addr pointer	CP	19		; If not "illegal name"	JP	NZ,REMOV1	;   then error;;	Device not a system device - is it in use?;CKNILL	BIT	3,(HL)		; Test NIL device	JR	NZ,REMOVIT	; OK if NIL (not in use)	LD	A,27H		;   else "Device in use"	OR	A		; Set NZ flag	JP	REMOV1		;   and return error;;	Remove the device;REMOVIT	CALL	SCND4		; Zero 8 byte DCB area;;	Any other device routes to to removed one?;SCNDCB	LD	DE,'IK'		; Point to begin of area	LD	A,@GTDCB	RST	28HSCND1	BIT	4,(HL)		; Routed device?	JR	Z,SCND2		; Jump if its not	PUSH	HL		; Save DCB pointer	INC	L		; Bypass TYPE code	LD	A,(HL)		; Get route vector	INC	L	LD	H,(HL)		;   into HL	LD	L,A	LD	A,(HL)		; Get TYPE code of nest	POP	HL		; Recover DCB pointer	OR	A		; If TYPE = 0, we killed	JR	NZ,SCND2	;   the routed device	LD	A,08H	OR	(HL)		; Convert to NIL if so	LD	(HL),A	JR	SCNDCB;;	Point to the next device;SCND2	LD	A,L		; Advance to next DCB area	ADD	A,08H		; Loop through all devices	LD	L,A		;   while checking	JR	NZ,SCND1	; Loop until table end;;	Device table cleared - Now zero the DCB/FCB;	PUSH	IX		; Transfer vector to HL	POP	HL	CALL	SCND4	CALL	SHOWIT		; Show "Removing"	JP	REMOV0		; Next....;SCND4	LD	B,08H		; Clear 8 bytes	XOR	ASCND5	LD	(HL),A		; Do it	INC	HL	DJNZ	SCND5	RET;;	Transfer a filespec from HL to DE;MOVSPC	LD	A,(HL)		; Get spec character	CP	'/'		; Extension?	JR	NZ,CKSPACE	; No - check if space	INC	HL		; Is the next character	LD	A,(HL)		;   valid?	CP	'A'	JR	C,CKSPACE	; No - don't output it	DEC	HL		; Back one	LD	A,(HL)		; Get slashCKSPACE	CP	' '	RET	C		; Return on space or less	CP	'.'		; Password?	JR	NZ,MOVSPC1	; Go if notSKIPPW	INC	HL		; Skip the password	LD	A,(HL)	CP	' '	RET	C		; Back on terminator	CP	':'	JR	NZ,SKIPPWMOVSPC1	LDI			; Move the char	JR	MOVSPC;;	Messages;SPCREQ$	DB	'File spec required',CRRENDEV	DB	'*RS'SHOW$	DB	'Removing: 'FILESPC	DS	15FCB	DB	00H	DS	31;	END	REMOVE