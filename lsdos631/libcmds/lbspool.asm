;LBSPOOL/ASM - Spool command	TITLE	<SPOOL - LS-DOS 6.3>;;PAR_ERR	EQU	44ETX	EQU	3		; End of textCR	EQU	13		; Carriage returnRST28	EQU	28H		; RST 28 addressLOWBUF$	EQU	2300H		; Low memory disk I/O bufferKITSK@	EQU	31		; FLGTAB+31;*GET	SVCMAC			; System SVC macros*GET	LOWCORE/EQU		; Low core equates;;	ORG	2400H;;	Save stack and call Spool routine;SPOOL	LD	(SAVESP+1),SP	; Save stack ptr	CALL	SPOOL1		; Call SPOOL codeEXIT	LD	HL,0		; Successful exit;;	Pick up stack and clear any pending <BREAK>;SAVESP	LD	SP,0		; Pick up original SP	@@CKBRKC		; Clear break	RET			; Return to DOS;;	Informative message exit;CLEARD	LD	HL,CLEARD$	DB	0DDHRESUMD	LD	HL,RESUMD$	DB	0DDHPAUSED	LD	HL,PAUSED$	DB	0DDHSPLACT	LD	HL,SPLACT$	DB	0DDHSPLONM	LD	HL,SPLONM$	DB	0DDHSPLOFM	LD	HL,SPLOFM$	DB	0DDHSPLOPM	LD	HL,SPLOPM$	DB	0DDHPRMBGM	LD	HL,PRMBGM$	@@LOGOT	JR	EXIT;;	I/O Error Processor;PRMERR	LD	A,PAR_ERR	; Parameter ErrorIOERR	LD	L,A		; Set HL = Error #	LD	H,0	OR	0C0H		; Short msg & return	LD	C,A		; Error code to C for	@@ERROR			; Display error message	JR	SAVESP		; Exit;;	Internal Error message handler;BADDCB	LD	HL,BADDCB$	DB	0DDHNOFIND	LD	HL,NOFIND$	DB	0DDHINUSE	LD	HL,INUSE$	DB	0DDHCANT	LD	HL,CANT$	@@LOGOT			; Log error message	LD	HL,-1		; Set abort code	JR	SAVESP		; Exit;;	SPOOL1 - Set up system to spool output;SPOOL1	PUSH	HL		; Save INBUF$ pointer	@@FLAGS			; Get flag table pointer	LD	IX,PRMSAV	; Point to param save area	LD	DE,SPOOL$	; If already resident,	@@GTMOD			;   don't need to check				;   if memory available	JR	NZ,SPL1		; Go if not found	LD	(SVDCB),DE	; Save the DCB pointer	LD	(SVBGN),HL	; Save module begin	LD	HL,4		; Get param save pointer	ADD	HL,DE	LD	(HIPARM),HL	; Save for use by clear	PUSH	IX		; Also put address in DE	POP	DE		; Shift saved params into	LD	BC,11		;   spool driver front end	LDIR	LD	E,(IX+04H)	; Get previous MPARM+1	LD	D,(IX+05H)	LD	(MPARM+1),DE	; Save as new default	LD	E,(IX+06H)	; Get previous DPARM	LD	D,(IX+07H)	LD	(DPARM+1),DE	; Save as new default	LD	A,(IX+0AH)	; Get old bank #	AND	7FH		; Strip off high bit	LD	(BPARM+1),A	; Save as defaultSPL1	POP	HL		; Get INBUF$ pointer;;	Fetch device spec to spool;SPL2	LD	DE,SPLDCB	; Fetch dev spec	@@FSPEC	PUSH	HL		; Save inbuf$	JR	NZ,USEPR	; Use *PR if no entry	LD	A,(DE)		; If dev spec not found	CP	'*'		;   maybe it was the	JR	Z,SPL2A		;   the spool file spec;;	File spec fetched - Move to spool FCB;	EX	DE,HL		; DCB to HL	LD	DE,SPLFCB	; Point to spool FCB	PUSH	DE	LD	BC,32	LDIR			; Move it in	LD	HL,PR$		; Move in default spec	LD	DE,SPLDCB	;   for spool device	LD	BC,4	LDIR	XOR	A	POP	DE		; Point to SPLFCB	JR	SPL2B		; Go - we have specUSEPR	LD	HL,PR$		; Move in default spec	LD	DE,SPLDCB	LD	BC,4	LDIR;;	Fetch the file spec to use as disk spool buffer;SPL2A	POP	HL		; Get INBUF$ ptr	LD	DE,(SPLDCB+1)	; Stuff device name for	LD	(DSKSPC),DE	;   default spool filename	LD	DE,SPLFCB	; Fetch spool filespec	@@FSPEC	PUSH	HL		; Save separator charSPL2B	PUSH	AF		;   and line pointer	LD	HL,DSKSPC	; Default to XX/SPL	JR	Z,SPL2C	@@FSPEC			;   If user entered noneSPL2C	LD	HL,SPLEXT	; Default ext to SPL	@@FEXT	POP	AF		; Recover line pointer	POP	HL	CP	':'		; Drive entered?	JR	NZ,GETPRMSPL3	LD	A,(DE)		; Wait for ETX or CR	CP	CR	JR	Z,SPL4	CP	ETX	JR	Z,SPL4	INC	DE	JR	SPL3;SPL4	LD	A,':'		; Stuff colon for drive	LD	(DE),A	INC	DE	LD	A,(HL)		; Get possible drive #	CP	0DH	JP	Z,PRMERR	; Param error if EOL	INC	HL	LD	(DE),A		; Stuff drive number	INC	DE	LD	A,ETX		; End of text	LD	(DE),A;;	Get parameter entries;GETPRM	LD	DE,PRMTBL$	; Get parameters	@@PARAM	JP	NZ,PRMERR	; Jump on param error;;	Check on OFF;OPARM	LD	DE,0		; Get OFF param	INC	E		; On or off?	JP	Z,SPLOFF	; Jump if off;;	Check on RESUME despooling;RPARM	LD	DE,0		; Get RESUME param	INC	E		; Was it used?	JP	Z,RESUME	; Jump of so;;	Check on PAUSE parameter;PPARM	LD	DE,0		; Get PAUSE param	INC	E		; Specified?	JP	Z,PAUSE		; Go if so;;	Check on CLEAR parameter;CPARM	LD	DE,0		; Get CLEAR  param	INC	E		; Specified?	JP	Z,CLEAR		; Go if it was;;	Assume request to be install;	BIT	0,(IY+'C'-'A')	; Can't insert spool if	JP	NZ,CANT		;   memory frozen	BIT	0,(IY+'D'-'A')	; Is spooler already on?	JP	NZ,SPLONM	; Quit if so;;	If module resident, check param sizes;	LD	DE,SPOOL$	@@GTMOD	JR	NZ,FNDDCB	; Go if no area in mem	LD	L,(IX+04H)	; Prev MPARM	LD	H,(IX+05H)	LD	DE,(MPARM+1)	OR	A	SBC	HL,DE		; Old must = new	JP	NZ,PRMBGM	; Abort if bad	LD	L,(IX+06H)	; D param	LD	H,(IX+07H)	LD	DE,(DPARM+1)	SBC	HL,DE	JP	NZ,PRMBGM	; Abort if not same as old	LD	A,(IX+0AH)	; Bank number	AND	7FH		; Strip high bit	LD	HL,(BPARM+1)	CP	L	JP	NZ,PRMBGM	; Abort if not same as old;;	Find device to spool;FNDDCB	LD	DE,(SPLDCB+1)	; Pick up device name	@@GTDCB			; Find in device tables	JP	NZ,IOERR	; Jump if not foundCKRTE	BIT	4,(HL)		; Routed device?	JR	Z,CKLNK		; Bypass if notCKRTE1	INC	L		; Point to vector	LD	A,(HL)		; Pick up vector DCB	INC	L		;   address & test it	LD	H,(HL)	LD	L,A	JR	CKRTECKLNK	BIT	5,(HL)		; If linked, get DCB	JR	NZ,CKRTE1	BIT	6,(HL)		; If filtered, trace to	JR	Z,SETDVR	;   its DCB in header	LD	D,H		; Save to chk inactive	LD	E,L	INC	L	LD	A,(HL)		; Get vector to module	INC	L	LD	H,(HL)	LD	L,A	LD	BC,4		; HL now points to the	ADD	HL,BC		;   entry point.  Get its	LD	C,(HL)		;   DCB address by peeking	INC	C		;   past the name field	ADD	HL,BC	LD	A,(HL)		; Get low order	INC	HL	LD	H,(HL)		; Get high order	LD	L,A	PUSH	HL		; If DCB is itself, then	SBC	HL,DE		;   it's some error	POP	HL		;   else continue to	JR	NZ,CKRTE	;   search the chain	JP	BADDCB;;	Found the device;SETDVR	BIT	1,(HL)		; Device handle @PUT?	JP	Z,BADDCB	; Can't do if not	LD	(MODDVR),HL	; Stuff DCB table address;;	Check BANK spec for availability;BPARM	LD	BC,0		; Pick up the bank number	LD	A,C		; If bank = 0, no need to	OR	B		;    test availability	JR	Z,LOCDCB	CP	1FH		; This version supports	JP	NC,PRMERR	;   banks 0-31	SET	7,A		; Set for transfer	LD	(BANKX1),A	; Stuff for module A	LD	(BANKX2),A	LD	(BANKX3),A	LD	(SPLBNK),A	LD	B,02H		; Test if bank 1-x	@@BANK			;   is available	JP	NZ,INUSE	; Quit if not available;;	Locate a spare DCB for the spool module;LOCDCB	LD	DE,0		; Find spare DCB	@@GTDCB	LD	A,33		; Init "No device space...	JP	NZ,IOERR	; Go if no spare DCBs	LD	(S0DCB),HL	; Save pointer	LD	(S0DCB1),HL	PUSH	HL		; Save DCB field pointer	LD	DE,'/S'		; Let's find a link nameNAMLP	INC	D		; Bump "2nd" character	@@GTDCB			; If we find this name	JR	Z,NAMLP		; Look for another	POP	HL		; Get DCB pointer	SET	3,(HL)		; NIL in case of error	LD	BC,6	ADD	HL,BC		; Point to name field	LD	(HL),E		;   & stuff in the	INC	L		;   selected spool name	LD	(HL),D;;	Create a disk file for spooling;	LD	DE,(DPARM+1)	; Get disk size	LD	(IX+06H),E	; Save DPARM for next time	LD	(IX+07H),D	;   SPOOL is entered	LD	A,D	OR	E	JR	Z,PUHIGH	; No file if DISK=0	LD	DE,SPLFCB	; Init the spool file	LD	HL,BUFFER	SET	0,(IY+'S'-'A')	; Init file open bit	@@INIT	JP	NZ,IOERR	; Jump on init errorDPARM	LD	BC,4		; D param (default = 4k)	LD	A,B		; Param error if > 4095K	AND	0F0HPRMERRA	JP	NZ,PRMERR	; Go if size too big	SLA	C		; Multiply K by 4	RL	B		;   to calculate sectors	SLA	C	RL	B	LD	(IPLDSK1+1),BC	; Stuff disk K	DEC	BC		; Adjust for 0 offset	@@POSN			; Position to end	@@WRITE			; Write a junk sector	JP	NZ,IOERR	; Jump on write error	@@REW			; Seek back to 0	@@WEOF			; End of file mark	LD	BC,(SPLFCB+6)	; Get DEC and drive	@@DIRRD			; Read its DIR record	JP	NZ,IOERR	; Quit if read error	INC	HL		; Point to DIR+1	SET	7,(HL)		; Turn on CREATE bit	@@DIRWR	JP	NZ,IOERR	; Quit on write error	LD	HL,LOWBUF$	; Revise I/O buffer	LD	(SPLFCB+3),HL	;   in file's FCB;;	Get current HIGH$;PUHIGH	LD	HL,0		; Set HLB to zero to	LD	B,L		;   fetch HIGH$	@@HIGH$	LD	(GBUF1+1),HL	; Save for later	LD	(OLDHI+1),HL;;	If bank RAM, recalculate MPARM;	LD	A,(BPARM+1)	; Alternate banks requested?	OR	A	JR	Z,MPARM		; Go if not;;	Recalculate MEM parameter to use the;	maximum space in bank RAM.  Formula is;	[((32768-512 for module) - (DPARM+1)*16)];	divided by 260.  The 260 is derived from;	256 byte page plus 4 bytes for pointers.;	Then revise to K from pages.;	LD	HL,(DPARM+1)	INC	HL		; Bump by one	ADD	HL,HL		; Times 16	ADD	HL,HL	ADD	HL,HL	ADD	HL,HL	LD	C,L		; Transfer to BC for	LD	B,H		;   subtract	LD	HL,32768-512	; RAM space - module space	XOR	A		; The remainder is for	SBC	HL,BC		;   MEM pages and ptrs	SRL	H		; A divide by 260 is	RR	L		;   accomplished by	LD	C,260/2		;   div 2 and div 130	@@DIV16	LD	C,L	LD	B,H	SRL	C		; Calculate	SRL	C		;   K = pages / 4	JR	CALCPTR;;	Calculate memory buffer space requested;MPARM	LD	BC,1		; MEM param - default 1K	LD	A,B		; Test entry - must be	OR	A		;   Less than 33K	JR	NZ,PRMERRA	; High order must be 0	CP	C		; Mem = 0?	JP	Z,PRMERR	; Yes, parameter error	LD	A,H		; Get high order HIGH$	SUB	81H		; Can't go below 8000H	RRA			; Divide by 2	SRL	A		;   and again to calc K	SUB	C		; Reduce by K of request	JP	C,PRMERR	; Error if below 8000HCALCPTR	LD	(IX+04H),C	; Stuff MEM param into	LD	(IX+05H),B	;   save area;;	Add memory buffer space to disk space;	LD	HL,(DPARM+1)	; Get disk K	ADD	HL,BC		; Calculate pointer	ADD	HL,HL		;   buffer space required	ADD	HL,HL		;   (D+M)*16 + 4 extra	INC	HL		;   used to detect the end	ADD	HL,HL	ADD	HL,HL;;	Retrieve high memory space for buffers;	PUSH	HL	LD	L,(IX+00H)	; Get saved HIGH$ entry	LD	H,(IX+01H)	LD	A,L		; If <> 0 then SPOOL	OR	H		;   is resident	JR	NZ,GBUF2GBUF1	LD	HL,0		; Get current high	LD	(IX+00H),L	; Save the value	LD	(IX+01H),HGBUF2	LD	(SVEND+1),HL	; Stuff highest byte used;;	If bank RAM used, reset to X'FFFF';	INC	HL		; Point to lower 256	LD	L,00H		;   byte block boundary	LD	A,(BPARM+1)	; Bank specified?	OR	A	JR	Z,$+3		; Jump if not	LD	H,L		; Set to FFFF+1 = 0	LD	C,A		; Reside bank for	LD	B,00H		;   module B	@@BANK	JP	NZ,IOERR	; Quit on bank error	LD	A,(IX+04H)	; Pick up MEM param	RLCA			; MEM*4 = # of	RLCA			;    256 byte blocks	LD	B,A		; Go back that number	NEG			;   of blocks needed	ADD	A,H		; HL now reserves buffer	LD	H,A		;   blocks for MEM	LD	(PUTNXT$),HL	; Stuff pointers to begin	LD	(GETNXT$),HL	;   of memory blocks	LD	C,H	POP	DE		; Get (D+M)*16+4	XOR	A		; Backup the # of D+M	SBC	HL,DE		;  sectors;;	Initializze the memory pointers;	PUSH	HL		; Save pointerIPLMEM	LD	(HL),00H	; Init the 4 byte fields	INC	HL		;   for each of the disk	LD	(HL),00H	;   and memory block ptrs	INC	HL	LD	(HL),C		; Stuff memory high order	INC	HL	LD	(HL),00H	INC	HL	INC	C		; Bump memory high order	DJNZ	IPLMEM;;	Initialize the disk pointers;IPLDSK1	LD	DE,0		; Pick up # of disk sectors	LD	A,D	OR	E	JR	Z,IPLDSK3	; Bypass if none	LD	BC,0		; Set up a disk pointerIPLDSK2	LD	(HL),00H	;   for each disk block	INC	HL	LD	(HL),00H	INC	HL	LD	(HL),C		; Stuff block number	INC	HL	LD	(HL),B	SET	7,(HL)		; Set bit 7 to indicate	INC	HL		;  this ptr is for disk	INC	BC		; Inc block number	DEC	DE	LD	A,D		; Test if finished	OR	E	JR	NZ,IPLDSK2	; Loop if notIPLDSK3	LD	(HL),00H	; One more used to	INC	HL		;   indicate the end	LD	(HL),00H	;   of the pointer fields	INC	HL	LD	(HL),0FFH	INC	HL	LD	(HL),0FFH	POP	HL		; Recover start of ptrs	PUSH	HL	LD	(MAPPTR$),HL	; Save for later use	LD	(PUTBLK$),HL	LD	(GETBLK$),HL	LD	A,H		; Stuff 1st MEM block ptr	LD	(HL),L		;   with table address	INC	HL	LD	(HL),A;;	Modify driver for spooling device vector address;	LD	A,(IY+KITSK@)	; Transfer device hook	LD	L,(IY+KITSK@+1)	LD	H,(IY+KITSK@+2)	LD	(GETBLK0),A	LD	(GETBLK0+1),HL	PUSH	IY		; Set up address	POP	DE		;   in despooler	LD	HL,'P'-'A'	; PFLAG use to	ADD	HL,DE		;   determine if spooler	LD	(DFLAG),HL	;   is paused	LD	(DFLAG1),HL	POP	BC		; Start of MEM block table	DEC	BC		; Get last byte to use	PUSH	BC	LD	DE,DVRBEND	; Point to module B	LD	HL,RELTABB	; Point to table	CALL	RELO		; Relocate absolute refs;;	If bank 0, then wipe out module A;	LD	A,(BPARM+1)	; Alternate bank used?	OR	A	JR	NZ,MOVMODB	; Skip next if so	LD	HL,FIX1		; Shift in JPs for the	LD	DE,PUTCHAR	;   bank transfer	LD	BC,5	LDIR	LD	DE,FIX2UP	LD	C,05H	LDIR	LD	DE,GETBLK	LD	C,05H	LDIRMOVMODB	POP	DE		; Get last byte to use	LD	HL,DVRBEND	; Last byte of module	LD	BC,DVRBEND-DVRBBGN+1	LDDR	PUSH	DE		; New last byte;;	Switch to bank 0 always;	LD	BC,0		; Set func 0, bank 0	@@BANK	JP	NZ,IOERR	; Quit on bank error	POP	BC;;	If module B is in bank x, switch HIGH for A;	LD	A,(BPARM+1)	; Get alt bank resp	OR	A	JR	Z,STORHI	; Go if none used	LD	C,A		; Reserve the bank	LD	B,03H		; Set function #3	@@BANK	JP	NZ,IOERR	; Quit on bank error	LD	BC,(SVEND+1)	; Pick up bank-A HIGH$STORHI	PUSH	BC;;	Relocate absolute addresses in module A;	LD	DE,DVRAEND	; Point to last used in A	LD	HL,RELTABA	; Point to relo table	CALL	RELO		; Relocate absolute refs	POP	DE		; Get last byte to use	LD	HL,DVRAEND	; Last byte of module	LD	BC,DVRAEND-DVRABGN+1	LDDR	LD	HL,PRMSAV+2-DVRABGN+1	ADD	HL,DE		; Data area in himem	LD	(HL),E	INC	HL	LD	(HL),D		; Save HIGH$ there;;	Stuff new HIGH$OLDHI	LD	HL,0		; Pick up old HIGH$	SBC	HL,DE		; Check if old HIGH$ is	JR	C,NOSET		;   already lower	EX	DE,HL		; New high$ to HL	@@HIGH$			; Set new HIGH$	EX	DE,HLNOSET	INC	DE		; Point to module start	LD	HL,(S0DCB)	; Pick up module DCB ptr	LD	(HL),46H	;   & set to filter	INC	HL		; Point to DCB vector pos	LD	(HL),E		; Put entry point of module	INC	HL		;   into the DCB	LD	(HL),D	LD	DE,DSPLTCB	; Calculate entry pointRX05	EQU	$-2	LD	C,09H		; This will be task 9	@@ADTSK	LD	HL,GETBLK	; Now update device hookRX06	EQU	$-2;;	Interface to KITSK - No need to DI/EI;	as KITSK not used by interrupts;	LD	(IY+KITSK@+2),H	; Move in device	LD	(IY+KITSK@+1),L	;   vector and a	LD	A,0C3H		;   jump opcode	LD	(IY+KITSK@),A	SET	0,(IY+'D'-'A')	; Turn on device flag bit	SET	7,(IY+'P'-'A')	; Show not paused;;	Filter the specified device driver;	LD	HL,(MODDVR)	; Ptr to device DCB	LD	DE,(S0DCB)	; Ptr to spooler DCB	LD	B,03H	DI			; Interrupts off during swapSWAP	LD	C,(HL)		; Swap first three bytes	LD	A,(DE)		;   of the DCBs	LD	(HL),A	LD	A,C	LD	(DE),A	INC	L	INC	E	DJNZ	SWAP		; Loop three times	EI			; Enable interrupts again	JP	SPLACT		; Set complete;;	Routine to PAUSE despooling;PAUSE	BIT	0,(IY+'D'-'A')	; Spool resident?	JP	Z,SPLOFM	; Quit if not	BIT	7,(IY+'P'-'A')	; Check first if active	RES	7,(IY+'P'-'A')	;   then turn off	LD	HL,SPLOPM	; Quit if already paused	JP	PAUSED;;	Routine to RESUME despooling;RESUME	BIT	0,(IY+'D'-'A')	; Check first if resident	JP	Z,SPLOFM	; Quit if not	BIT	7,(IY+'P'-'A')	; See if despooling now	SET	7,(IY+'P'-'A')	;   then turn on	JP	NZ,SPLONM	; Can't resume if so	JP	RESUMD;;	Routine to turn off the spooler;SPLOFF	BIT	0,(IY+'D'-'A')	; Test if off already	JP	Z,SPLOFM	; Go if off now	LD	DE,SPOOL$	; Find out where spooler is	@@GTMOD	JP	NZ,NOFIND	; Quit if not there	RES	0,(IY+'D'-'A')	;   else turn off	RES	7,(IY+'P'-'A')	; Show paused also	LD	BC,GETBLK0-DVRABGN	ADD	HL,BC		; Point to KITSK@ swap	LD	A,(HL)	LD	(IY+KITSK@),A	; Restuff KIHOOK	INC	HL	LD	A,(HL)	LD	(IY+KITSK@+1),L	INC	HL	LD	A,(HL)	LD	(IY+KITSK@+2),A	LD	C,09H		; Remove task 9 from	@@RMTSK			;   the task processor;;	Attempt to reclaim memory space;	LD	HL,0		; Get current HIGH$	LD	B,L	@@HIGH$	LD	E,(IX+02H)	; Get HIGH$ after spool	LD	D,(IX+03H)	;   was installed	XOR	A	SBC	HL,DE		; Is it the same now?	LD	E,(IX+00H)	; Get HIGH before res	LD	(IX+00H),A	;   & clear data	LD	D,(IX+01H)	LD	(IX+01H),A	LD	HL,NOMEM$	; Init "Can't reclaim...	JR	NZ,LOGMEM	; Go if HIGH$ different	EX	DE,HL		;   else release memory	@@HIGH$			;   by resetting HIGH$	LD	HL,GOTMEM$	; "Memory released...LOGMEM	@@LOGOT;;	De-use any RAM bank;	LD	A,(IX+10)	; Pick up bank used	AND	1FH		; Keep only bank num	JR	Z,RESDCB	; Jump only if bank 0	LD	C,A		; Save bank in C	OR	'0'		; Convert to ASCII	CALL	SPLOPM$	LD	B,01H		; Func to reset BUR$	@@BANK	LD	HL,FREBNK$	; "Bank released...	@@LOGOT;;	Reset the device;RESDCB	LD	HL,0SVDCB	EQU	$-2		; Point to spool DCB ptr	LD	E,(HL)		;   & get the DCB ptr	INC	HL		;   into reg DE	LD	D,(HL);;	Check if DCB is inactive (user RESET *PR);	PUSH	DE		; Save DCB pointer	INC	E	LD	A,(DE)		; Get DCB vector contents	LD	C,A		;   into reg BC	INC	E	LD	A,(DE)	LD	B,A	POP	DE		; Recover DCB pointer	LD	HL,0		; Pick up start of moduleSVBGN	EQU	$-2	XOR	A		; If vector points to	SBC	HL,BC		;   start of module,	RET	Z		;   we are finished	LD	L,(IX+08H)	; Pick up DCB being spooled	LD	H,(IX+09H)	EX	DE,HL		; Spool to HL,	LD	B,03H		;   device to DE	DI			; No interruptions nowSWAP1	LD	A,(HL)		; Undo the spooler	LD	(HL),00H	;   by swapping back the	LD	(DE),A		;   original vector and	INC	L		;   zeroing the spool DCB	INC	E	DJNZ	SWAP1	INC	L		; Point to name field	INC	L	INC	L	LD	(HL),00H	; Wipe out the name	INC	L	LD	(HL),00H	EI			; Interrupts okay now	RET			; Done - return;;	Routine to CLEAR the spool buffer;CLEAR	BIT	0,(IY+'D'-'A')	; Spooler active?	JP	Z,SPLOFM	; Go if not active	LD	IX,0		; Params in HIMEMHIPARM	EQU	$-2	LD	L,(IX+11)	; Pick up SPLFCB pointer	LD	H,(IX+12)	LD	C,(IX+10)	; Pick up RAM bank used	RES	7,C		; Set on xfer to bank	LD	B,00H		; Function to load bank	DI			; Interrupts off now	@@BANK	PUSH	BC		; Save old bank	PUSH	HL		; Xfer FCB pointer to IX	POP	IX	LD	L,(IX+24H)	; Get LINK map pointer	LD	H,(IX+25H)	PUSH	HLCLEAR1	LD	(HL),00H	; Reset every link	INC	HL	LD	(HL),00H	INC	HL		; Bypass page pointer	INC	HL	LD	A,(HL)		; Check for TABEND	INC	HL	INC	A		; End if it was X'FF'	JR	NZ,CLEAR1	POP	HL		; Point to LINK start	LD	(IX+26H),L	; Reset PUTBLK$	LD	(IX+27H),H	LD	(IX+28H),L	; Reset GETBLK$	LD	(IX+29H),H	LD	A,H		; Show 1st LINK position	LD	(HL),L		;   is the "last" one by	INC	HL		;   loading it to point	LD	(HL),A		;   to itself	INC	HL		; Pick up the page pointer	LD	B,(HL)	LD	(IX+21H),B	; Stuff PUTNXT$	LD	(IX+20H),00H	LD	(IX+23H),B	; Stuff GETNXT$	LD	(IX+22H),00H	POP	BC		; Reload previous bank	@@BANK	EI			; Enable interrupts again	JP	CLEARD;;	Relocate internal references in driver;	HL = Relocation table;	DE = Pointer to last byte of module;	BC = Pointer to last RAM byte to use;RELO	PUSH	IX		; Save index reg	PUSH	HL		; Xfer rel tab pointer	POP	IXSVEND	LD	HL,0		; Get last byte used	LD	(DVRABGN+2),HL	;   & stuff into module	LD	H,B		; Xfer last byte to use	LD	L,C		;   into HL reg	XOR	A		; Clear carry flag	SBC	HL,DE	LD	B,H		; Move to BC	LD	C,L	LD	A,(IX+00H)	; Get table length	INC	IXRLOOP	LD	L,(IX+00H)	; Get address to change	LD	H,(IX+01H)	LD	E,(HL)		; Pick up address	INC	HL	LD	D,(HL)	EX	DE,HL	ADD	HL,BC		; Offset it	EX	DE,HL		; And put it back	LD	(HL),D	DEC	HL	LD	(HL),E	INC	IX	INC	IX	DEC	A		; Dec counter	JR	NZ,RLOOP	;   and loop until done	POP	IX		; Restore index register	RET;;	Message strings;NOFIND$	DB	'Can',27H,'t locate SPOOL in memory',CRCLEARD$	DB	'SPOOL buffer cleared',CRPAUSED$	DB	'Despooling now paused',CRRESUMD$	DB	'Despooling now resumed',CRSPLOFM$	DB	'Spooler is not active',CRSPLONM$	DB	'Spooler is already active',CR;;SPLOPM$	LD	L,C		; Set HL = C	LD	H,00H	LD	DE,FREBNK$+5	; Destination buffer	PUSH	BC		; Save BC	LD	B,02H		; Max two chars	@@HDEC			; Convert HL to ASCII at DE	POP	BC		; Recover BC	RETSPLOP1$	DB	'y active but paused',CRPRMBGM$	DB	'Cannot reinstall with altered parameters',CRSPLACT$	DB	'Spooler is now operational',CRNOMEM$	DB	'Can',27H,'t reclaim memory space',CRGOTMEM$	DB	'Memory space reclaimed',CRFREBNK$	DB	'Bank xx freed  ',CRINUSE$	DB	'Requested bank in use',CRCANT$	DB	'No memory space available',CRBADDCB$	DB	'Device driver incompatible',CR;;;SPLDCB	DS	32DSKSPC	DB	'XX/'SPLEXT	DB	'SPL',03HPR$	DB	'*PR',03H;VAL	EQU	80H		; Param table equatesSW	EQU	40HSTR	EQU	20HSGL	EQU	10H;PRMTBL$	DB	'R'!80H		; Ver 6.x table format	DB	VAL!SGL!3,'MEM',0	DW	MPARM+1;	DB	VAL!SGL!4,'DISK',0	DW	DPARM+1;	DB	SW!3,'OFF',0	DW	OPARM+1;	DB	SW!1,'N',0	DW	OPARM+1;	DB	VAL!SGL!4,'BANK',0	DW	BPARM+1;	DB	SW!SGL!5,'PAUSE',0	DW	PPARM+1;	DB	SW!SGL!6,'RESUME',0	DW	RPARM+1;	DB	SW!SGL!5,'CLEAR',0	DW	CPARM+1;	DB	00H		; End of param table;	ORG	$<-8+1<+8;BUFFER	DS	256;----------------------------------------------------------------------;LBSPOOLB/ASM - Actual spool driver;;	This is the spool/despool driver - bank 0;FIX1	CALL	SPLR2		; Code mods to module ARX16	EQU	$-2		;   if strictly bank 0	XOR	A	RET	CALL	DSPLR1		;RX17	EQU	$-2	XOR	A	RET	CALL	GETBLK2RX18	EQU	$-2	XOR	A	RET;;	Driver A begin;DVRABGN	EQU	$	JR	DVREPT		; Branch around linkage	DW	$-$		; Last byte used	DB	05H		; Length of nameSPOOL$	DB	'SPOOL'		; Name of moduleS0DCB	DW	0,0		; Space for DCB pointersPRMSAV	DW	0		; HIGH$ before space alloc	DW	DVRABGN-1	; HIGH$ after space alloc	DW	0		; Previous MPARM	DW	0		; Previous DPARMMODDVR	DW	0		; DCB address of deviceSPLBNK	DB	0		; Bank of RAMRX8	DW	SPLFCB		; FCB Pointer;;	Driver entry point;DVREPT	JR	Z,PUTCHAR	; Go on @PUT	JR	NC,CKCTL	; Go on @CTL	LD	A,00H		; Show nothing on @GET	RET;CKCTL	XOR	A		; Show available on CTL-0	RET;;	Move stack low if needed;STKCTL	PUSH	HL	LD	HL,8005H	ADD	HL,SP		; Stack in which bank?	POP	HL	RET	NC		; Okay if stack low	DI			; No ints while stack mucking	LD	(SVHL),HLRX19	EQU	$-2	POP	HL		; Return address	LD	(SAVSTK),SP	; Save the current stackRX20	EQU	$-2	LD	SP,STACK$-40H	; Force it low	PUSH	HL		; User RET back on	LD	HL,SPOLRETRX21	EQU	$-2	EX	(SP),HL		; Now, ultimate ret 1st	PUSH	HL		;   and local ret 2nd	LD	HL,(SVHL)	;   restore HLRX23	EQU	$-2	EI			; Enable interrupts again	RET			;   and return;SPOLRET	DI			; Just in case	LD	SP,(SAVSTK)	; Get the old stackRX22	EQU	$-2	EI	RETSAVSTK	DW	0SVHL	DW	0;;	Character to PUT - Get bank activated;PUTCHAR	LD	HL,SPLR1A	; Point to xfer addrRX01	EQU	$-2	LD	E,C		; Xfer char to PUT	LD	BC,0<8!0!80H	; Function and bank requestBANKX1	EQU	$-2	CALL	STKCTL		; Move stack low?RX24	EQU	$-2	@@BANK			; Invoke bank transfer	RET;;	Task processor despooling routine;DSPLTCB	DW	DSPLR		; Despool task control blkRX02	EQU	$-2DSPLR	LD	A,(0)		; Pick up PFLAG$ and check ifDFLAG	EQU	$-2		;   despooling active	RLCA	RET	NC		; Return if not	LD	HL,(S0DCB)	; If despooler is inactiveRX08	EQU	$-2		;   then don't try to do	INC	L		;   any despooling	LD	C,(HL)		; Get DCB vector	INC	L	LD	B,(HL)	LD	HL,DVRABGN	; Pick up spooler startRX09	EQU	$-2	XOR	A	SBC	HL,BC		; If the same then	RET	Z		;   module is not activeFIX2UP	LD	HL,DSPLR0	; Point to xfer addrRX03	EQU	$-2	LD	BC,0<8!0!80H	; Function & bank requestBANKX2	EQU	$-2	CALL	STKCTL		; Move stack low?RX25	EQU	$-2	@@BANK			; Invoke bank transfer	RET;;	KI task routine to get a disk block;GETBLK	LD	HL,GETBLK1	; Point to transfer addrRX04	EQU	$-2	LD	BC,0<8!0!80H	; Pick up func & bank reqBANKX3	EQU	$-2	CALL	STKCTL		; Move stack low?RX26	EQU	$-2	@@BANK			; Do bank transferGETBLK0	DB	0,0,0		; Original @KITSK;DVRAEND	EQU	$-1RELTABA	DB	TABALEN		; 0DH	DW	RX02,RX05,RX06,RX08	DW	RX09,RX19,RX20,RX21	DW	RX22,RX23,RX24,RX25	DW	RX26TABALEN	EQU	$-RELTABA/2;;DVRBBGN	EQU	$;;	Driver B - Spool/despool module in bank x;S0DCB1	DW	0;;	Spool a character;SPLR1A	PUSH	HL		; Save new transfer addr	PUSH	BC		; Save invocation	LD	C,E		; Get character to PUT	CALL	SPLR2		; Spool a charRX1	EQU	$-2	POP	BC	POP	HL	@@BANK			; Transfer backSPLR2	LD	IX,SPLFCBRX2	EQU	$-2	LD	L,(IX+20H)	; Pick up next buff posn	LD	H,(IX+21H)	LD	(HL),C		; Stuff char received	DI			; No interruptions nowSPLR3	INC	(IX+20H)	; Inc low order	JR	Z,SPLR5		; Jump if block full	CALL	DSPLR1X		; Output to *PR if availRX3	EQU	$-2	EI			; Interrupts on again	JP	GETBLK2RX4	EQU	$-2;SPLR5	LD	L,(IX+24H)	; Get pointer to table	LD	H,(IX+25H)SPLR6	LD	A,(HL)		; Find spare pointer field	INC	HL	OR	(HL)	JR	Z,SPLR7		; Jump if spare	INC	HL		;   else index to next	INC	HL	INC	HL	JR	SPLR6		; Loop for more;SPLR7	DEC	HL	PUSH	HL		; Save pointer	INC	HL	INC	HL	LD	B,(HL)		; Pick up memory segment byte	INC	HL		;   or lo-order record num	LD	A,(HL)		; End of table?	CP	0FFH	JR	NZ,SPLR10	; Jump if still space	POP	HLSPLR8	CALL	DSPLR1X		; Output to *PR if availRX5	EQU	$-2	EI			; Interrupts okay nowSPLR9	CALL	GETBLK2		; Disk rec to bring back?RX6	EQU	$-2	DI			; Ints back off	JR	SPLR5;SPLR10	BIT	7,A		; Test mem or disk block	JR	NZ,SPLR12	; Jump if disk pointer;;	Found a spare memory pointer;	POP	HL		; Recover ptr to start	PUSH	HL		;   of spare table field	LD	(HL),L		; Place address of table	LD	A,H		;   position into table	INC	HL	LD	(HL),A	LD	(IX+21H),B	; Stuff hi-order free mem	LD	L,(IX+26H)	; Get current table ptr	LD	H,(IX+27H)	LD	(IX+2AH),L	; Stuff last block pointer	LD	(IX+2BH),H	POP	BC		; Recover ptr to field start	LD	(HL),C		; Set up a link to this	INC	HL		;   block in last block	LD	(HL),B	LD	(IX+26H),C	; Reset current block ptr	LD	(IX+27H),B	EI			; INTs back on	RET;;	Found a spare disk block pointer;SPLR12	EI	LD	C,B		; Low order record num	AND	0FH		; High order rec num	LD	B,A		; BC = rec num	PUSH	IX		; Position file to recnum	POP	DE		; FCB to DE	@@POSN			; Move to desired record	DB	0,0,0		; Reserved	LD	C,(IX+26H)	; Pick up current table ptr	LD	B,(IX+27H)	POP	HL		; Pick up ptr to this disk	PUSH	HL		; Block table field	LD	(HL),C		; Tell this disk block	INC	HL		;   field which memory	LD	(HL),B		;   block it is storing	POP	BC		; Exchange link in last	LD	L,(IX+2AH)	;   block pointer with new	LD	H,(IX+2BH)	;   link since this memory	LD	(HL),C		;   block is now on disk	INC	HL	LD	(HL),B	LD	(IX+2AH),C	LD	(IX+2BH),B	LD	BC,256		; Block move the page	LD	L,C		;   into the low memory	LD	H,(IX+21H)	;   buffer for disk I/O	PUSH	DE		; Save FCB pointer	LD	DE,LOWBUF$	LDIR	POP	DE	@@WRITE			; Write out the block	DB	0,0,0		; Reserved	RET;DSPLR0	PUSH	HL		; Save new xfer address	PUSH	BC		; Save invocation	CALL	DSPLR1		; Send device a characterRX7	EQU	$-2	POP	BC		; Recover bank	POP	HL		; Recover address	@@BANK			; Transfer back;;	Routine will output a char to *PR if available;DSPLR1X	LD	A,($-$)		; Pick up PFLAG$ & chk ifDFLAG1	EQU	$-2		;   despooling active	RLCA	RET	NC		; Return if not activeDSPLR1	LD	BC,4<8!0	; Init to CTL-0	PUSH	IX		; Save current DCB ptrPUDCB	LD	IX,(S0DCB1)	; Point to printerRX9	EQU	$-2	@@CHNIO			; Check *PR status	POP	IX		; Recover DCB	RET	NZ		; Return if not availablePUFCB	LD	IX,SPLFCBRX10	EQU	$-2	LD	A,(IX+23H)	; See if char in buffer	OR	A		;   to send to printer	RET	Z		; Return if none there	LD	H,A		; Also none if GET pointer	CP	(IX+21H)	;   is same as PUT pointer	LD	A,(IX+22H)	JR	NZ,DSPLR2	CP	(IX+20H)	RET	Z		; In & out the same;DSPLR2	LD	L,A		; Pick up the character	LD	C,(HL)		; Transfer to output reg	PUSH	IX		; Save the DCB vector	LD	B,02H		; Set chain for PUTPUDCB1	LD	IX,(S0DCB1)	; Point to spooled DCBRX11	EQU	$-2	@@CHNIO			; Output the char	POP	IX		; Recover DCB	INC	(IX+22H)	; Bump PUT (output) ptr	RET	NZ		; Ret if still more in buff	LD	(IX+23H),00H	; Block empty, turn off	RET			;   high order and exit;;	Routine to see if we can grab a block back from;	the disk file and insert into a spare memory block;GETBLK1	PUSH	HL		; Save new transfer addr	PUSH	BC		; Save invocation	CALL	GETBLK2		; Spool a characterRX12	EQU	$-2	POP	BC	POP	HL	@@BANK			; Transfer backGETBLK2	PUSH	AF	PUSH	IX		; Save in case DSPLR1GETBLK3	LD	A,(SPLFCB+23H)	; Jump if block beingRX13	EQU	$-2		;   printed is not empty	OR	A	JR	NZ,GETBLK6;;	The block's been despooled - Get one from disk/mem?;	PUSH	HL	PUSH	DE	PUSH	BCGETBLK4	LD	IX,SPLFCBRX14	EQU	$-2	LD	L,(IX+28H)	; Get pointer of block	LD	H,(IX+29H)	;   being printed	PUSH	HL	LD	C,(HL)		; Point to POSN or hi-mem	INC	HL		;   byte of field this	LD	B,(HL)		;   field points to	LD	HL,2	ADD	HL,BC	LD	A,(HL)	INC	HL	BIT	7,(HL)		; Jump if this is pointing	JR	NZ,GETBLK7	;   to a disk block	LD	(IX+23H),A	; Reset high order of where	POP	HL		;   next block is coming from	LD	(HL),00H	; Show that this block	INC	HL		;   is spare	LD	(HL),00H	LD	(IX+28H),C	; Set the next block	LD	(IX+29H),B	;   to be printedGETBLK5	POP	BC	POP	DE	POP	HL;GETBLK6	EQU	$	DI	CALL	DSPLR1X		; See if we can despoolRX15	EQU	$-2		;   a character while	EI			;   we are in here	POP	IX	POP	AF	RET;;	Next block to print is on disk, get it;GETBLK7	LD	C,A		; Set up position	LD	A,(HL)	AND	0FH	LD	B,A	PUSH	IX		; Set FCB and position	POP	DE		;   the spool file	@@POSN	DB	0,0,0		; Reserved	POP	HL		; Recover table ptr of	PUSH	HL		;   block just finished	INC	HL	INC	HL		; Get its buffer location	@@READ			; Read block from file	DB	0,0,0		; Reserved	LD	BC,256		; Block move from the	LD	D,(HL)		;   low memory buffer	LD	E,C		;   to RAM page	LD	HL,LOWBUF$	LDIR	POP	HL		; Table ptr of block finished	PUSH	HL	LD	A,(HL)		; Get field address of	INC	HL		;   next table field	LD	H,(HL)		;   that gets printed	LD	L,A	LD	C,(HL)		; Get field address of the	LD	(HL),00H	;   block after that to	INC	HL		;   print and show this one	LD	B,(HL)		;   as empty (this was the	LD	(HL),00H	;   disk one just vacated)	POP	HL	LD	(HL),C		; Reset current printing	INC	HL		;   block and point to	LD	(HL),B		;   new next block	INC	HL	LD	B,(HL)	LD	(IX+23H),B	; Show where new printing	JR	GETBLK5		;   block is and exit;;	File control block area for spool file;SPLFCB	DS	32;;	Pointer to the memory location where the next;	character received from *XX can be put;PUTNXT$	DS	2;;	Pointer to where the next character to print;	is going to come from;GETNXT$	DS	2;;	Pointer to start of block map table;	Table configuration is:;;	TAB+0/1 -> Store the TAB address if the field;	is currently in use for receiving.  If a;	block is not current, it stores the;	address of the next TAB to print.  If;	a disk field, then stores the TAB address;	of the previous block (link back);;	TAB+2 -> For a memory block, stores the hi-order;	byte of where the memory block starts.  If;	a disk block, stores the lo-order POSN #;;	TAB+3 -> Should be 0 for a memory block.  If a;	disk block, it contains the hi-order POSN;	vector with bit 7 set.;MAPPTR$	DS	2;;	Pointer to the beginning of the memory table;	block pointer for the block that is receiving;	characters from *PR calls (the current block);PUTBLK$	DS	2;;	Pointer to the memory table field for the block;	that is printing characters;GETBLK$	DS	2;;	Points to the table position of the previous;	block.  This is used to reset the previous link.;	DW	00HDVRBEND	EQU	$-1;RELTABB	DB	TABBLEN	DW	RX01,RX03,RX04	DW	RX1,RX2,RX3,RX4,RX5,RX6	DW	RX7,RX8,RX9,RX10,RX11,RX12	DW	RX13,RX14,RX15,RX16,RX17,RX18TABBLEN	EQU	$-RELTABB/2;	END	SPOOL