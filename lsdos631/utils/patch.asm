; ***************************************************************; * Filename: PATCH/ASM						*; * Revision: 06.03.01						*; * Rev Date: 19 Dec 97						*; ***************************************************************; * Disk File Patch Utility					*; *								*; ***************************************************************;	TITLE	<PATCH - LS-DOS 6.3>;ETX	EQU	3LF	EQU	10CR	EQU	13FLAG	EQU	01000000BABB	EQU	00010000B;*GET	SVCMAC			; System SVC equivalents*GET	COPYCOM			; Copyright message;	ORG	2600H;BEGIN	@@CKBRKC		; Check if break hit	JR	Z,BEGINA	; Go if no break	LD	HL,-1		;   else abort	RET;BEGINA	LD	(STACK),SP	; Save original stack	PUSH	HL		; Save ptr to cmd line	@@FLAGS			; Get system flags	LD	HL,HELLO$	CALL	$DSPLY		; Display the signon message;;	Get /CMD file off the command line;	POP	HL		; Recover cmd line pointer	LD	DE,PGMDCB	; Set up for open	@@FSPEC			; Fetch program filespec	JP	NZ,PGMREQ	; Quit if illegal name	LD	A,(DE)	CP	'*'		; Test for device spec	JP	Z,PGMREQ	; Abort if not a filespec	PUSH	HL		; Save position on cmd line	LD	HL,CMDEXT	@@FEXT			; Default ext to /CMD	PUSH	DE		; Save ptr to FCB	EX	DE,HL		; Point HL to current name	LD	DE,FNM$		; Store the name away	@@FSPEC			;   in case of a later error	POP	DE		; Recover FCB	LD	HL,PGMBUF	; Buffer for /CMD file I/O	LD	B,00H		; Set LRL = 256	CALL	$OPEN		; Open the file to fix;;	Get /FIX file (if any);	POP	HL		; Get command line position	LD	DE,FIXDCB	; FCB used for /FIX file	@@FSPEC			; See if a filespec is there	JP	NZ,CKLIN	; If error, check for params	PUSH	HL		; Save cmd line position	LD	HL,FIXEXT	@@FEXT			; Default ext of /FIX	LD	HL,FIXDCB	; Point HL to start of FIX filespec	LD	DE,NAMFIX$	; Buffer to hold filename only	LD	B,00H		; Init char count to 0;;	Save patch name for X header;FXNAM	LD	A,(HL)		; Get a char of filespec	INC	HL	CP	'/'		; Found the /FIX ext?	JR	Z,FXNAM2	; Quit if so	CP	':'		; Colon yet?	JR	C,FXNAM1	; If less, must be a number	CP	'A'		; A-Z?	JR	C,FXNAM2	; If less, done	CP	'Z'+1		; If not alpha, done	JR	NC,FXNAM2FXNAM1	LD	(DE),A		; Store the name character	INC	DE		; Inc storate pointer	INC	B		; Inc count of name chars	JR	FXNAM		; Loop for more;FXNAM2	LD	A,B		; Store the length of	LD	(NAMLEN$),A	;   the /FIX patch filename	POP	HL		; Recover cmd line positionCKLIN	LD	A,(HL)		; Test command line	CP	0DH		;   for end	JR	Z,RDFIX		; Go if found	INC	HL		; Bump command line pointer	CP	' '		; Space?	JR	Z,CKLIN		; Ignore spaces	CP	'('		; Start of parameters?	JP	NZ,PRMERR	; Anything else is param error;;	Test for REMOVE or special Option parameters;	Ignore @@PARAM errors, as the parameters may actually;	be a command line patch;	LD	DE,PTBL$	; Point to parameter table	PUSH	HL		; Save cmd line pointer	DEC	HL		; Back up to the '('	@@PARAM	POP	HL		; Get command line back	LD	BC,$-$		; "Remove" param responseRPARM1	EQU	$-2	LD	A,C	LD	(RPARM),A	; Set remove param	LD	BC,-1		; O -aram - bypass need forOPARM1	EQU	$-2		;   Frr,nn line if OFF	LD	A,C	LD	(OPARM),A	; Set find flag	JP	Z,RDFIX		; If @PARAM was good, there is				;   no cmd line patch code;;	Check for command line patch code (CLP);	LD	BC,FIXDATA	; Space allocated for /FIX dataCKLIN1	LD	A,(HL)		; Get char from command line	CP	0DH	JP	Z,CKLIN3	; Show end of CLP	CP	')'	JR	Z,CKLIN3	; End of CLP if so	INC	HL		; Bump buffer pointer	CP	':'		; Separator between patches?	JR	NZ,CKLIN2	; If not, store character	LD	A,0DH		;   else show end of this CLPCKLIN2	LD	(BC),A		; Put byte into fix data buffer	INC	BC		; Bump buffer pointer	JR	CKLIN1		; Loop until end of cmd line;CKLIN3	LD	A,0DH		; Put CR into CLP buffer	LD	(BC),A	INC	BC	LD	A,03H		; End buffer with ETX	LD	(BC),A	JR	DOFIX;;	Get the fix info from the FIX file, rather than;	the command line;RDFIX	LD	A,(NAMLEN$)	; Get len of /FIX filename	OR	A	JP	Z,PGMREQ	; If none used, abort	SET	0,(IY+'S'-'A')	; Set open inhibit bit	LD	DE,FIXDCB	; Set up & open /FIX file	LD	HL,FIXBUF	LD	B,00H	CALL	$OPEN	LD	HL,PGMDATA	; Point HL to highest byte	DEC	HL		;   avail for fix data	LD	BC,FIXDATA	; Start of /FIX data storageRDFIX1	CALL	$GET1		; Get a char from /FIX file	JR	NZ,RDFIX2	; Jump on error	AND	7FH		; Strip bit 7	JR	Z,RDFIX3	; Take 0 as EOF also	LD	(BC),A		; Save fix data char	INC	BC		; Advance buffer	PUSH	HL		; Save HL temporarily	SBC	HL,BC		; Room in fixdata buffer?	POP	HL	JP	C,TOOBIG	; Abort if patch data too large	JR	RDFIX1		;   else loop until EOF;RDFIX2	CP	1CH		; End of file error?	JP	NZ,IOERR	; Abort if notRDFIX3	LD	A,03H		; Mark end of the fix data	LD	(BC),A;;	Start patching the target file;DOFIX	LD	HL,FIXDATA	; Point to start of fix data;DOFIX1	PUSH	HL	LD	HL,RDGINP$	; "Reading input...	CALL	$DSPLY	POP	HL	LD	(SETMSG+1),HL	; Used if error in line	LD	A,$-$		; Zero if 1st pass through dataPASS2	EQU	$-1	OR	A	LD	A,(HL)		; Get a character	JP	Z,PASS1		; Go if 1st pass	LD	A,(HL)		; <-- redundant!	CP	03H		; End of patch?	JR	Z,PCHDUN	CP	'.'		; Comment?	JP	Z,COMMENT	RES	5,A		; Make upper case	CP	'F'		; FIND line?	JP	Z,COMMENT	; Skip on 2nd pass or if O=N	CP	'D'		; Start of D line?	JP	Z,DVERB	CP	'Y'		; Yank previous patch?	JP	Z,YANK	CP	'L'		; Library overlay?	JP	Z,LVERB	CP	'R'		; Remove param?	JP	Z,REMOVE	CP	'O'		; "O" param?	JP	Z,OVERB	CP	'X'		; Start of X line?	JP	NZ,PCHERR	; Error if none of above;;	Verb = 'X' -> Patch by hex load address;	LD	DE,PGMDCB	; Rewind the program to 0	LD	BC,0		; Use @POSN so EOF	CALL	$POSN		;   is not changed	CALL	POSFIL		; Position to end of prgfile;	PUSH	AF		; Save regs from display routine	PUSH	HL	PUSH	DE	LD	HL,INSPCH$	; "Installing patch...	CALL	$DSPLY	POP	DE	POP	HL	POP	AF;	CP	02H		; Be sure type byte = 2	JP	NZ,FILERR	; Load file format error	LD	A,01H		; Set LRL to 1 temporarily	LD	(PGMDCB+9),A	;   and backspace file to	CALL	$BKSP		;   overwrite old xfer addr	XOR	A		; Reset LRL to 256	LD	(PGMDCB+9),A;;	Install the X patch at the end of the prg file;	CALL	STUFNM		; Generate the patch	LD	A,(HL)		; HL => ending posn in fix data	CP	03H		; Did it go til the end	JP	NZ,PCHERR	; "Patch format error...;;	Patch operation complete - close the file;PCHDUN	LD	A,0DH		; Move cursor to next line	CALL	$DSP	LD	DE,PGMDCB	; Close the program file	@@CLOSE	JP	NZ,IOERR	LD	HL,YANKMSG	; Set up in case Yank was done	LD	A,(YNKFLG)	; Was it a Yank?	OR	A	JR	NZ,EXLOG	; Yes, log out	LD	HL,SUCCES$	; "Func complete...	@@LOGOT	LD	HL,(LINCNT)	; Get # of D and X lines	LD	A,H	OR	L		; Any?	JR	Z,NOCHG		; No D or X verbs	PUSH	HL		; Save line count	LD	DE,1		; Exactly one line?	SBC	HL,DE	POP	HL	JR	NZ,NTONE	; Go if more than one	LD	A,' '		;   else remove "s" from message	LD	(PLURAL),ANTONE	LD	DE,LINMSG$	; Put line count into message	@@HEXDEC		;   as decimal ASCIINOCHG	LD	HL,LINMSG$EXLOG	@@LOGOT			; Show how many lines done;	LD	HL,0		; Init no error$QUIT	PUSH	HL	LD	HL,PGMDCB	; Get program DCB	BIT	7,(HL)		; Was file left open?	EX	DE,HL		; DE => DCB possible close	CALL	NZ,FLOPN	; Warn user	LD	A,0EH		; Cursor on	CALL	$DSP	POP	HL	LD	SP,$-$		; Get original stackSTACK	EQU	$-2	@@CKBRKC		; Clear any <BREAK>	RET			; Done with patching;;	Verb = '.' -> Comment line;	HL = start of line in fix data;	Bypass all chars until a terminator is found;COMMENT	LD	A,(HL)		; Look for some terminator	CP	03H		; End of fix data?	JP	Z,DOFIX1	; Back if so	INC	HL		; Else bump buffer pointer	CP	';'		; Logical EOL?	JR	Z,EOL1		; Back if so	CP	0DH		; Physical EOL?	JR	NZ,COMMENT	; Do next char if notEOL1	JP	DOFIX1		; Back to the caller;;	Verb = 'D' -> Disk record patch;DVERB	CALL	CNTLIN		; Bump line counter	CALL	DPOSN		; Position to Drr,bb	CALL	DLINE		; Put or check the patch line				;   depending on which pass	JP	DOFIX1		; Do next line;DPOSN	INC	HL		; Bump fix data buffer ptr	CALL	PRSFIX		; Get char or hex pair	LD	B,00H		; Put disk record # in BC	LD	C,A	LD	A,(HL)		; If no comma, then	CP	','		;   get 3rd & 4th digits	JR	Z,DVERB1	;   in case user put in	CALL	PRSFIX		;   a 4 byte record #	LD	C,ADVERB1	LD	DE,PGMDCB	; Position file to record	CALL	$POSN	LD	A,(HL)		; Check for "," separator	CP	','		;   beween record and offset	JP	NZ,PCHERR	; Error if not there	INC	HL		; Point to offset bytes	CALL	$READ		; Read the sector	CALL	PRSFIX		; Make offset binary in A	LD	(PGMDCB+5),A	; Set byte offset in FCB	RET;;	Dual purpose routine that checks a Drr,bb line;	or installs it into the program file;DLINE	LD	A,(HL)		; Next byte in line must	CP	'='		;   be '='	JP	NZ,PCHERR	; Abort if missingDVERB2	INC	HL		; Point to start of patch dataDVERB3	CALL	PRSFX1		; Get patch byte as binary in A	CALL	PUTORCHK	; Either write it or check it	LD	A,(HL)		; Get next char	CP	0DH		; End of line?	JR	Z,DVERB4A	; Go on CR	CP	';'		; End of logical line?	JR	Z,DVERB4	; Go if it is	CP	'"'		; Closing double quote?	JR	Z,DVERB4	LD	A,(STRFLG+1)	; If in quote string, do not	OR	A		;   bump HL past non-existant	JR	Z,DVERB2	;   space character	JR	DVERB3		; No special, do next byte;DVERB4	LD	A,(HL)		; Ignore rest of lineDVERB4A	INC	HL	CP	0DH	JR	NZ,DVERB4	; Loop until physical EOL	LD	A,(PASS2)	; Patching or checking?	OR	A		; If patching, need to re-write	CALL	NZ,$RWRIT	;   the sector	RET;;	Verb = 'R' -> Set flag to yank D patch;	This routine is needed to check the R parameter;	when doing a CLP, in case the param was entered;	after the fix data;REMOVE	LD	A,-1		; Set remove param true and	LD	(RPARM),A	;   then igmore all until the	JP	COMMENT		;   next logical line;;	Verb = 'Y' -> Yanks patch with same name;YANK	LD	A,(HL)		; Ignore all chars until the	INC	HL		;   physical end of line	CP	0DH	JR	NZ,YANK;	PUSH	HL		; Save fix data position	LD	HL,YNKPCH$	; "Yanking patch...	CALL	$DSPLY	LD	BC,0		; Rewind the file	LD	DE,PGMDCB	CALL	$POSNYANK1	CALL	$GET1		; Get a "type" byte	JP	NZ,YANK9	; If error, check for EOF	CP	07H		; Found a patch?	JR	Z,YANK4		; If so, check the name	LD	(TYPCOD+1),A	; Save type for testing	CALL	$GET		; Get block length	LD	B,A		; Set loop counterTYPCOD	LD	A,00H		; Test type	DEC	A		; Check for type 1 (code block)	JR	NZ,YANK2	; Length okay if not;;	Adjust length for 255 and 256 byte code blocks;	CALL	$GET		; Read 1st two bytes in case	DEC	B		;   the block was 255+2 or 256+2	CALL	$GET	DEC	BYANK2	CALL	$GET		; Read rest of the blockYANK3	DJNZ	YANK2	JR	YANK1;;	Found patch code area, is this the one?;YANK4	CALL	$GET		; Get name length from file	LD	B,A		; Save length in B	LD	A,(NAMLEN$)	; Get fix file name length	CP	B		; If no match, not the fix	JR	NZ,YANK2	;   to yank	LD	HL,NAMFIX$	; Point to Yank file nameYANK5	CALL	$GET1		; Check for match of yank	JP	NZ,YANK2	;   file name with program	CP	(HL)		;   patch name	INC	HL	JR	NZ,YANK3	; Back if no match	DJNZ	YANK5;;	Found this fix patch - let's yank it;YANK6	CALL	$GET		; Get type code	CP	01H		; Ignore block if not type 1	JP	NZ,YANK8	;   (code block)	LD	A,01H		; Set LRL to 1 and backspace	LD	(PGMDCB+9),A	;   to overwrite the type byte	CALL	$BKSP	XOR	A		; Reset LRL back to 256	LD	(PGMDCB+9),A	LD	A,10H		; Change type 1 to type 16	CALL	$PUT		;   and write to prgfile	CALL	$RWRIT		; Force re-write	CALL	$GET		; Get length byte of patch	LD	B,A		;   code blockYANK7	CALL	$GET	DJNZ	YANK7		; Position past the code block	JR	YANK6		; Loop through patch blocks;YANK8	POP	HL		; Not type 1, done with yank	LD	A,0FFH		; Set yank flag for exit	LD	(YNKFLG),A	;   message display	JP	PCHDUN;YANK9	CP	1CH		; Got $GET error, was it EOF?	JP	NZ,IOERR	; Abort if it wasn't EOF	LD	HL,NOYANK$	; "Can't yank, not in file	JP	ERREXIT;;	Verb = 'O' -> Turn FIND on or off;	Check special O parameter, determine ON or OFF;OVERB	INC	HL		; Move past 'O'	LD	A,(HL)		; Next char must be a '=' or	CP	'='		;   it's an error	JR	NZ,WHATIS	INC	HL		; Bypass the '='	LD	A,(HL)	CP	0DH		; Was it CR or ')'?	JR	Z,OISOFF	; O=<ENTER> is OFF	RES	5,A		; Force char to upper case	CP	'N'	JR	Z,OISOFF	CP	'Y'	JR	Z,OISON	CP	'O'	JR	NZ,WHATIS	; Not Y/N/On/Off!	CALL	GETNXT		; Get next char, already upper	CP	'F'		; OFF	JR	Z,OISOFF	CP	'N'		; ONWHATIS	JP	NZ,PCHERR	; Quit if no acceptable flag;OISON	DB	3EH		; LD A,0AFHOISOFF	XOR	A	LD	(OPARM),A	; Set parameter on or off	DEC	HL	JP	COMMENT		; Ignore rest til logical EOL;;	Verb = 'L' -> Indicate patch to library file;LVERB	INC	HL		; Bypass the 'L'	CALL	PRSFIX		; Get a hex digit pair	LD	C,A		; Stuff for later	LD	(OVRLY+1),A	LD	A,(HL)		; Check for end of line	INC	HL	CP	0DH	JP	NZ,PCHERR	; Error if not EOL	CALL	FISAM		; Get isam overlay pointers	PUSH	AF		; Save byte offset	LD	A,(PGMDCB+1)	RES	7,A		; Sector operations only	LD	(PGMDCB+1),A	LD	DE,PGMDCB	; Position the file to	CALL	$POSN		;   overlay requested	CALL	$READ		; Read in the sector	POP	AF	LD	(PGMDCB+5),A	; Stuff byte offset in FCB	CALL	POSFIL		; Advise "Positioning...	CP	04H		; End of ISAM overlay?	JP	NZ,FILERR	; If not, "load file fmt err	LD	A,01H		; Set LRL to 1	LD	(PGMDCB+9),A	CALL	$BKSP		; Backspace over the 4	XOR	A		; Set LRL back to 256	LD	(PGMDCB+9),A	CALL	STUFNM		; Do the patch	PUSH	HL	LD	HL,BLDMAP$	; "Rebuilding library map...	CALL	$DSPLY	CALL	RPRMAP		; Rebuild the map	POP	HL	JP	DOFIX1		; Loop;;	Routine to position to file's end;POSFIL	PUSH	HL		; Save from display call	PUSH	DE	LD	HL,POSLD$	; "Positioning...	CALL	$DSPLY	POP	DE	POP	HL;POSFIL1	CALL	$GET		; Get a type byte	CP	20H		; X'20' and above are illegal	JP	NC,FILERR	CP	02H		; Transfer address found?	RET	Z	CP	03H		; Not really used in a file yet	RET	Z	CP	04H		; End of ISAM member?	RET	Z	CP	0AH		; End of ISAM directory?	RET	Z	LD	C,A		; Save type byte	CALL	$GET		; Get block length	LD	B,A		; Save it for countdown	DEC	C		; Was type = 1?	JR	NZ,POSFIL2	; Jump if not	CALL	$GET		; Read off the load address	DEC	B		; Adjust length for each get	CALL	$GET	DEC	BPOSFIL2	CALL	$GET		; Read the block	DJNZ	POSFIL2	JR	POSFIL1		; Loop to next type code;;	Routine to put the patch name header block into the;	program data buffer and then position to the next 'X' line;STUFNM	PUSH	HL		; save position in fix data	LD	HL,GENPCH$	; "Generating patch...	CALL	$DSPLY	LD	DE,PGMDATA	LD	HL,NAMLEN$	; Point to fix name field	LD	A,(HL)	OR	A	JR	Z,STUFNM2	; Go if no name length	LD	A,07H		; Set fix patch type	LD	(DE),A	INC	DE	LD	B,(HL)		; Set header length	INC	B		; Bump to write lengthSTUFNM1	LD	A,(HL)		; Get a name byte	INC	HL	LD	(DE),A		; Put it into the output buffer	INC	DE	DJNZ	STUFNM1		; Loop for name length;STUFNM2	POP	HL		; Recover position in fix dataSTUFNM3	LD	(SETMSG+1),HL	; Start of this line	LD	A,(HL)	CP	03H		; End of fix data?	JP	Z,RIPPLE	INC	HL	CP	'.'		; Comment?	JR	Z,STUFNM4	RES	5,A		; Force to upper case	CP	'X'		; Start of code line?	JR	Z,DOXVB		; Go if so	JP	PCHERR		; "Patch input format error;STUFNM4	LD	A,(HL)		; In a comment, loop until	INC	HL		;   end of line	CP	03H		; End of patch code?	JP	Z,PCHERR	; Abort if so	CP	0DH		; EOL?	JR	NZ,STUFNM4	; Loop back if not	JR	STUFNM3;;	Do the 'X' verb patch;	HL => Fix data buffer;	DE => Program data buffer;DOXVB	CALL	CNTLIN		; Count installed lines	LD	A,01H		; Show type 1 (code block)	LD	(DE),A		; Put in output buffer	INC	DE	PUSH	DE		; Save pointer to length	INC	DE	LD	A,(HL)		; Should be "'"	INC	HL		;   around address (X'nnnn')	CP	27H	JP	NZ,PCHERR	; Error if it isn't	CALL	PRSFIX		; Get hex digit pair	LD	B,A		; Save high order address	CALL	PRSFIX		; Get hex digit pair	LD	(DE),A		; Stuff low order address	INC	DE	LD	A,B	LD	(DE),A		; Stuff high order address	INC	DE	LD	A,(HL)		; Syntax requires "=" or "'"	CP	'='		;   to be next char	JR	Z,DOXVB1	CP	27H		; Bypass optional closing "'"	JP	NZ,PCHERR	; Error if not one	INC	HLDOXVB1	INC	HL		; Bypass the "="	LD	B,02H		; Length of bytes already stuffedDOXVB2	LD	A,(HL)		; Get char of fix data	CP	'"'		; Is it an ASCII string?	JR	Z,DOXVB5	; Go process if soDOXVB3	LD	A,(HL)		; Get line byte	INC	HL	CP	';'		; Logical end of line?	JR	Z,DOXVB4	CP	0DH		; Physical end of line?	JR	Z,DOXVB6	CP	' '	JR	Z,DOXVB2	; Ignore spaces	DEC	HL		; Back up, it's a byte	CALL	PRSFX1		; Get the hex digit pair	LD	(DE),A		; Stuff into code buffer	INC	DE	INC	B		; Bump block length	JR	DOXVB3;;	Bypass until end of line;DOXVB4	LD	A,(HL)		; Get the character	INC	HL	CP	0DH		; End of line?	JR	NZ,DOXVB4	JR	DOXVB6;;	Fix has double quoted string in it;DOXVB5	INC	HL	LD	A,(HL)		; Get next character	CP	03H		; End of fix data found?	JP	Z,PCHERR	; Can't end without some EOL	INC	HL	CP	0DH		; End of line?	JP	Z,DOXVB6	; Go if valid end	CP	'"'		; Closing quote?	JR	Z,DOXVB3	; Go for more	DEC	HL	LD	(DE),A		; Stuff the character	INC	DE	INC	B		; Bump counter	JR	DOXVB5		; Loop until end or '"';;	Found valid end - update the length;DOXVB6	EX	(SP),HL		; Grab length pointer	LD	(HL),B		; Stuff the length	POP	HL	JP	STUFNM3		; Go for more lines;;	Got to the end of the fix input;RIPPLE	PUSH	HL	EX	DE,HL		; Last patch byte to HL	LD	DE,PGMDATA	; Point to patch code buffer	XOR	A	SBC	HL,DE		; Calculate length of fixup	LD	(RPRMAP9+1),HL	; Save for later use	LD	HL,INSPCH$	; "Installing patch...	CALL	$DSPLY	LD	HL,PGMDCB	; Move prog into fix	LD	DE,FIXDCB	;   file control block	LD	BC,32		;   for output use	LDIR	LD	HL,LIBBUF	; Set the I/O buffer	LD	(FIXDCB+3),HL	LD	DE,FIXDCB	; Re-read the last program	@@RREAD			;   sector	JP	NZ,IOERR	; Quit on read error;;	Now ripple the file down while stuffing bytes;	LD	HL,PGMDATA	; Beginning of the "fixed" codeRIPPL1	LD	DE,FIXDCB	; Get prog byte	CALL	$GET1	JP	NZ,RIPPL2	PUSH	HL		; Save buffer pointer and byte	PUSH	AF	LD	DE,PGMDCB	; Use the output FCB	LD	A,(HL)		; Get byte from fixbuf	CALL	$PUT		; Put it to disk	LD	BC,(RPRMAP9+1)	; Point to patch length	ADD	HL,BC		; Point past patch code	POP	AF		; Recover prog byte	LD	(HL),A		;   and stuff after fix code	POP	HL		; Recover buffer pointer	INC	HL		; Bump pointer	JR	RIPPL1		;    and loop;RIPPL2	CP	1CH		; Got to end of file?	JP	NZ,FILERR	; Quit if any other error	LD	DE,PGMDCB	LD	BC,(RPRMAP9+1)	; Get length of patchRIPPL3	LD	A,(HL)		; Put rest of program	INC	HL		;   (ie: the bytes = to	CALL	$PUT		;    the length of patch code)	DEC	BC		; Do until length left = 0	LD	A,B	OR	C	JR	NZ,RIPPL3	POP	HL	RET;;	Routine to read and convert fix code values;PRSFIX	XOR	A		; Entry to clear	LD	(STRFLG+1),A	;   STRING checkPRSFX1	LD	A,(HL)		; Get patch character	CP	03H		; End of text?	JP	Z,PCHERR	; Error if so	CP	'"'		; String?	JR	NZ,STRFLG	LD	(STRFLG+1),A	; Stuff string indicator	INC	HL	LD	A,(HL)		; Get char	CP	03H		; End again?	JP	Z,PCHERR	; That's still an errorSTRFLG	LD	A,00H		; Test string flag	OR	A	LD	A,(HL)		; Get char again	INC	HL		; Bump pointer	RET	NZ		; Return if '"' was prev char	CALL	CVTBIN		; Convert hex digit to binary	LD	C,A		; Save value	LD	A,(HL)		; Get next digit	INC	HL	CP	03H		; Backup pointer and return	JP	Z,PCHERR	;   if next char is not hex	CP	'0'		;   else pack it into reg C	JR	C,PRSFX3	;   and place in reg A	CP	'9'+1	JR	C,PRSFX2	CP	'A'	JR	C,PRSFX3PRSFX2	RLC	C		; Assume digit, move over	RLC	C		;   a nybble	RLC	C	RLC	C	CALL	CVTBIN		; Get hext digit	OR	C		; Merge high order nybble	RETPRSFX3	LD	A,C		; Non hex char, recover	DEC	HL	RET			;   and return;;	Routine to convert hex digit into binary;CVTBIN	SUB	'0'		; 1st adjustment to binary	JP	C,NONHEX	; Quit if too low	CP	0AH		; 0-9 range?	RET	C		; Return if so	RES	5,A		; Force to upper case	SUB	07H	CP	10H		; Less then 0Fh + 1?	RET	C		; Okay if so	JP	NONHEX		;   else abort;;	Routine to find ISAM member pointer in map table;FISAM	LD	DE,PGMDCBFISAM1	CALL	$GET1		; Get a type byte	JR	Z,FISAM1A	; Go on no error	CP	1CH		; End of file?	JP	Z,LIBERR	; Invalid library format if so	JP	IOERR		;   else I/O errorFISAM1A	CP	08H		; Start of the map table?	JR	Z,FISAM3	CP	0AH		; End of the map table?	JP	Z,NOVRLY	; Should not be the end!	PUSH	BC	LD	C,A		; Save the type byte	CALL	$GET		; Get block length	LD	B,A		; Set counter and read	DEC	C	JR	NZ,FISAM1B	; Go if not load record	CALL	$GET		;   else read 1st two bytes	DEC	B		;   and then fall through	CALL	$GET		;   in case len = 01 or 02	DEC	BFISAM1B	LD	A,B	POP	BC	LD	B,AFISAM2	CALL	$GET		; Through the block	DJNZ	FISAM2	JR	FISAM1		; Go back for more;;	Found a map field;FISAM3	CALL	$GET		; Get field length	LD	B,A		; Set the counter	CALL	$GET		; Get overlay number	DEC	B		; Reduce the count	CP	C		; Is the the one we want?	JR	NZ,FISAM2	; Loop to next field if not	CALL	$GET		; Get low order traaddr	CALL	$GET		; Get high order traaddr	CALL	$GET		; Get low order NRN	LD	C,A		; Save in C	CALL	$GET		; Get high order NRN	LD	B,A		; BC now holds next rec num	CALL	$GET		; Get byte offset	RET			; Done;;	Routine to repair the library map table;RPRMAP	LD	DE,PGMDCB	; Rewind the file	LD	BC,0	CALL	$POSN	LD	HL,PGMDATA	; Point to buffer areaRPRMAP1	CALL	$GET		; REad the map into buffer	CP	0AH		; End of the table?	JR	Z,RPRMAP3	LD	(HL),A		; Save type code	CALL	$GET		; Get the length	LD	B,A		; Set counter	LD	A,(HL)		; Re-get the type	INC	HL		; Bump where to stuff length	DEC	A		; Is this a load record?	LD	(HL),B		; Put length in too	INC	HL	JR	NZ,RPRMAP2	; Go if another type	CALL	$GET		;   else get two extra bytes	DEC	B		;   and adjust length in case	LD	(HL),A		;   it was 01 or 02	INC	HL	CALL	$GET	DEC	B	INC	HL	LD	(HL),ARPRMAP2	CALL	$GET		; Save member # and rest of	LD	(HL),A		;   the data entries	INC	HL	DJNZ	RPRMAP2	JR	RPRMAP1;;	Found end of the table;RPRMAP3	LD	(HL),A		; Show map end	LD	HL,PGMDATA	; Point to beginningRPRMAP4	LD	A,(HL)		; Get type code	INC	HL	LD	B,(HL)		; Get block length	INC	HL	CP	08H		; Map type is 8	JR	Z,RPRMAP6	; Go if found it	CP	0AH		; End of map?	JP	Z,NOVRLY	; Should not have gotten that	DEC	A		; Code block (type 1)?	JR	NZ,RPRMAP5	; Go if not	INC	HL		; You should know what this is	DEC	B		;   for by now	INC	HL	DEC	BRPRMAP5	INC	HL		; Bypass this field	DJNZ	RPRMAP5	JR	RPRMAP4;;	Found a type 8, check if ISAM number matches;RPRMAP6	LD	A,(HL)		; Get member number	INC	HL	DEC	B		; Count downOVRLY	CP	00H		; Compare to patched one	JR	NZ,RPRMAP5	; Keep reading until found	INC	HL		; Bypass transfer address	INC	HL	LD	E,(HL)		; Get the position low	INC	HL		;   and high order	LD	D,(HL)	INC	HL	LD	C,(HL)		;   and the byte offset	LD	A,B		; Calc pointer to next field	SUB	04H	LD	B,A	INC	HL		; <--------------------+	DJNZ	$-1		; Loop to next field --+RPRMAP7	LD	A,(HL)		; End of table reached?	CP	0AH		; If end, write the map back	JR	Z,RWRMAP	;   to the disk file	INC	HL		; Point to field length	LD	B,(HL)		; Get length	INC	HL		; Point to member number	INC	HL		; Tranfer addr low	INC	HL		; TRAADR high	INC	HL		; NRN low	LD	A,B		; Adjust count for the INC HLs	SUB	04H	LD	B,A	LD	A,(HL)		; If position is the same as	INC	HL		;   that of patched one, it's	CP	E		;   position has not changed	JR	NZ,RPRMAP8	;   so don't change it	LD	A,(HL)	INC	HL	DEC	B	CP	D		; Compare the high order	JR	NZ,RPRMAP9	LD	A,(HL)	CP	C		;   and the offset	JR	NZ,RPRMAP9LPFLD	INC	HL		; Loop to end of field	DJNZ	LPFLD	JR	RPRMAP7;;	Add the patch length to each position vector;RPRMAP8	INC	HL		; Bump to offset byte	DEC	BRPRMAP9	LD	DE,0		; Get patch length	LD	A,(HL)		; Get offset and add	ADD	A,E		;   low order patch length	LD	(HL),A	DEC	HL		; Point to NRN field	DEC	HL	LD	A,(HL)		; Get NRN low byte	ADC	A,D		; Add to it	LD	(HL),A	INC	HL		; Point to pos high byte	LD	A,(HL)		; Get the high byte	ADC	A,00H		; Add in any carry	LD	(HL),A	INC	HL		; Point to next map field	LD	DE,0	JR	LPFLD		; Loop;;	Routine to rewrite the library map table;RWRMAP	LD	DE,PGMDCB	; Rewind the program file	LD	BC,0	CALL	$POSN	LD	HL,PGMDATA	; Point to mapbuf startRWRMAP1	LD	A,(HL)		; Return when we get to the	CP	0AH		;   map end type byte	RET	Z	LD	C,A		; Save the end	INC	HL	CALL	$PUT		; Put the type	LD	A,(HL)		; Get the length	INC	HL	LD	B,A		; Save as counter	CALL	$PUT		; Write the length byte	DEC	C		; Again, this should look	JR	NZ,RWRMAP2	;   rather familiar	LD	A,(HL)	INC	HL	CALL	$PUT	DEC	B	LD	A,(HL)	INC	HL	CALL	$PUT	DEC	BRWRMAP2	LD	A,(HL)		; Put block of code	INC	HL	CALL	$PUT	DJNZ	RWRMAP2	JR	RWRMAP1		; Loop for more;;	This routine enters at PASS 1.  It does the first pass;	through the fix data, and checks for params as well;	as checking the Drr,bb and Frr,bb matches.;SPASS2	LD	(PASS2),A	; Flag pass 2	JP	DOFIX		; Start over;PASS1	CP	'.'		; Comment line?	JR	Z,OK	CP	03H		; End of fix data?	JR	Z,SPASS2	; End of pass 1	RES	5,A		; Force char to upper case	CP	'D'		; D line patch?	JR	Z,FCHK	CP	'R'		; Remove param?	JP	Z,REMOVE	CP	'O'		; Special O param?	JP	Z,OVERB	CP	'F'		; Find line data?	JR	Z,OK	CP	'Y'		; Yank param?	JR	Z,OK	CP	'L'		; Library ISAM number?	JR	Z,OK	CP	'X'		; X line patch?	JP	NZ,PCHERR	; Abort if not one of the aboveOK	JP	COMMENT;;	Check the Drr,bb (if REMOVE) or Frr,bb line;FCHK	LD	A,0FFH		; If O param = off, thenOPARM	EQU	$-1		;   don't do the check	OR	A	JP	Z,COMMENT	; Skip check if O=OFF	LD	A,00H		; Remove param used?RPARM	EQU	$-1	OR	A	JP	NZ,YANKD	; Reverse D and F lines if so	LD	(DL),HL		; Save D Line pointer	CALL	SKPLN		; Move to F line	CALL	DOCHK		; Comp F line bytes with file	JP	DOFIX1;;	Checks Drr,bb and Frr,bb addresses for a match;	Checks Frr,bb against program file if patching, or;	Drr,bb if removing;DOCHK	LD	(SETMSG+1),HL	; Set line error message	PUSH	HL		; Save position	LD	DE,(DL)		; Get D or F line to check	LD	B,03H		; Init the check countCP3	INC	HL	INC	DE	LD	A,(DE)	CP	(HL)	JP	NZ,FERROR	; 'FIND' error	DJNZ	CP3		; Check the first three bytes;	LD	B,03H		; Assume was 2 digit record #	LD	A,','		; Comma?	CP	(HL)	JR	Z,CP5		; Yes, continue	LD	B,05H		; Adjust, assume 5 digit rec #CP5	INC	HL		; Check rest of 'rr,bb' string	INC	DE	LD	A,(DE)	CP	(HL)	JP	NZ,FERROR	; 'FIND' error	DJNZ	CP5;	EX	(SP),HL		; Point to '=' in fix line	CALL	DPOSN		; Position the file	POP	HL	CALL	DLINE		; Check rest of line for match	RET;;	Remove used.  Check Drr,bb lines instead of Frr,bb lines;YANKD	PUSH	HL		; Save D line pointer	CALL	SKPLN		; Move to F line	LD	(DL),HL		; Save pointer	POP	HL		; => D line	PUSH	HL		; Save D line again	CALL	DOCHK		; Test D line	POP	HL	LD	(HL),'.'	; Make comment for pass 2	LD	HL,(DL)	LD	(HL),'D'	; Make 'F' line into D line	CALL	SKPLN		; Point to the next line	JP	DOFIX1;;	Skip past the current line, position to start of next;SKPLN	CALL	SKPLN1		; Move past current line	LD	A,(HL)		; Check 1st char next line	CP	'.'		; Is it a comment?	JR	Z,SKPLN		; Then skip it, too	RET;SKPLN1	LD	A,(HL)		; Get line character	INC	HL		; Bump pointer	CP	0DH		; Physical end of line?	RET	Z	CP	';'		; Logical end of line?	RET	Z	JR	SKPLN1		; Loop until EOL found;;	Get the next character, converted to upper case;GETNXT	LD	A,(HL)		; Get the char	INC	HL		; Bump the buffer pointer	RES	5,A		; Force char to upper case	RET			;   and return;;	Either write a character, or check for a match;PUTORCHK	LD	C,A		; Char in question	LD	A,(PASS2)	; Write pass?	OR	A	LD	A,C		; Put char back in A reg	JP	NZ,$PUT		; Writing patch if NZ	CALL	$GET		; Get next character from file	CP	C		; Match with patch?	RET	Z		; Okay if it matchesFERROR	LD	HL,LOCERR$	; "Find mismatch...	JP	ERRDSP		; Display and quit;;	Count patch lines;CNTLIN	PUSH	HL		; Save HL	LD	HL,(LINCNT)	; Get current line count	INC	HL		; Add one to it	LD	(LINCNT),HL	; Save line count	POP	HL		; Get HL back again	RET;;	After an error, show file not close if necessary;FLOPN	LD	A,(WRFLAG)	; Did we modify the file?	OR	A	JR	NZ,MESS		; Yes, don't close it	@@CLOSE			; No changes	JP	NZ,IOERR	; Quit on close error	RET;MESS	LD	HL,WARN1$	; File is modified, but patch	CALL	$DSPLY		;   did not complete	LD	HL,WARN2$	; Ooops!	JP	$DSPLY		; Then return to caller;$OPEN	@@OPEN	JR	NZ,IOERR	RET$POSN	@@POSN	JR	NZ,IOERR	RET$BKSP	@@BKSP	JR	NZ,IOERR	RET$RWRIT	@@RWRIT	JR	NZ,IOERR	RET$GET1	@@GET			; Use this if prog might get EOF	RET$GET	@@GET			; This one if EOF is an error	JR	NZ,IOERR	RET$PUT	PUSH	BC	LD	C,A	LD	A,0FFH		; Flag that file has been	LD	(WRFLAG),A	;    modified	@@PUT	POP	BC	JR	NZ,IOERR	RET$DSPLY	@@DSPLY	JR	NZ,IOERR	RET$READ	@@READ	JR	NZ,IOERR	RET$DSP	PUSH	BC	LD	C,A	@@DSP	POP	BC	RET	Z;;	Error handling;IOERR	LD	L,A		; Move error # to HL	LD	H,00H	OR	0C0H		; Short message, return	LD	C,A	@@ERROR			; Show the error message	JR	QUIT1;;	Internal error routine;NOVRLY	LD	HL,NOVRLY$	; "Library not found	DB	0DDHLIBERR	LD	HL,LIBERR$	; "Invalid library	DB	0DDHFILERR	LD	HL,FILERR$	; "Not load file format	DB	0DDHPRMERR	LD	HL,PRMERR$	; "Param error	DB	0DDHTOOBIG	LD	HL,TOOBIG$	; "Fix file too big	DB	0DDHPGMREQ	LD	HL,PGMREQ$	; "Patch what file?ERREXIT	@@LOGOT			; Log the error	LD	HL,-1		; Set abort codeQUIT1	JP	$QUIT;NONHEX	LD	HL,NONHEX$	; "Non hex digit	DB	0DDHPCHERR	LD	HL,PCHERR$	; "Patch format errorERRDSP	PUSH	HL	LD	A,0DH		; Move the cursor down	CALL	$DSPSETMSG	LD	HL,0		;	@@LOGOT	POP	HL	JR	ERREXIT;;	Messages and data area;YNKFLG	DB	0		; Was function YANK?LINCNT	DW	0		; Count lines installedWRFLAG	DB	0		; Did pgm write to file?DL	DW	0		; Save pointer to line;CMDEXT	DB	'CMD'		; Default program file extFIXEXT	DB	'FIX'		; Default patch file ext;PGMDCB	DB	00H		;EQU	M2D7F	DS	32FIXDCB	DS	32		;EQU	2DA0H;;HELLO$	DB	'PATCH'*GET	CLIENT;PGMREQ$	DB	'PROGRAM file name required',0DHPRMERR$	DB	'Parameter error',0DHPOSLD$	DB	1DH,'Positioning load file',1EH,' ',03HRDGINP$	DB	1DH,'Reading input',1EH,' ',03HGENPCH$	DB	1DH,'Generating patch',1EH,' ',03HINSPCH$	DB	1DH,'Installing patch',1EH,' ',03HBLDMAP$	DB	1DH,'Re-building library map',1EH,' ',03HYNKPCH$	DB	1DH,'Yanking patch from file',1EH,' ',03HNOYANK$	DB	0AH,'Can',27H,'t yank, patch not in load file',0DHNOVRLY$	DB	'Library overlay not found',0DHLIBERR$	DB	'Invalid library format',0DHPCHERR$	DB	'Patch input format error',0DHFILERR$	DB	'Load file format error',0DHNONHEX$	DB	'Non-hex digit encountered',0DHSUCCES$	DB	0AH,'Patch function completed.',0DHLINMSG$	DB	'   No patch line'PLURAL	DB	's installed.',0DHTOOBIG$	DB	'Fix file too big - partition it',0DHYANKMSG	DB	'Patch successfully yanked',0DHNAMLEN$	DB	03HNAMFIX$	DB	'CLP     'LOCERR$	DB	'FIND line mismatch',0DHWARN1$	DB	'WARNING - File 'FNM$	DB	'                        'WARN2$	DB	' Not Closed',0DH;;	Parameter table;PTBL$	DB	80H		; Version 6.3 parameter table;	DB	FLAG!ABB!6,'REMOVE',0	DW	RPARM1;	DB	FLAG!1,'O',0	DW	OPARM1	DB	00H;;	Buffer space;	ORG	$<-8+1<+8;FIXBUF	DS	256	;EQU	3100HLIBBUF	DS	256	;EQU	3200HPGMBUF	DS	256	;EQU	3300HFIXDATA	DS	1400H	;EQU	3400HPGMDATA	EQU	$	;4800H;	END	BEGIN