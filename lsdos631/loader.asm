;****************************************************************;* Filename: LOADER/ASM						*;* Rev Date: 30 Nov 97						*;* Revision: 6.3.1						*;****************************************************************;* System Loader and associated routines			*;*								*;****************************************************************;CORE$	DEFL	$		;Save where we are	ORG	SVCTAB$;;	Supervisor Call Table - Page 5;	DW	@IPL,@KEY,@DSP,@GET		;0-3	DW	@PUT,@CTL,@PRT,@WHERE		;4-7	DW	@KBD,@KEYIN,@DSPLY,@LOGER	;8	DW	@LOGOT,@MSG,@PRINT,@VDCTL	;12	DW	@PAUSE,@PARAM,@DTHDLR,@TIME	;16	DW	@CHNIO,@ABORT,@EXIT,SVCERR	;20	DW	@CMNDI,@CMNDR,@ERROR,@DEBUG	;24	DW	@CKTSK,@ADTSK,@RMTSK,@RPTSK	;28	DW	@KLTSK,@CKDRV,@DODIR,@RAMDIR	;32	DW	SVCERR,SVCERR,SVCERR,SVCERR	;36	DW	@DCSTAT,@SLCT,@DCINIT,@DCRES	;40	DW	@RSTOR,@STEPI,@SEEK,@RSLCT	;44	DW	@RDHDR,@RDSEC,@VRSEC,@RDTRK	;48	DW	@HDFMT,@WRSEC,@WRSSC,@WRTRK	;52	DW	@RENAME,@REMOVE,@INIT,@OPEN	;56	DW	@CLOSE,@BKSP,@CKEOF,@LOC	;60	DW	@LOF,@PEOF,@POSN,@READ		;64	DW	@REW,@RREAD,@RWRIT,ZEROA@	;68	DW	@SKIP,@VER,@WEOF,@WRITE		;72	DW	@LOAD,@RUN,@FSPEC,@FEXT		;76	DW	@FNAME,@GTDCT,@GTDCB,@GTMOD	;80	DW	SVCERR,@RDSSC,@GATRD,@DIRRD	;84	DW	@DIRWR,@GATWR,@MUL8,@MUL16	;88	DW	SVCERR,@DIV8,@DIV16,@HEXDEC+2	;92	DW	@DECHEX,@HEXDEC,@HEX8,@HEX16	;96	DW	@HIGH$,@FLAGS,@BANK,@BREAK	;100	DW	@SOUND,@CLS,@CKBRKC,@PRTSCR	;104	DW	SVCERR,SVCERR,SVCERR,SVCERR	;108	DW	SVCERR,SVCERR,SVCERR,SVCERR	;112	DW	SVCERR,SVCERR,SVCERR,SVCERR	;116	DW	SVCERR,SVCERR,SVCERR,SVCERR	;120	DW	SVCERR,SVCERR,SVCERR,SVCERR	;124;	ORG	CORE$		;BACK TO WHERE WE WERE;;	Routine to set or retrieve HIGH$/LOW$;@HIGH$	LD	A,H		;TEST IF PUT OR GET	OR	L	JR	Z,GETHILO	;GO IF GET	LD	A,(CFLAG$)	;IS HIGH$ CHANGEABLE?	RRCA	LD	A,43		;INIT SVC PARM ERROR	RET	C		;BACK WITH NZ	INC	B		;TEST FOR HIGH$/LOW$	DEC	B	JR	NZ,PUTLO	;GO IF LOW$	LD	(HIGH$),HL	;SET NEW HIGH$GETHI	LD	HL,(HIGH$)	;GET THE VALUE	RETGETHILO INC	B		;TEST FOR HIGH$/LOW$	DEC	B	JR	Z,GETHI	LD	HL,(LOW$)	;GET LOW$PUTLO	LD	(LOW$),HL	;SET LOW$	XOR	A		;SET Z FLAG	RET;@FLAGS	LD	IY,FLGTAB$	RET;@BREAK	PUSH	HL		;Save user vector	LD	HL,(BRKVEC$)	;Get current vector	EX	(SP),HL		;Save current & get user	LD	(BRKVEC$),HL	;Stuff new vector	POP	HL		;Recover old vector	RET;@WHERE	POP	HL	JP	(HL);;	Code for these SVCs is in system overlays;@CMNDR	LD	A,0A3H		;Interpret command and return	RST	40@CMNDI	LD	A,0B3H		;Interpret a command	RST	40@FSPEC	LD	A,0C3H		;Parse a filespec	RST	40@FEXT	LD	A,0D3H		;Optional default ext	RST	40@PARAM	LD	A,0E3H		;Parameter error	RST	40@OPEN	LD	A,94H		;Open a file	RST	40@INIT	LD	A,0A4H		;Initialize a file	RST	40@GTDCB	LD	A,0B4H		;Get a DCB vector	RST	40@CKDRV	LD	A,0C4H		;Drive available?	RST	40@RENAME LD	A,0F4H		;Rename a file	RST	40@CLOSE	LD	A,95H		;Close a file	RST	40@FNAME	LD	A,0A5H		;Recover filespec	RST	40@DBGHK	RET			;Init debug off (NOP=on)@DEBUG	PUSH	AF	LD	A,97H		;Enter system debugger	RST	40EXTDBG$ DW	ORARET@		;Hook for extended debugger@REMOVE LD	A,9CH		;Remove a file/device	RST	40@DOKEY	LD	A,0CDH		;Do execution	RST	40@RAMDIR LD	A,9EH		;Directory data	RST	40@DODIR	LD	A,0AEH		;Directory data	RST	40@GTMOD	LD	A,0BEH		;Get module address	RST	40;;	These SVCs handle the disk primitive requests;@DCSTAT XOR	A		;FDC Status	JR	IOFUNCTAPDRV	LD	A,(LDRV$)	;GET DRIVE #	LD	C,A@SLCT	LD	A,1		;SELECT DRIVE	JR	IOFUNC@DCINIT LD	A,2		;FDC INIT	JR	IOFUNC@DCRES	LD	A,3		;FDC RESET	JR	IOFUNC@RSTOR	LD	A,4		;RESTORE TO CYL 0	JR	IOFUNC@STEPI	LD	A,5		;STEP IN 1 CYL	JR	IOFUNC@SEEK	LD	A,6		;SEEK A TRACK/SECTOR	JR	IOFUNC@RSLCT	LD	A,7		;RE-SELECT A DRIVE	JR	IOFUNC@RDHDR	LD	A,8		;??	JR	IOFUNC@VRSEC	LD	A,10		;VERIFY A SECTOR	JR	IOFUNC@RDTRK	LD	A,11	JR	IOFUNC@HDFMT	LD	A,12	JR	IOFUNC@WRSEC	LD	A,13		;WRITE STANDARD SECTOR	JR	IOFUNC@WRSSC	LD	A,14		;WRITE A SYSTEM SECTOR	JR	IOFUNC@WRTRK	LD	A,15		;WRITE A TRACK	JR	IOFUNC@RDSEC	LD	A,9		;READ A SECTOR;IOFUNC	PUSH	BC		;SAVE REG PAIR	LD	B,A		;XFER FUNCTION CODE;;	Bring up bank 0;	PUSH	BC	XOR	A	LD	B,A		;SET BANK FUNCTION 0	LD	C,A		;  BANK NUMBER 0	CALL	@BANK		;BRING UP BANK	POP	AF		;PERFORM EX (SP),BC	PUSH	BC	PUSH	AF	POP	BC;;	Continue disk I/O setup;	LD	A,C		;XFER THE DRIVE CODE	LD	(LDRV$),A	PUSH	IY	CALL	@GTDCT		;GET DCT ADDRESS TO IY	LD	A,20H		;SET ILLEGAL DRIVE #	OR	A		;  IF DRIVE DISABLED	CALL	GODOIO	POP	IY;;	Bring back the old bank;	POP	BC	PUSH	AF		;SAVE DISK I/O RETCODE	LD	A,102		;SET FOR @BANK	RST	40		;NO NEED TO CK FOR ERROR	POP	AF	POP	BC	RET;GODOIO	JP	(IY);@GTDCT	PUSH	HL		;GET I/O ROUTINE ADDRESS	CALL	DCTFLD@		;  INTO IY	EX	(SP),HL	POP	IY	RET;;	Entry to get DCT+8 of FCB (IX) drive spec;D@FBYT8 LD	C,(IX+6)	;get drive;;	Entry to get DCT+8 of register C drive spec;DCTBYT8@	LD	A,8;;	Entry to get byte (reg A) from DCT of drive (reg C);	 C -> Logical drive specification;	 A -> relative byte requested from DCT;	 A <- Data at position requested;@DCTBYT PUSH	HL		;SAVE THE REGISTER PAIR	LD	H,A		;XFER RELATIVE POSITION	CALL	DCTFLD@		;GET HL POINTING TO	LD	L,A		;  DCT POSITION	LD	A,(HL)		;GET THE BYTE	POP	HL	RET;;	Entry to get HL pointing to DCT byte reg C, Reg A;	 C -> Logical drive specification;	 H -> relative byte requested from DCT;	HL <- Start of requested DCT for the drive;	 A <- Low order pointer to relative byte request;DCTFLD@ LD	A,C		;GET DRIVE SPEC &	AND	7		;  STRIP EXCESS DATA	ADD	A,A		;TIMES 2	LD	L,A		;  & SAVED	ADD	A,A		;TIMES 4	ADD	A,A		;TIMES 8	ADD	A,L		;TIMES 10	ADD	A,70H		;ADD DCT OFFSET FROM 0	LD	L,A		;POINT L TO DCT LOW ORDER	ADD	A,H		;ADD IN REL POS DESIRED	LD	H,DCT$<-8	;POINT H TO DCT HIGH ORDER	RET;;	Process supervisory calls (0-127);SVCUSER CP	26		;CHECK FOR @ERROR	JR	Z,ERRSVC	;SKIP NEXT IF SO	LD	(LSVC$),A	;STORE SVC REQUEST	EX	(SP),HL		;GET RETURN ADDRESS	LD	(SVCRET$),HL	;  AND SAVE IT	EX	(SP),HL		;RESTORE RET ADDRESSERRSVC	PUSH	HL		;SAVE HL	RLCA			;MULTIPLY BY TWO	LD	H,SVCTAB$<-8	;BASE OF TABLE	LD	L,A		;HL NOW POINTS TO ADDR	LD	A,(HL)		;GET TABLE ENTRY	INC	L	LD	H,(HL)	LD	L,A	EX	(SP),HL		;GET HL @ STUFF VECTOR	LD	A,C		;XFER FOR PUT TYPE OPS	RET;;	RST 28 vector - System and user SVCs;RST28	OR	A		;TEST IF BIT 7 SET	JP	P,SVCUSER	;JUMP ON USER SVC REQUEST	EX	(SP),HL		;DISCARD RETURN ADDRESS	PUSH	AF		;  & SAVE HL, AF	LD	HL,@DBGHK	;SET UP DEBUG LINKAGE	LD	A,(HL)	LD	(SET@EXEC),A	LD	(HL),0C9H	POP	AF		;RESTORE AF,HL	POP	HLHKRES$	CALL	CKMOD@		;GET OVERLAY IF NEEDED	LD	A,0		;GET NEW OVERLAY #OVRLYOLD	EQU	$-1	LD	(OVRLY$),A	;  & UPDATE CURRENTTRANSFR CALL	0		;TRAADR OF SYSx	PUSH	AF	LD	A,0		;SET TO C9 IF EXEC ONLYSET@EXEC	EQU	$-1	LD	(@DBGHK),A	POP	AF	RET;;	DOS command overlay request;CKMOD@	PUSH	HL	LD	H,A		;SAVE COMMAND VALUE	LD	A,B	LD	(EXOVR2+1),A	;SET OVERLAY #	LD	A,H	OR	1		;SET FOR SYS6 & SYS7	CP	89H		;IS IT EITHER?	LD	A,H		;GRAB CORRECT ONE BACK	JR	Z,EXOVR		;SYS6/7 REQ?  USE ISAM!	CP	8AH		;SYS8 ALSO ISAM	JR	Z,EXOVR	LD	A,(OVRLY$)	;GET CURRENT OVERLAY	XOR	H		;CHECK IF IT'S THE ONE	AND	0FH		;  WE NEED TO EXECUTE	LD	A,H	LD	(OVRLYOLD),A	;UPDATE CURRENT TEMPORARY	LD	HL,OVERLAY	;INIT TO SYSx ENTRY	JR	Z,EXOVR3	;GO EXEC IF RESIDENT;;	Execute a system overlay;EXOVR	PUSH	DE	PUSH	BC	AND	0FH		;GET RIGHT NIBBLE	BIT	3,A		;CHECK FOR SYS0-7	JR	Z,EXOVR1	;  W/O CHANGING CARRY	ADD	A,18H		;ADJUST FOR SYS8-15EXOVR1	LD	(SFCB$+7),A	LD	B,A		;SET D.E.C. FOR DIRECTORY	LD	A,20H		;SET BIT 5 OF FCB+1	LD	(SFCB$+1),A	SBC	HL,HL		;CARRY IS CLEAR HERE	LD	(SFCB$+10),HL	;ZERO NRN	LD	C,H		;INIT FOR DRIVE 0	CALL	@DIRRD		;READ DIR ENTRY	JR	NZ,EXERR	;GO IF ERROR	LD	A,(HL)		;WAS OVERLAY PURGED	AND	50H		;  OR IS IT NON-SYSTEM	XOR	50H	LD	A,7		;INIT "DELETED" ERROR	JR	NZ,EXERR	LD	A,L	ADD	A,22		;POINT TO 1ST EXTENT	LD	L,A	LD	DE,SFCB$+14	;EXTENT FIELD IN FCB	CALL	PAT1		;STUFF 1ST 2 EXTENTSEXOVR2	LD	B,0		;GET ISAM # OR ZERO	LD	E,SFCB$&0FFH	CALL	LOADER		;READ SYSTEM OVERLAYEXERR	POP	BC	POP	DEEXOVR3	LD	(TRANSFR+1),HL	;STUFF OVERLAY ENTRY POINT	POP	HL	RET	Z	JR	SYSERR		;GO IF I/O ERROR ON READ;;	Routine to calulate 1st 2 extents of SYS file;PAT1	CALL	PAT1A		;MOVE FIRST EXTENT	AND	1FH		;COMPUTE # OF GRANULES	INC	A	LD	(DE),A		;STORE IN FCB	INC	DE	XOR	A	LD	(DE),A	INC	DEPAT1A	CALL	PAT1B		;MOVE SECOND EXTENTPAT1B	LD	A,(HL)	LD	(DE),A	INC	HL	INC	DE	RET;;	System error display routine;	The NOP is provided so an intercept routine vector;	may be patched in during program development;SVCERR	LD	A,43		;SVC ERROR	NOPSYSERR	AND	3FH		;STRIP EXCESS BITS	LD	HL,ERRNUM	;PACK ERROR NUMBER	CALL	@HEX8		;  INTO MESSAGE	LD	HL,SYSERR$	CALL	@LOGOT		;LOG ERROR AND ABORT	LD	SP,STACK$	;RESET STACK@ABORT	LD	HL,-1@EXIT	LD	A,93H		;EXIT TO DOS	RST	40;POPERR	POP	HL		;POP EXTENDED ERROR@ERROR	PUSH	AF		;SAVE ERROR CODE	LD	A,96H		;DISPLAY ERROR NUMBER	RST	40;SYSERR$ DM	'Error 'ERRNUM	DM	'xxH',CR;;	Routine to RUN a program;@RUN	PUSH	HL		;SAVE REGISTER PAIR	LD	HL,SFLAG$	SET	2,(HL)		;TURN ON RUN FLAG BIT	CALL	@LOAD		;LOAD THE PROGRAM MODULE	EX	(SP),HL		;PUT TRAADR ON THE STACK;;	Note: The error code is set to NOT abort.  Errors;	will be passed back to the calling module after;	@ERROR.	 Note that HL will contain the error #.;	JR	NZ,POPERR;;	Place the INBUF$ pointer in register pair BC;	LD	BC,INBUF$	;Reflect buffer pointer;;	Get TRAADR then test if we need to go to DEBUG;	LD	A,(SFLAG$)	BIT	1,A		;GO TO THE PROGRAM IF	RET	NZ		;  IT'S EXEC ONLY ACCESS	BIT	7,A		;  ELSE TEST IF DEBUG	JP	NZ,@RST30	;  IS ON & GO TO IT	RET			;  ELSE GO TO PROGRAM;;	This module LOADs a Load Module Format file;@LOAD	LD	B,0		;LRL=256	LD	HL,SFLAG$	SET	0,(HL)		;DON'T SET "FILE OPEN"	LD	HL,SBUFF$	;SET BUFFER TO SYSTEM	CALL	@OPEN		;OPEN THE FILE	PUSH	DE		;SAVE FCB POINTER	CALL	Z,LOADER	;LOAD IF NO OPEN ERROR	POP	DE		;RESTORE FCB	RET	Z		;BACK IF NO ERROR	LD	L,A		;XFER THE ERROR CODE	LD	H,0	OR	0C0H		;SET RET & ABBREV	CP	0D8H		;CHANGE "FILE NOT IN DIR"	RET	NZ		;  TO "PROGRAM NOT FOUND"	ADD	A,7	RET;;	System command file loader;LOADER	LD	A,B		;SET OVERLAY # (0 ON	LD	(LDR14+1),A	;  NON-SYS FILE)	PUSH	DE		;SAVE IX & XFER FCB TO IX	EX	(SP),IX	LD	DE,SBUFF$+255	;INIT TO END OF BUFFER	CALL	LDR01		;DO THE LOAD	POP	IX		;RECOVER IX	RET;;	Routine to ignore the LMF record;LDR05	CALL	LDR15		;GET LENGTH OF "COMMENT"	LD	B,ALDR06	CALL	LDR15		;READ AND IGNORE THAT MANY	DJNZ	LDR06		; BYTES THEN FALL THROUGH;;	Routine to parse LMF record types;LDR01	CALL	LDR15		;GET RECORD TYPELDR02	CP	1		;START OF BLOCK?	JR	Z,LDR08	CP	2		;START OF TRANSFER ADDRESSLDR03	JR	Z,LDR07	CP	4		;END OF LIB MEMBER	JR	Z,LDR12	CP	8		;BEGIN ISAM TABLE ENTRY?	JR	Z,LDR13	CP	10		;END OF ISAM MAP?	JR	Z,LDR04	CP	20H		;IGNORE ALL OTHER CONTROL	JR	C,LDR05LDR04	LD	A,22H		;LOAD FILE FORMAT ERROR	OR	A	RET;;	Grab transfer address;LDR07	CALL	LDR15		;BYPASS SECOND 02H	CALL	GETADR		;GET ADDRESS	RET			;Z OR NZ;;	Grab load block;LDR08	CALL	LDR15		;GET BLOCK LENGTH	LD	B,A	CALL	GETADR		;GET LOAD ADDRESS	RET	NZ	DEC	B		;ADJ LENGTH FOR ADR	DEC	BLDR09	CALL	LDR15		;GET BLOCK BYTE	LD	(HL),A		;STORE AT LOAD ADDRESS	INC	HL	DJNZ	LDR09		;LOOP UNTIL BLOCK END	JR	LDR01		;BACK FOR ANOTHER BLOCK;LDR12	POP	HL	RET;;	Routine to check ISAM table match;LDR13	CALL	LDR15		;GET RECORD LENGTH	LD	B,A	CALL	LDR15		;GET ISAM NUMBER	DEC	B		;  AND DECR COUNTERLDR14	CP	0		;EITHER ISAM# OR 0	JR	NZ,LDR06	;GO IF NO MATCH	CALL	GETADR		;  ELSE GET TRANSFER ADDR	PUSH	HL		;  AND SAVE IT	CALL	Z,GETADR	;GET THE NRN FOR MEMBER	JR	NZ,LODERR	CALL	LDR15		;GET THE SECTOR OFFSET	LD	E,A		;UPDATE POINTER OFFSET	PUSH	BC	LD	B,H		;XFER NRN POSITION NEEDED	LD	C,L	PUSH	DE		;SAVE BUFFER PTR OFFSET	PUSH	IX	POP	DE		;GET FCB INTO DE	CALL	@POSN		;POSITION TO ISAM RECORD	POP	DE		;RECOVER BUFFER PTR OFFSET	POP	BC	JR	NZ,LODERR	CALL	LDR17		;READ THE SECTOR	JR	LDR02		;NOW GO READ THE MEMBER;;	Routine to get the next file byte;LDR15	INC	E		;BUMP BUFFER POINTER	JR	Z,LDR17		;READ SECTOR IF NEEDEDLDR16	LD	A,(DE)		;GET BYTE FROM BUFFER	RETLDR17	PUSH	HL		;SAVE REGS	PUSH	DE	PUSH	BC	CALL	NXTSECT		;READ NEXT SECTOR	POP	BC		;RESTORE REGS	POP	DE	POP	HL	JR	Z,LDR16		;BYPASS IF NO ERRORLODERR	POP	BC		;POP RETURN ADDRESS	RET;;	Routine to get an address field;GETADR	CALL	LDR15		;GET LOW ORDER BYTE	LD	L,A	CALL	LDR15		;GET HIGH ORDER BYTE	LD	H,A	CP	A		;NON-ZERO RETURN	RET;;	BOOT code brings back the ROM;MOD3BUF	EQU	4300H@IPL	LD	HL,BOOTCOD	;CODE TO TOGGLE IN ROM	LD	DE,MOD3BUF	;BUFFER USED BY ROM	PUSH	DE		;THIS IS THE RETURN ADDRESS	LD	BC,BOOTLEN	LDIR			;TRANSFER BOOT CODE AND	RET			;  JUMP TO IT;;	End of loader module;