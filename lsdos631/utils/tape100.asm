; ***************************************************************; * Filename: TAPE100/ASM					*; * Revision: 06.03.01						*; * Rev Date: 19 Dec 97						*; ***************************************************************; * Model 100 Tape <-> Disk Transfer Utility			*; *								*; ***************************************************************;	TITLE	<TAPE100 - LS-DOS 6.3>;BREAKLC	EQU	0F440H		; <BREAK> key locationLOADA	EQU	3AH		; LD A,(nnnn) opcodeWRMASK	EQU	'W'-'A'		; WRINTMASK port mask byteMODMASK	EQU	'M'-'A'		; MODOUT port mask byte;@INIT	EQU	58		; SVC number for @INIT@OPEN	EQU	59		; SVC number for @OPEN;PORTE0	EQU	0E0HMODOUT	EQU	0ECHPORTFF	EQU	0FFHOPREG$	EQU	78H		; Operating register@OPREG	EQU	84H		; Video/keyboard control portVIDEO	EQU	0F800H		; Start of video RAM;WHICH1	EQU	22H		; Which one - 0 or 1?TOOSHRT	EQU	0FH		; Pulse too short?TOOLONG	EQU	3EH		; Pulse too long?ROUTOFF	EQU	6		; Interrupt rout offsetDIFFER	EQU	0DH		; Difference between 2 pulsesDELAY0	EQU	2B2FH		; Bit 0 delay countDELAY1	EQU	1217H		; Bit 1 delay count;CURON	EQU	14		; Curson onCUROFF	EQU	15		; Cursor off;*GET	SVCMAC			; System SVC macros*GET	VALUES			; Miscellaneous equates*GET	COPYCOM			; Copyright message;	ORG	2600H;START	@@CKBRKC		; Check for break	JR	Z,STARTA	; Go if not	LD	HL,-1		;  else abort	RET;STARTA	LD	(OLDSP+1),SP	; Save entry stack	CALL	DOINIT		; Do initialization;;	Was READ or WRITE specified?;	LD	A,(RRESP)	; Get read response byte	LD	B,A		; Transfer to B	LD	A,(WRESP)	; Get write response byte	XOR	B		; Are both the same?	JR	Z,INP_R_W	; Yes - prompt for which;;	Both weren't entered - check which one was;CHKPRM	INC	B		; READ entered?	DEC	B	JR	Z,WRTAPE	; <W>rite a tape file	JP	RDTAPE		; <R>ead a tape file;;	Prompt for READ or WRITE;INP_R_W	PUSH	HL		; Save cmd pointer;	LD	HL,RDORWR	; "Read or write...	CALL	DSPLY;;	Input R (read) or W (write) from user;	LD	B,01H		; Get 1 char input	CALL	INPUT	LD	A,(HL)		; Get user's entry	POP	HL		; Recover command line pointer	RES	5,A		; Force reply to upper case	CP	'R'		; Was it <R>ead?	JP	Z,RDTAPE	; Go if it was	CP	'W'		; <W>rite entered?	JR	NZ,INP_R_W	; Loop back if it was neither;;	Write disk file to a tape file;WRTAPE	LD	DE,FCB1		; DE => Source FCB	@@FSPEC			; If a bad filespec,	CALL	NZ,PRSOUR	;   prompt for source;;	Write - check if destination filespec input;	LD	DE,FCB2		; DE => Destination FCB	@@FSPEC			; Parse for filespec	CALL	NZ,PRDEST	; Prompt for destination	CALL	GTFILE		; Transfer into filename;;	Open disk source file;OPDSRC	LD	DE,FCB1		; DE => source	CALL	OPEN	JP	NZ,IOERR	; Quit on error;;	Can this disk file fit into memory?;	LD	HL,(FCB1+12)	; Get ending rec num	INC	H		; Too big?	DEC	H	JP	NZ,TOOBIG	; Yes - forget itENUF	LD	A,00H		; Enough memory?	ADD	A,MEM<-8	; Add mem start	CP	L	JP	C,TOOBIG	; No - forget it;;	Read in disk file and write it to tape;	CALL	PRTAPE		; Display "Ready tape	CALL	CURSOFF		; Turn off cursor	LD	HL,READING	; "Reading...	CALL	DSPLY	LD	HL,DFBUF	; HL => disk filename	CALL	DSPLY		; Display it	CALL	READSRC		; Read the source file	CALL	GETPOS		; Get new cursor position	CALL	ENDOKI		; Bring in video and kbd	LD	HL,WRITING	; Display "writing...	CALL	DISPSTR	LD	HL,FILENM	; "filenm"	CALL	DISPSTR	CALL	CASSON		; Turn on cassette	LD	B,80H		; Pause for a bit	@@PAUSE	CALL	WRHEAD		; Write header	CALL	WRDAT		; Write data	LD	HL,(CURPOS)	; Get new cursor position	CALL	GETCRS		; Convert to row,column	LD	B,03H		; Give to system	@@VDCTL	CALL	DISDOKI		; Restore video	CALL	CASOFF		; Turn off cassette	JP	EXIT		; Clean exit;;	Get source and destination for READ operation;RDTAPE	LD	DE,FCB1		; First filespec legal?	@@FSPEC	JR	Z,CHKSEC	; Yes - check for second;;	Accept first filename on tape;	LD	A,0C9H		; Code for RET	LD	(CORRECT),A	; Store in routine	LD	DE,FCB2		; Prompt for dest filename	CALL	PRDEST2	JR	READFIL		; Read file;;	Copy source FCB into destination;CHKSEC	PUSH	HL		; Save comm ptr	EX	DE,HL	LD	DE,FCB2		; DE => Disk FCB	LD	BC,32		; 32 bytes to move	PUSH	DE	LDIR	POP	DE		; Get Dest FCB back	POP	HL;;	Get destination filespec;	DEC	HL		; Skip leading spacesSKPSPC	INC	HL	LD	A,(HL)		; Get a character	CP	' '		; Space?	JR	Z,SKPSPC	; Loop until it's not	CP	CR+1		; End of line?	JR	C,GTFILE2	; Yes, use default	CP	'('		; Start of parameters?	JR	Z,GTFILE2	; Yes, use default	@@FSPEC			; Parse filespec;;	Transfer filename into buffer left justified;GTFILE2	LD	DE,FCB1		; DE => source	CALL	GTFILE		; Stuff filename into buffer;;	Read in tape source file;READFIL	LD	DE,FCB2		; @INIT the destination file	CALL	INIT	JP	NZ,IOERR	; Quit on error	LD	C,(IX+06H)	; Get drive #	@@CKDRV			; Write protected?	LD	A,0FH		; "Write protected disk	JP	C,IOERR		; Jump if it is	CALL	PRTAPE		; "Ready tape	CALL	CURSOFF		; Cursor off	CALL	ENDOKI		; Enable video and keybd RAM	CALL	GETPOS		; Calculate cursor position	LD	HL,READING	; "Reading...	CALL	DISPSTR	CALL	CASSON		; Turn on cassette	CALL	RDHEAD		; Read header	CALL	RDDAT		; Read tape data	DI			; Make sure ints are off	CALL	CASOFF		; Turn off cassette	LD	HL,WRITING	; "Writing...	CALL	DISPSTR	LD	HL,DFBUF	; HL => Destination	CALL	DISPSTR	LD	HL,(CURPOS)	; Get new cursor position	CALL	GETCRS		; Convert to row,column	LD	B,03H		; Give system new cursor	@@VDCTL	CALL	DISDOKI		; Enable real RAM	JR	WRTDES2FORNOW	CALL	DISDOKI		; Enable real RAM	CALL	CASOFF		; Turn off cassetteWRTDES2	CALL	WRTDEST		; Write destination file	JP	EXIT;;	Error handling routine;IOERR	LD	L,A		; Transfer error # to HL	LD	H,00H	OR	0C0H		; Short msg, return	LD	C,A	@@ERROR			; Display error	JR	OLDSP		;   and abort;ILLEGAL	JP	ABORT		; For now;ABORT	LD	HL,-1		; Show error return	DB	0DDH		; Skip LD HL,0EXIT	LD	HL,0		; Clean exitOLDSP	LD	SP,0		; Get original stack	EI			; Make sure interrupts are on	@@CKBRKC		; Clear any BREAK	RET;DLEN	DB	00H,00H,00H;CURPOS	DW	0		; Cursor position;;;READERR	DB	0AH,'Tape Read Error  ',0DHREADING	DB	'Reading: ',03HWRITING	DB	0AH,'Writing: ',03HFILENM	DB	'FILENM',0DHBUFFER	DS	6DFBUF	DB	'Filename/ext:d',03H;;;	GTFILE - Stuff filename from FCB into buffer;	DE => FCB with filename contained;GTFILE	LD	HL,FILENM	; HL => Filename buffered	PUSH	HL		; Save it	LD	B,06H		; Init to all spacesCLEAN	LD	(HL),' '	INC	HL	DJNZ	CLEAN	POP	HL		; Get dest back	LD	B,06H		; Only accept first 6;GETFILN	LD	A,(DE)		; Get character	CP	CR+1		; End?	RET	C		; Yes - done	CP	'.'		; Start of password?	RET	Z		; Yes - done	LD	(HL),A		; Stuff into filename buffer	INC	HL		; Bump both pointers	INC	DE	DJNZ	GETFILN		; Loop	RET;;	DOINIT - Do initialization of TAPE100;DOINIT	@@FLAGS			; IY => System flag table;;	Calculate highest mem address of buffer;	PUSH	HL		; Save command line pointer	LD	HL,0		; Get HIGH$	LD	B,L	BIT	1,(IY+CFLAG$)	; @CMNDR?	JR	Z,USEHI	INC	B		; Use LOW$USEHI	@@HIGH$	INC	HL		; Set hi-mem byte	DEC	H		; Give some leeway	DEC	H	LD	A,H		; Stuff into r/w routines	LD	(ENUF+1),A;;	Display log-on message;	LD	HL,HELLO$	; Display banner	CALL	DSPLY	POP	HL		; Process parameters;;	Get READ or WRITE parameter if entered;	PUSH	HL		; Save cmd line	DEC	HL		; Back up one spaceCKPLP	INC	HL		; Bump pointer	LD	A,(HL)		; Get character	CP	CR+1		; End of line?	JR	C,DUNLIN	; Yes - done	CP	'('		; Start of params?	JR	NZ,CKPLP	; No - loop for more;;	Process parameters entered on cmd line;	LD	DE,PARMTBL	@@PARAM	JP	NZ,PRMERR	; Quit on param errorDUNLIN	POP	HL		; Recover cmd line ptr;;	If C=N entered then use checksum;CPARM	LD	BC,0FFFFH	; Default no checksum	INC	B		; User requesting checksum?	RET	NZ		; Yes - return	LD	A,0C9H		; Load opcode for RET	LD	(CHKERR+1),A	; Stuff in checksum error	RET;;	PRSOUR/PRDEST - Prompt for source or destination;PRSOUR	PUSH	HL		; Save HL	LD	HL,DSF		; "Disk source filename	LD	B,23		; 23 chars maximum	JR	DOINPUTPRDEST	PUSH	HL		; Save HL	LD	HL,TDF		; "Tape dest filename	LD	B,06H		; 6 chars maxDOINPUT	CALL	DSPLY		; Display the prompt	PUSH	HL		; Save prompt start	CALL	INPUT		; Get user input	@@FSPEC			; Legal filespec?	POP	HL		; Get prompt string back	JR	NZ,DOINPUT	; Reprompt if bad name	POP	HL		; Recover pointer	RET			;   and return;;	PRSOUR2/PRDEST2 - Prompt for READ source/dest;PRSOUR2	PUSH	HL		; Save HL	LD	HL,TSF		; "Tape source filename	LD	B,06H		; 6 chars max	JR	DOINPUTPRDEST2	PUSH	HL		; Save HL	LD	HL,DDF		; "Disk dest filename	LD	B,23		; 23 chars max	JR	DOINPUT;;	INPUT - Line input routine;INPUT	PUSH	DE		; Save DE and BC	PUSH	BC	LD	HL,INBUFF	; HL => Input buffer	@@KEYIN			; Get user input	JP	C,ABORT		; Quit on BREAK key	POP	BC		; Restore registers	POP	DE	RET;DSP	PUSH	DE		; Save DE	@@DSP			; Display char	JR	EXDSP;DSPLY	PUSH	DE		; Save DE	@@DSPLY			; Display stringEXDSP	POP	DE		; Recover DE	RET	Z		; Return if okay	JP	IOERR		;    else abort;COUNT	DB	00H;;	Messages;HELLO$	DB	1CH,1FH,'TAPE100'*GET	CLIENT;RDORWR	DB	'<R>ead or <W>rite ? ',0EH,03HTSF	DB	'Tape Source Filespec ? ',0EH,03HDSF	DB	'Disk Source Filespec ? ',0EH,03HTDF	DB	'Tape Destination Filespec ? ',0EH,03HDDF	DB	'Disk Destination Filespec ? ',0EH,03HTREADY	DB	'Ready Cassette & Press <ENTER>',0EH,03HPRMERR$	DB	'Parameter error',0AH,0DHTOOBIG$	DB	'File too large to fit in available memory',0AH,0DH;;	Error exit routine;PRMERR	LD	HL,PRMERR$	; "Param err..."	DB	0DDHTOOBIG	LD	HL,TOOBIG$	; "Too big...;	@@LOGOT			; Display the error	JP	ABORT		; Goodbye;;	Parameter table;PARMTBL	DB	80H		; Version 6.x @PARAM;	DB	FLAG!ABB!5	DB	'WRITE'WRESP	DB	00H	DW	WPARM;	DB	FLAG!ABB!4	DB	'READ'RRESP	DB	00H	DW	RPARM;	DB	FLAG!ABB!4	DB	'CHECK'	DB	00H	DW	CPARM+1	DB	00H;RPARM	DW	0WPARM	DW	0;;;	DC	50,0		; Patch space;;	Tape I/O Routines;;	CASSON - Turn cassette motor on;CASSON	DI			; Disable interrupts	CALL	SWAP38		; Grab RST 38H vector	IN	A,(PORTE0)	; Clear any latches	IN	A,(MODOUT)	; Clear any latches	LD	A,02H		; Motor on, slow speed	OUT	(MODOUT),A	; Turn on motor	LD	A,03H		; Disable other interrupts	OUT	(PORTE0),A	RET;;	CASSOFF - Turn off cassette motor;CASOFF	LD	A,(IY+WRMASK)	; Get original	OUT	(PORTE0),A	; Set up R/F interrupt	IN	A,(PORTFF)	; Clear 1500 baud interrupts	LD	A,(IY+MODMASK)	; Turn off motor	OUT	(MODOUT),A	CALL	SWAP38		; Restore RST 38H vector	RET;;	PRTAPE - Prompt for "tape ready" and turn motor on;PRTAPE	LD	HL,TREADY	; "Ready cassette...	CALL	DSPLYNOTENT	LD	B,01H		; Just one character	CALL	INPUT		; <BREAK> or <ENTER>	JP	CURSOFF		; Turn off cursor and return;;	RDDAT - Read in a tape data file;RDDAT	LD	HL,MEM-100H	; HL => start of fileRDDAT2	INC	H		; Bump high byte	CALL	RDDATA		; Read a block	RET	Z		; EOF?EOTF	LD	A,00H		; At top of memory?	CP	H	JR	NZ,RDDAT2	; Lo - loop	OR	A		; Top of memory	RET			; Return NZ;;	RDDATA - REad in a block of data;	HL => Destination of block;RDDATA	CALL	RDSYNC		; Read sync field	CALL	RDBYTE		; Read a byte	CP	8DH		; Legal?	JP	NZ,ILLEGAL	; No - bad news	LD	DE,0		; D = EOF flag, E = checksum;RDLP1	CALL	RDBYTE		; Read a byte	LD	(HL),A		; Stuff into buffer;;	Check for end of file byte x'1A';	CP	1AH		; End of file?	JR	NZ,AFTER	; No	CP	D		; Been here before?	JR	Z,AFTER		; First time?	LD	D,A		; Set D = 1AH	LD	B,L		; Yes - set B = pos;;	Add byte to checksum;AFTER	ADD	A,E		; Add checksum	LD	E,A		; Transfer back to E	INC	L		; Bump	JR	NZ,RDLP1	NEG			; Negate checksum	LD	E,A		; Stuff back in E;;	Verify checksum byte;	CALL	RDBYTE		; Read in byte	CP	E		; Checksums match?	CALL	NZ,CHKERR	; No - checksum error;;	Stuff EOF offset byte into WRTDEST routine;	LD	A,H		; Get EOM	LD	(EOTF2+1),A	; Stuff into WRTDEST	LD	A,B		; Get byte	INC	A		; Bump it	LD	(OFFSET+1),A;;	Read past 20 dummy zeros;	LD	B,20RDLP2	CALL	RDBYTE	DJNZ	RDLP2;;	Set Z flag if at EOF;	LD	A,D		; EOF?	CP	1AH	RET			; Done;;	RDBIT - Read a bit from the cassette;RDBIT	LD	C,00H		; Init count = 0	EI			; Interrupts back onRBLP	INC	C		; Bump count	LD	A,(BREAKLC)	; BREAK hit?	AND	04H	JR	Z,RBLP		; No - wait for interrupt;;	<BREAK> key hit - abort;	DI			; Cancel next interrupt	CALL	DISDOKI		; Put *DO and *KI back	CALL	CASOFF		; Turn off cassette	LD	C,0DH		; End line	CALL	DSP	JP	ABORT		; Go to abort routine;;	Interrupt handler - comes from RST 38H;RST38V	JP	$+3		; Wait	PUSH	AF		; Save status	IN	A,(PORTE0)	; Read port	RRA			; Bit 0 low?	JP	NC,BIT0LOW	RRA			; Bit 1 low?	JP	NC,BIT1LOW	POP	AF		; Recover status	EI			; Interrupts back on	RET			;   and return;;	Set E = bit image - Bit 0 or 1;BIT0LOW	LD	E,01H		; High	JR	BIT1LOW+2	; Add interrupt offsetBIT1LOW	LD	E,00H		; Low	LD	A,ROUTOFF	; Add interrupt routine	ADD	A,C		;   offset to C	LD	C,A;;	Is the head on a valid pulse;	IN	A,(PORTFF)	; Read cassette level	AND	01H		; Mask off all but bit 0	CP	E		; Same as given level?	JR	NZ,WAITINT	; No - wait for next interrupt;;	Valid pulse - Get out of interrupt routine;	POP	AF		; Remove RST 38H RET addr	POP	AF	RET;;	Not the right interrupt - wait for next one;WAITINT	POP	AF		; Recover status	EI			;   and wait for next	RET			;   interrupt;;	RDHEAD - Read a TAPE100 header;RDHEAD	LD	HL,(CURPOS)	; Get cursor position	LD	DE,BUFFER	; DE => buffer	CALL	RDSYNC		; Read in SYNC;;	Read in header type byte;	CALL	RDBYTE		; Read type byte	CP	9CH		; Text type?	JR	NZ,RDHEAD	; No - try again;	LD	BC,600H		; B = 6 bytes, checksum = 0;RFNLP	CALL	RDBYTEC		; Read byte	LD	(HL),A		; Save byte	LD	(DE),A		; Stuff in buffer	INC	HL		; Bump cursor position	INC	DE		; Bump buffer pointer	DJNZ	RFNLP;;	Next ten bytes are unused;	LD	B,0AHBOGUSLP	CALL	RDBYTEC		; Read byte and checksum	DJNZ	BOGUSLP;;	Negate checksum;	LD	A,C		; Get checksum	NEG			; Negate it	LD	C,A	CALL	RDBYTE		; Read in checksum byte	CP	C		; Do they match?	CALL	NZ,CHKERR	; No - checksum error;;	Read in twenty zeros;	LD	B,20DUMBYT	CALL	RDBYTE	DJNZ	DUMBYT;;	Check if this is the correct filename;CORRECT	NOP			; RET if first filename okay	LD	DE,BUFFER	; Is this the one to use?	LD	HL,FILENM	LD	B,06H		; 6 char in name;;	Loop to compare (HL) to (DE);CKFILE	LD	A,(DE)		; Get header byte	CALL	CONV_UC		; Convert to upper case	CP	(HL)		; Do they match?	INC	HL		; Bump pointers	INC	DE	JP	NZ,RDHEAD	; No - try again	DJNZ	CKFILE	RET			; Yes - return;;	Checksum error - Either ignore it or "C";CHKERR	NOP			; Return or NOP	DI			; Disable interrupts	LD	A,'C'		; <C>hecksum errorCHKERR2	LD	(VIDEO+79),A	CALL	DISDOKI		; Bring back RAM	CALL	CASOFF		; Turn off cassette	LD	HL,READERR	; "Tape read error...	CALL	DSPLY	JP	ABORT		; Bye-bye;;	RDSYNC - Read cassette SYNC  byte field;RDSYNC	PUSH	HL		; Save registers	PUSH	DE	PUSH	BC	LD	A,01H		; Set interrupt vector	OUT	(PORTE0),A;;	Read in 128 bits (16 bytes) initially;RDSYNC2	LD	B,80H		; Read 128 bitsRBTLP	CALL	RDBIT		; Read a bit	LD	A,C		; Get count value	CP	TOOSHRT		; Is this a bit?	JR	C,RDSYNC2	; No - didn't find a bit	CP	TOOLONG		; Is this a bit?	JR	NC,RDSYNC2	; No - wait for a bit	DJNZ	RBTLP		; Legal bit - dec count;;	Now check parity of next 128 bits;RESCNT	LD	HL,0		; H = 0s count, L = 1s count	LD	B,40H;;	Read in 3 bits;LOOP	CALL	RDBIT		; Read bit	CALL	RDBIT		; Read bit	LD	D,C		; Save count	CALL	RDBIT		; Read bit;;	Calculate difference between last 2 bits;	LD	A,D		; Get last bit	SUB	C		; Subtract current bit	JR	NC,ABSVAL	NEG			; Change to abs value;;	If value < DIFFER then Bit = 1, else Bit = 0;ABSVAL	CP	DIFFER		; Bit = 1?	JR	C,BIT1		; Yes - bump bit 1 count	INC	H		; No - bump bit 0 count	JR	DODJ		; Back to loopBIT1	INC	L		; Bump bit 1 countDODJ	DJNZ	LOOP		; Dec count, go to loop;;	Check if H (0 count) and L (1 count) = 40;	LD	A,40H		; Is H = 64?	CP	H	JR	Z,CHKMARK	; Yes - check for marker	CP	L		; Is L = 64?	JR	NZ,RESCNT	; No - reset count;;	Set interrupt vector and discard one bit;	LD	A,02H		; Set interrupt vector	OUT	(PORTE0),A	CALL	RDBIT		; Read a bit;;	Rotate each bit read in D and check if = X'7F';CHKMARK	LD	D,00H		; Set byte = 0GETBIT	CALL	RDBIT		; Read next bit	CALL	ROTBYTE		; Rotate into byte (D)	LD	A,D		; Get byte	CP	7FH		; Marker byte?	JR	NZ,GETBIT	; No - get another bit;;	Found marker byte - restore registers and return;	POP	BC	POP	DE	POP	HL	RET;;	ROTBYTE - Rotate bit through D and check if error;ROTBYTE	LD	A,C		; Get count	CP	WHICH1		; Git = 0 or 1?	RL	D		; Set bit if carry set	CP	TOOSHRT		; Too quick?	JP	C,CIOERR	; Yes - I/O error	CP	TOOLONG		; Too long?	RET	C		; No - return;;	Cassette I/O error - display error message;CIOERR	DI			; Interrupts off	LD	A,'D'		; Data error	JP	CHKERR2;;	RDBYTEC - Read byte and add byte to check sum;RDBYTEC	CALL	RDBYTE		; Read the byte	ADD	A,C		; Add to checksum	RET;;	RDBYTE - Read a byte into the A register;RDBYTE:	PUSH	DE		; Save registers	PUSH	BC	CALL	RDBIT		; Get bogus bit	LD	D,00H		; Init byte = 0	LD	B,08H		; 8 bits to read;RDBLP	CALL	RDBIT		; Read a bit	CALL	ROTBYTE		; Rotate into D	DJNZ	RDBLP;;	Add to byte count;	LD	A,(COUNT)	; Get count	INC	A		; Increment it	AND	3FH		; Check if the 64th	LD	(COUNT),A	; Save the count	JR	NZ,NOTBLNK;	LD	A,(VIDEO+79)	; Blink every 64 chars	XOR	0AH	LD	(VIDEO+79),A;NOTBLNK	LD	A,D		; Transfer byte to A	JR	NEXTINS		; Timing;NEXTINS	POP	BC		; Restore BC and DE	POP	DE	RET			; Done;;	WRBIT - Write a bit to cassette;;	Set DE = delay count for a bit;WRBIT	RLC	C		; Get bit	JR	NC,NOPULS	; NC - bit 0	LD	DE,DELAY1	; Delay for bit 1	JR	DEL_LP		; Go to delayNOPULS	LD	DE,DELAY0	; Delay for bit 0;;	Delay 18 counts for 1, 43 counts for 0;DEL_LP	DEC	D		; Dec count	JR	NZ,DEL_LP	LD	A,02H		; 0 volts to tape	OUT	(PORTFF),ADEL_LP2	DEC	E		; Secondary delay	JR	NZ,DEL_LP2	LD	A,01H		; 0.85 volts to tape	OUT	(PORTFF),A	RET			; Done;;	WRHEAD - write a cassette header;WRHEAD	CALL	WRSYNC		; Write sync pattern;;	Write text header type byte X'9C';	LD	D,00H		; Init checksum to 0	LD	C,9CH		; Text header type byte	CALL	WRBYTE		; Write tape byte;;	Write filename in header block;	LD	B,06H		; 6 chars in name	LD	HL,FILENM	; Point to filenameFILELP	LD	C,(HL)		; Get filename character	CALL	WRBYTEC		; Write it	INC	HL		; Bump count	DJNZ	FILELP;;	Write ten filler bytes;	LD	B,0AHBOGUS	CALL	WRBYTEC	DJNZ	BOGUS;;	Write checksum byte & 20 dymmy 0 bytes;	LD	A,D		; Get checksum	NEG	LD	C,A		; Transfer to C	CALL	WRBYTE		; Write checksum byte	LD	BC,20<8+0	; B = 20 bytes, C = 0DUMMY	CALL	WRBYTE	DJNZ	DUMMY	RET;;	WRDAT - Write a chunk of data to cassette;WRDAT	LD	HL,MEM		; HL => Mem startWRDAT2	CALL	WRDATA		; Write block	INC	H	LD	A,(FCB1+4)	; Finished?	CP	H	JR	NZ,WRDAT2	; No - write another	RET;;	WRDATA - Write a data block;	HL => 256 byte block of data (on page boundary);WRDATA	CALL	WRSYNC		; Write sync pattern	LD	C,8DH		; Write x'8D' byte	CALL	WRBYTE;;	Write 256 byte block of data;	XOR	A		; Set checksum to 0WBLP	LD	C,(HL)		; Get byte	ADD	A,C		; Add checksum	PUSH	AF		; Save A	CALL	WRBYTE		; Write byte	POP	AF		; Recover checksum	INC	L		; Bump count	JR	NZ,WBLP		; Loop until block done;;	Write checksum byte;	NEG			; Negate checksum	LD	C,A		; Write it	CALL	WRBYTE;;	Write 20 dummy bytes of 0;	LD	B,20WDLP	LD	C,00H	CALL	WRBYTE	DJNZ	WDLP	RET;;	WRBYTEC - Write a byte and add to checksum;WRBYTEC	CALL	WRBYTE		; Write byte	LD	A,C		; Get byte in A	ADD	A,D		; Add to checksum	LD	D,A		; Store back in D	RET;;	WRBYTE - Write byte in C register to cassette;WRBYTE:	PUSH	BC		; Save registers	PUSH	DE	CALL	NOPULS		; Write dummy pulse	LD	B,08H		; 8 bits to writeWRBTLP	CALL	WRBIT		; Write a bit	DJNZ	WRBTLP		; Loop for all 8 bits	POP	DE		; Restore registers	POP	BC	RET;;	WRSYNC - Write a SYNC pattern to cassette;WRSYNC	DI			; Disable interrupts	PUSH	BC		; Save BC	LD	B,80H		; Delay count	@@PAUSE	LD	BC,0055H	; B = 256, C = x'55';;	Write sync bytes - x'55';WR55LP	CALL	WRBYTE8		; Write 8 bit byte	DJNZ	WR55LP;;	Write marker byte - x'7F';	LD	C,7FH	CALL	WRBYTE8	POP	BC	RET;WRBYTE8	PUSH	BC		; Save B	LD	B,08H		; 8 bits longWB8LP	CALL	WRBIT		; Write a bit	DJNZ	WB8LP	POP	BC	RET;;	Disk I/O and other routines;;	DISPSTR - Display a string;DISPSTR	PUSH	DE		; Save DE	LD	DE,(CURPOS)	; Get cursor positionDSLP	LD	A,(HL)		; Get source character	CP	03H		; done?	JR	Z,EXIT1		; Yes - exit	CP	0DH		; Done?	JR	Z,EXIT2	CP	0AH		; Linefeed?	JR	NZ,STUFCHR	; No - put the char on screen	CALL	NEXTLIN		; Get next line	JR	BUMPITSTUFCHR	LD	(DE),A		; Output to video	INC	DEBUMPIT	INC	HL		; Bump count	JR	DSLPEXIT2	CALL	NEXTLIN		; Next line downEXIT1	LD	(CURPOS),DE	; Save cursor position	POP	DE		; Restore DE	RET;;	NEXTLIN - Position to next line on video;	DE => RAM location;NEXTLIN	PUSH	HL		; Save regs	EX	DE,HL		; Transfer position to HL	CALL	GETCRS		; Calculate X,Y position	INC	H		; Increment row number	LD	L,00H		; Set column to 0	CALL	GETPOS2		; Convert back to RAM location	EX	DE,HL		; Put it back into DE	POP	HL		; Get HL back	RET;;	CONV_UC - Convert A register to upper case;CONV_UC	CP	'a'		; Lower case?	RET	C		; no	CP	'z'+1		; Lower case?	RET	NC		; no	RES	5,A		; Force to upper	RET;;	CURSOFF - Turn off the cursor;CURSOFF	PUSH	AF		; Save registers	PUSH	DE	PUSH	BC	LD	C,CUROFF	; Cursor off char	@@DSP	JP	NZ,IOERR	POP	BC		; Restore registers	POP	DE	POP	AF	RET;;	INIT - Init a file;INIT	LD	A,@INIT		; Get SVC # in A	JR	DOSVC;;	OPEN - Open source file;OPEN	SET	0,(IY+SFLAG$)	; Inhibit file-open bit	LD	A,@OPEN		; Open file SVC #;DOSVC	PUSH	AF	PUSH	DE	LD	HL,DFBUF	; HL => Disk filename bufferTLP	LD	A,(DE)		; Get byte from FCB	LD	(HL),A		; Transfer to temp buffer	INC	HL	INC	DE	CP	CR+1		; Done?	JR	C,DUN	CP	':'	JR	Z,DUN	CP	'.'	JR	NZ,TLP;;	Found valid terminator - is this a device?;DUN	DEC	HL		; back up to terminator	POP	DE		; DE => FCB+0	LD	A,(DE)		; Device?	CP	'*'	JR	Z,DUN2		; Yes - done	LD	(HL),':'	; No - overwrite with ":"	INC	HL	LD	(DSPEC+1),HL	; Save drivespec location	INC	HLDUN2	LD	(HL),03H	; Stuff an ETX at end	POP	AF		; A = SVC #	LD	(SVCNUM+1),A	; Save SVC number	LD	HL,IOBUFF	; HL => I/O buffer	LD	B,00H		; LRL = 256	RST	28H		; Open or init the fileCKECK	JR	Z,CHKPROT;;	Ignore error #42 - LRL open fault;	CP	42		; Ignore this error	RET	NZ		; Return NZ if any other;;	Stuff drive number into buffer;CHKPROT	PUSH	DE		; Get drivespec	POP	IX		; from FCB+6	LD	A,(IX+06H)	ADD	A,'0'		; Convert it to ASCIIDSPEC	LD	(0),A;;	Check if file has proper access rights;	BIT	7,(IX+00H)	; Is FCB open?	JR	Z,ILLFILE	; No - illegal filename	LD	A,(IX+01H)	; Get protection byte	AND	07H	LD	B,A		; Transfer to B;SVCNUM	LD	A,00H		; Get SVC #	CP	@INIT		; Was it INIT?	LD	A,B		; Get protection level	JR	Z,INIT1		; Z - must be < 5	CP	06H		; Read access?	JR	C,OKYDOKY	; Yes - set Z flag and return;;	Illegal access to protected file;ILLACC	@@CLOSE			; Close the file	LD	A,19H		; File access denied	JP	IOERR		; Error - regardless;INIT1	CP	05H		; Update access?	JR	NC,ILLACC	; No - illegal access;OKYDOKY	XOR	A		; Return Z	RET;ILLFILE	LD	A,19		; Illegal filename	OR	A	RET;;	CLOSE - Close the destination file;CLOSE	LD	DE,FCB2		; DE => FCB	@@CLOSE			; Close the file	RET	Z		; Return if good	JP	IOERR;;	WRITESC - Write a sector to destination file;WRITESC	LD	DE,FCB2		; Point to FCB	@@WRITE			; Write the sector	JP	NZ,IOERR	; Quit if write error	RET;;	WRTDEST - Write destination file;WRTDEST	LD	DE,FCB2		; DE => Destination FCBWRTDES	LD	HL,FCB2+4	; HL => MSB of I/O buffer	INC	(HL)		; Bump	CALL	WRITESC		; Write sectorEOTF2	LD	A,00H		; Get # of sectors	CP	(HL)		; Finished?	JR	NZ,WRTDES	; Loop until we are;;	Finished writing - set EOF offset byte;OFFSET	LD	A,00H		; Pick up offset byte	LD	(FCB2+8),A	;   and stuff in FCB	CALL	CLOSE		; Close the file	RET;;	READSRC - Read in chunk of source disk file;READSRC	LD	HL,FCB1+4	; HL => Hi byte of I/O buffer	LD	(HL),MEM<-8-1	; Init FCB I/O buffer;;	Read in source file;READSR2	LD	DE,FCB1		; Point to the FCB	INC	(HL)		; Bump I/O buffer	@@READ			; Read a sector	JR	Z,READSR2;;	Fill remainder of sector with x'1A' bytes;	PUSH	AF		; Save error codeNOMORE	LD	A,(FCB1+8)	; Get EOF offset byte	NEG	LD	B,A		; Transfer to B for DJNZ	LD	H,(HL)		; Get I/O buffer MSB	LD	L,0FFH		; End of sector	JR	Z,NULBUF	; Z - keep HL here	DEC	H		; Sector boundaryNULBUF	LD	(HL),1AH	; Fill remainder of buffer	DEC	HL		;   with zeros	DJNZ	NULBUF;;	Add a sector of x'1A' bytes;	INC	H		; Point to next sector	LD	L,00HXTR1AS	LD	(HL),1AH	; EOF indicator	INC	HL		; Bump	DJNZ	XTR1ASDONTFIL	POP	AF		; Recover error code;;	I/O error - better be EOF error;	CP	1CH		; EOF?	RET	Z		; That's fine	CP	1DH		; NRN > ERN?	RET	Z		; That's fine, too	JP	IOERR		; Any other is error;;	ENDOKI - Enable video and keyboard;ENDOKI	PUSH	AF	PUSH	HL	LD	A,(OPREG$)	; Get current port mask	LD	(SVOPREG+1),A	; Save it for DISDOKI	RES	0,A		; Reset bit 0	SET	1,A		; Set bit 1	JR	DOOPREG		; Set new assignment;;	DISDOKI - Disable video and keyboard;DISDOKI	PUSH	AF	PUSH	HLSVOPREG	LD	A,00H		; Restore original maslDOOPREG	LD	(OPREG$),A	OUT	(@OPREG),A	;   and disable video	POP	HL	POP	AF	RET;;	SWAP38 - Swap 38H through 3AH with save area;SWAP38	LD	B,03H		; 3 bytes to exchange	LD	HL,SWAREA	; HL => Swap area	LD	DE,0038H	; DE => RST 38 addressSWAPLP	LD	C,(HL)		; Get source	LD	A,(DE)	EX	DE,HL		; Swap pointers	LD	(HL),C		; Stuff in destination	LD	(DE),A	INC	HL		; Bump pointers	INC	DE	DJNZ	SWAPLP		; Do three bytes	RET;SWAREA	JP	RST38V		; JP vector;;	GETPOS - Get current cursor position in video;GETPOS	LD	B,04H	@@VDCTLGETPOS2	LD	C,L		; Save column #	LD	L,H	LD	H,00H		; HL => Row #	LD	D,H		; Set DE = HL	LD	E,L	ADD	HL,HL		; Times 2	ADD	HL,HL		; Times 4	ADD	HL,DE		; Times 5	ADD	HL,HL		; Times 10	ADD	HL,HL		; Times 20	ADD	HL,HL		; Times 40	ADD	HL,HL		; Times 80	LD	B,VIDEO<-8	; D = high byte of video	ADD	HL,BC		; HL -> Cursor location	LD	(CURPOS),HL	; Save cursor position	RET;;	GETCRS - Calculate row x column cursor position;	HL => Cursor position in RAM;	HL <= Cursor position in Row (H) Column (L);GETCRS	LD	DE,VIDEO	; Get offset	OR	A	SBC	HL,DE	LD	C,80		; Calculate row #	@@DIV16	LD	H,L		; Set H = row	LD	L,A		; Set L = column	RET;FCB1	DS	32	;EQU	2DF1HFCB2	DS	32	;EQU	2E11HINBUFF	DS	25	;EQU	2E31H;	ORG	$<-8+1<+8;IOBUFF	DS	256	;EQU	2F00HMEM	EQU	$	;EQU	3000H;	END	START