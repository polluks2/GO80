; LBATTR/ASM - ATTRIB command	TITLE	<ATTRIB - LSDOS 6.3>;CR	 EQU	13BLNKMPW	 EQU	4296HPASSWORD EQU	42E0H;*GET	SVCMAC			; SVC macro equivalents;	ORG	2400H;ATTRIB	LD	(SAVESP+1),SP	; Save stack pointer	CALL	ATTRIB1		; Call attrib code	LD	HL,0		; Set no error	JR	SAVESP		; Get stack and return;;	I/O Error handling;IOERR	CP	63		; Extended error?	JR	Z,EXTERR	LD	L,A		; Error # to HL	LD	H,00H	OR	0C0H		; Abbrev & return	LD	C,A	@@ERROR	JR	SAVESP;;	Internal error message handling;ABORT	LD	HL,ABORT$	; Command aborted	DB	0DDHSPCREQ	LD	HL,SPCREQ$	; File spec required	DB	0DDHNOTDUN	LD	HL,NOTDUN$	; Specifications required	DB	0DDHATBERR	LD	HL,ATBERR$	; Attr specification errorEXTERR	@@LOGOT			; Log the error	LD	HL,-1		; Set abort errorSAVESP	LD	SP,$-$		; Reload stack pointer	@@CKBRKC		; Clean up <BREAK>	RET;;	ATTRIB1 - Set attributes of file/disk;ATTRIB1	LD	DE,FCB		; Check filespec or drive #	@@FSPEC	JP	NZ,PROT		; Assume drive # if error	LD	A,(DE)		; Cannot be a device	CP	'*'	JP	Z,SPCREQ	@@FLAGS			; Get flag table pointer	PUSH	HL		; Save cmd line pointer	LD	HL,BUFFER	; Use local buffer	LD	B,L		; Open the file	SET	0,(IY+'S'-'A')	; Don't set file open bit	@@OPEN	POP	HL		; Get cmd line back	JP	NZ,IOERR	; jump if non-existant	LD	A,(FCB+1)	; Get protection	AND	07H		; Mask off other bits	LD	A,25H		; Init for access denied	JP	NZ,IOERR	; Jump if no can do	XOR	A	LD	(PRMCOD+1),A	; Init prot to 0;;	Convert command line to upper case;	PUSH	HL		; Save cmd line ptrATT0	LD	A,(HL)		; convert lc to uc	CP	CR	JR	Z,ATT02		; Done if CR	CP	03H	JR	Z,ATT02		; Done if ETX	CP	'a'		; Not lc?	JR	C,ATT01	CP	'z'+1	JR	NC,ATT01	RES	5,(HL)ATT01	INC	HL		; Bump to next char	JR	ATT0		; Loop;ATT02	POP	HL		; Recover orig cmd line ptr;;	Scan command line for parameters;ATT1	LD	A,(HL)		; Scan for start of param	CP	'('		; There yet?	JR	Z,ATT2		; Jump if so	CP	' '		; Ignore spaces	JR	NZ,ATT3		; Assume parm if dif char	INC	HL	JR	ATT1ATT2	INC	HL		; Bump past '('	LD	A,(HL)ATT3	CP	'I'		; Check for INV	JR	Z,DOINV	CP	'V'		; Check for VIS	JR	Z,DOVIS	CP	'O'		; Check for OWNER	JP	Z,DOOWN	CP	'P'		; Check for PROT	JP	NZ,ATBERR	; Err if none of above;;	Process PROT=parm;	CALL	PRSFLD		; Parse field	JP	Z,ATBERR	; Error if end of line	PUSH	HL		; Save ptr to next char	LD	B,08H		; Init for 8 prots	LD	DE,(PSWDBUF)	; Get 1st 2 chars	LD	HL,PROTS$	; Point to various protsDOPR01	LD	A,(HL)		; Get 1st prot char	INC	HL		; Bump pointer	CP	E		; Does 1st match?	CALL	Z,DOPR02	; Check 2nd if so	INC	HL		; Point to next	DJNZ	DOPR01		; Loop until all 8	POP	HL		; Stack integrity	JP	ATBERR		; Abort if no match;;	Check 2nd prot = char for match;DOPR02	LD	A,(HL)		; Get 2nd table char	CP	D		; Match user's entry?	RET	NZ		; Go back if not	POP	AF		; Pop return addr	LD	A,B		; Calc which prot was	DEC	A		;   entered by the user	JR	Z,DOPR03	; Jump on PROT=FU	CP	05H		; REname, REad, REmove?	JR	NZ,DOPR03	; Go if none of above	LD	A,(PSWDBUF+2)	; Get user's 3rd char	CP	'N'		; Was it 'N'?	LD	A,02H		; Init for REName	JR	Z,DOPR03	; Go if REName	DEC	A		; else init to REMove	CP	'M'		; Was it REMove?	JR	Z,DOPR03	LD	A,05H		; Else assume REAdDOPR03	LD	(PROTLVL+1),A	; Stuff protection level	POP	HL		; Recover INBUF$ pointer	LD	B,01H		; Init to show prot givenDOPR04	LD	A,(HL)		; Get next parm	CP	'"'		; Closing quote on last?	JR	NZ,DOPR05	; Go if something else	INC	HL		; Ignore closing quoteDOPR05	LD	A,(PRMCOD+1)	; Get param test bits	OR	B		; Merge PROT entered	LD	(PRMCOD+1),A	; Restuff param test bits	LD	A,(HL)		; Get next char	CP	CR		; End of line?	JR	Z,$+4		; Go on end of line	CP	')'		; End of params?	JP	Z,UPDDIR	CP	','		; More params?	JR	Z,ATT2		; Loop on more params	JP	ATBERR		; Exit on wrong char;;	Process INV parm;DOINV	CALL	PRSFLD		; Parse param	JP	NZ,ATBERR	; Go on param err	LD	A,(IVCOD+1)	; Set bit 3 to indicate	OR	08H		;   that INV given	LD	(IVCOD+1),A	LD	B,08H		; Show vis/inv done	JR	DOPR05		; Merge w/prev. params;;	Process VIS parm;DOVIS	CALL	PRSFLD		; Parse param	JP	NZ,ATBERR	; Quit on param error	LD	A,(IVCOD+1)	; Strip bit 3	AND	0F7H	LD	(IVCOD+1),A	LD	B,08H		; Show vis/inv done	JR	DOPR05		; Merge w/prev. params;; --------------------------------------------------------;;	This whole section not used in ver 6.3 because of;	the new date/timestamp fields that took over the;	USER password area in the directory record;;;	Process USER param;;	CALL	PRSFIELD	; Parse param;	JP	Z,ATBERR	; Quit on param err;	PUSH	HL		; Save cmdline ptr;	LD	DE,PSWDBUF;	CALL	DOHASH		; Hash the password;	LD	(HASHBUF+2),HL	; Set into position;	POP	HL;	LD	B,2		; Show USER done;	JR	DOPR04		; Merge w/prev. params;; --------------------------------------------------------;;	Process OWNER param;DOOWN	CALL	PRSFLD		; Parse param	JP	Z,ATBERR	; Quit on param error	PUSH	HL		; Save cmd line ptr	LD	DE,PSWDBUF	CALL	DOHASH		; Hash the password	LD	(HASHBUF),HL	; Set into position	POP	HL		; Recover cmdline ptr	LD	B,04H		; Show OWNER done	JR	DOPR04		; Merge w/prev. params;;	Transfer the field, 1st char alpha;XSPEC8A	LD	A,(HL)		; Pick up filespec char	INC	HL		;   & 1st test for A-Z	JR	XSPEC10XSPEC9	LD	A,(HL)		; Pick up filespec char	INC	HL		; Advance to next one	CP	'0'		; Check for 0-9	RET	C		; Quit if < '0'	CP	'9'+1	JR	C,XSPEC11	; Go if numericXSPEC10	CP	'A'		; Check for A-Z	RET	C	CP	'Z'+1	RET	NCXSPEC11	LD	(DE),A		; Character is valid	INC	DE		; Advance to next one	DJNZ	XSPEC9		;   and loop	LD	A,(HL)		; Get following char	INC	HL	RET			; Go home;;	Parse rest of parm (ignore until separator);PRSFLD	INC	HL	LD	A,(HL)		; Get next char	CP	CR		; Ret on end of line	RET	Z	CP	')'		; Ret on closing paren	RET	Z	CP	','		; Ret on separator	RET	Z	CP	'='		; Assignment operator?	JR	NZ,PRSFLD	; Loop if not	INC	HL	LD	A,(HL)	CP	'"'		; Is quote there?	JR	NZ,M2565	INC	HL		; Bypass the quoteM2565	LD	DE,PSWDBUF	LD	B,08H	PUSH	DE	PUSH	BC	LD	A,' '		; Space out the bufferPRSF01	LD	(DE),A	INC	DE	DJNZ	PRSF01	POP	BC	POP	DE	CALL	XSPEC8A		; Transfer the spec	DEC	HL	OR	01H		; Show got a param	RET;;	Routine updates file's directory data;UPDDIR	LD	BC,(FCB+6)	; Pick up drive and DEC	@@DIRRD			; Read its directory record	JP	NZ,IOERR	; Quit on read error	LD	A,(HL)		; Pick up attribs bytePRMCOD	LD	D,$-$		; Get param test bits	BIT	0,D		; Was PROT entered?	JR	Z,UPDIR1	; Jump if not	AND	0F8H		; Remove prot levelPROTLVL	OR	00H		; Merge new prot levelUPDIR1	BIT	3,D		; Was INV or VIS entered?	JR	Z,UPDIR2	; Bypass if not	AND	0F7H		; Remove old vis/invIVCOD	OR	00H		; Merge new VIS/INVUPDIR2	LD	(HL),A		; Update dir record	LD	A,L		; Point to owner password	ADD	A,16	LD	L,A	BIT	2,D		; Was password entered?	JR	Z,UPDIR3	; Bypass if not	LD	A,(HASHBUF)	; Move new hashed password	LD	(HL),A		; into the directory	LD	A,(HASHBUF+1)	INC	HL	LD	(HL),A; ------------------------------------------------;	Code removed by LS-DOS 6.3 date stuff; ------------------------------------------------;	DEC	HLUPDIR3	EQU	$;	INC	HL		; Bypass own pswd field;	INC	HL;	BIT	1,D		; Was USER param entered?;	JR	Z,UPDIR4	; Bypass if not;	LD	A,(HASHBUF+2)	; Xfer new hashed pswd;	LD	(HL),A		;   into the directory;	LD	A,(HASHBUF+3);	INC	HL;	LD	(HL),A; ------------------------------------------------UPDIR4	@@DIRWR			; Write dir back to disk	JP	NZ,IOERR	; Abort on write error	RET			; Done - return;;	Change attribs of entire disk;PROT	LD	C,00H		; Init for drive 0	DEC	HL		; Back up for separator	LD	A,(HL)		; Check for drive entered	CP	':'		; Colon indicator?	JR	NZ,PROT01	; Bypass if not	INC	HL		; Point to drive #;;	Is the drivespec legal?;	LD	A,(HL)		; Get drive entered	SUB	'0'		; Convert to binary	CP	08H		; Greater than 7?	LD	C,A		; Save in C	LD	A,32		; Init "Illegal drive	JP	NC,IOERR	; Go if out of range;;	Drive # is legal - check it out;	@@CKDRV			; Do a drive check	LD	A,32		; Init "Illegal drive	JP	NZ,IOERR	; Go if bad;	INC	HL		; Bump line pointerPROT01	LD	A,C		; Get drive	LD	(TSTMPW+1),A	; Save drive for later	@@GTDCT			; Get DCT into IY	LD	DE,PRMTBL$	; Get params	@@PARAM	JP	NZ,IOERR	; Go on param error	LD	A,(PPARM+1)	; Make sure a param	LD	HL,LPARM+1	;   was entered	OR	(HL)	LD	HL,UPARM+1	OR	(HL)	LD	HL,NPARM+1	OR	(HL)	JP	Z,NOTDUN	; Quit if none entered	CALL	TSTMPW		; Test master password	JP	NZ,IOERR	; Quit on errorNPARM	LD	DE,0		; Pick up name param	LD	A,D	OR	E	JR	Z,PPARM		; Jump if name not entered	LD	HL,PACKNM$	; Get name into buf1	CALL	GMPW1	JP	NZ,IOERR	; Quit on error	LD	HL,BUFFER	; HL = new name	LD	DE,GATBUF+0D0H	; Where new name goes	PUSH	DE	PUSH	HL	LD	BC,8		; Name length	LDIR			; Move new name in	POP	HL	LD	DE,2		; Track 0, Sector 2	LD	A,(TSTMPW+1)	; Get drive	LD	C,A	@@RDSEC			; Read sys info sector	POP	HL		; Get name pointer	JP	NZ,IOERR	; Quit if read error	PUSH	BC		; Save drive	LD	DE,BUFFER+10H	; Point to where name goes	LD	BC,8		; Still 8 chars	LDIR			; Move it in	POP	BC		; Recover drive	LD	DE,2		; Track 0, Sector 2	LD	HL,BUFFER	@@WRSEC			; Write new SIS	JP	NZ,IOERR	; Quit on write errorPPARM	LD	DE,0		; Was PW param entered?	LD	A,D	OR	E	JR	Z,PROT02	; Go if no PW param	LD	HL,NEWMPW$	; Buffer for new MPW	CALL	GETMPW		; Input the new one	JP	NZ,IOERR	; Quit if bad PW	LD	(GATBUF+0CEH),HL ; Stuff PWPROT02	LD	D,(IY+09H)	; Get Dir cyl to D	LD	A,(TSTMPW+1)	; Get drive	LD	C,A	CALL	GATWR		; Write GAT to disk	JP	NZ,IOERR	; Quit on write error	LD	HL,(GATBUF+0CEH)	; Get pack MPW;;	Check on Lock or Unlock;LPARM	LD	BC,0		; Lock param used?	LD	A,B	OR	C	LD	DE,BLNKMPW	; Get blank MPW for test	JR	NZ,PROT03	; Jump if LOCK enteredUPARM	LD	BC,0		; Unlock param used?	LD	A,B	OR	C	RET	Z		; Neither LOCK nor UNLOCK	EX	DE,HL		; Switch new and test MPW;;	Lock to pack MPW or unlock pswds to blanks;PROT03	LD	(REVMPW+1),HL	; Stuff new MPW	LD	(THISPW+1),DE	; Stuff test MPW	LD	A,(TSTMPW+1)	; Pick up drive	LD	C,A	LD	D,(IY+09H)	; Get dir cyl into D	LD	E,01H		; Point to HIT sector	LD	HL,HITBUF	; Point to HIT buffer	@@RDSSC			; Read it into buffer	JP	NZ,IOERR	; Quit on read errorPROT04	LD	A,(HL)		; Pick up a DEC	OR	A		; Is it used?	JR	Z,PROT09	; Loop if not used	LD	B,L		; Put DEC in reg B	PUSH	BC		;   and save on stack	LD	A,L		; Check if this DEC pts	AND	0E0H		;   to same dir sector as	LD	L,A		;   the previous DEC	XOR	BPROT05	CP	0FFH		; 1st time no DEC	JR	Z,PROT06	; Jump if the same	LD	(PROT05+1),A	; Save it for testing	@@DIRRD			; Read this dir sector	JP	NZ,IOERR	; Quit on read error	LD	A,H		; Set hi-order SBUFF$	LD	(PROT06+1),APROT06	LD	H,$-$		; Point to buf hi-order	LD	A,(HL)		; Pick up type code	AND	0F8H		; Remove protection	CP	10H		; Jump if INV,SYS,FXDE	JR	NZ,PROT08	LD	A,L		; Point to password fields	ADD	A,16	LD	L,A	PUSH	DE		; Save reg DEPROT07	PUSH	HL		; Save ptr to owner pw	LD	E,(HL)		; Get owner MPW	INC	HL	LD	D,(HL)THISPW	LD	HL,$-$		; Pick up test MPW & see	XOR	A		;   if this one matches	SBC	HL,DE	POP	HL		; Restore ptr to owner	JR	NZ,PROT07B	; Don't change if diffREVMPW	LD	DE,$-$		;   else get new MPW	LD	(HL),E		;   and insert it	INC	L	LD	(HL),D;;	code removed in LS-DOS 6.3;;	INC	L;	LD	(HL),E		; Change USER pw;	INC	L;	LD	(HL),D;PROT07B	POP	DE		; Recover reg DEPROT08	POP	BC		; Recover DEC	LD	H,HITBUF<-8	; Pt to HIT hi-order	LD	L,B		; Stuff HIT lo-orderPROT09	LD	A,L		; Point to next entry	ADD	A,32		;  for this dir sector	LD	L,A	JR	NC,PROT04	; Jump if still in same	LD	A,(PROT05+1)	; Pick up current DEC	XOR	L	JR	NZ,PROT10	; Go if different	PUSH	HL	@@DIRWR			; Write out this sector	POP	HL	JP	NZ,IOERR	; Quit on write errorPROT10	LD	A,L		; Advance to the next	INC	L		;   directory sector	CP	1FH		; At end of disk?	JR	NZ,PROT04	; Loop if not	RET			;   else return;;	Routine to test master password for match;TSTMPW	LD	C,$-$		; Init to drive requested	CALL	GATRD		; Read GAT into GATBUF	RET	NZ		; Back on error	LD	HL,(GATBUF+0CEH)	LD	DE,PASSWORD	; Password = PASSWORD?	XOR	A	SBC	HL,DE	RET	Z		; Back if PASSWORD;;	MPW is not "PASSWORD" - check entry match;MPARM	LD	DE,0		; Get MPW string addr	LD	HL,CURMPW$	; Init prompt	CALL	GETMPW		; Hash param or entry	RET	NZ		; Back on bad PW	EX	DE,HL		; Xfer hashed MPW to DE	LD	HL,(GATBUF+0CEH) ; Grab pack MPW and	XOR	A		;   check if user entered	SBC	HL,DE		;   the pack MPW	LD	HL,BADMPW$	; Init error pointer	LD	A,63		; Set extended error	RET			; With Z or NZ status;;	Enter SYS2 and hash the password;GETMPW	CALL	GMPW1		; Get MPW into buffer	JR	Z,DOHASH	CP	63		; Extended error?	RET	NZ	LD	HL,BADMPW$	; Switch error message	OR	A		;   to password error	RETDOHASH	LD	A,0E4H		; Hash password (DE) to HL	RST	28H		; Ret to what called;;	Routine places a password field into buffer;GMPW1	LD	A,D		; Test if user entered MPW	OR	E	JR	Z,GMPW3		; Prompt if not	INC	A		;   or if no operand	JR	Z,GMPW3;;	Place entered password into buffer;	LD	HL,BUFFER	; Point to buffer	PUSH	HL	LD	B,08H		; Init for 8 charsGMPW2	LD	A,(DE)		; Get a char	CP	0DH		; End of line?	JR	Z,GMPW4	CP	','		; Comma separator?	JR	Z,GMPW4	CP	'"'		; Closing quote?	JR	Z,GMPW4	INC	DE		; Bump input pointer	LD	(HL),A		; Transfer character	INC	HL		; Bump output pointer	DJNZ	GMPW2		; Loop until done	JR	CKMPW;;	MPW not entered - prompt and fetch;GMPW3	CALL	CKINDO		; Can't prompt in <DO>	RET	NZ	@@DSPLY			; Display prompt	RET	NZ	LD	BC,8<8		; Init for 8 chars max	LD	HL,BUFFER	; Point to input buffer	PUSH	HL		; Save buffer	@@KEYIN			; Get user input	JP	C,ABORT		; Quit on BREAK key	EX	DE,HL		; Start pointer to DE	LD	H,00H		; Calculate trailing	LD	L,B		;   spaces needed for MPW	ADD	HL,DE	LD	A,08H	SUB	B	JR	Z,CKMPW		; Go if all 8 chars entered	LD	B,A		; Set loop countGMPW4	LD	(HL),' '	;   and fill to end	INC	HL		;   with spaces	DJNZ	GMPW4;;	Convert (SP) through (SP)+7 to upper case;CKMPW	POP	HL		; Get buffer start	PUSH	HL	LD	B,08H		; Init to loop 8 chars	LD	A,(HL)		; Get 1st char	JR	CKMPW2		;   and check for A-ZCKMPW1	INC	HL		; Bump pointer	LD	A,(HL)		; Pick up character	CP	' '		; Got a space?	JR	Z,CKMPW7	CP	'0'		; Less than '0' is error	JR	C,INVNAM	CP	'9'+1		; 0-9 is okay after 1st char	JR	C,CKMPW3CKMPW2	CP	'A'		; Less than 'A' is error	JR	C,INVNAM	CP	'Z'+1		; A-Z is okay	JR	C,CKMPW3	CP	'a'		; Need to convert case?	JR	C,INVNAM	CP	'z'+1		; Out of range if not	JR	NC,INVNAM	RES	5,(HL)		; Force to upper caseCKMPW3	DJNZ	CKMPW1		; Loop if moreCKMPW4	POP	DE		; Point to buffer start	XOR	A		; Set Z flag	RET;CKMPW5	INC	HL	CP	(HL)		; No embedded spaces	JR	NZ,INVNAMCKMPW7	DJNZ	CKMPW5		; A space found, now	JR	CKMPW4		;   must be all spacesINVNAM	LD	HL,BADNAM$	; Point to error string	LD	A,63		; Init extended error	OR	A		; Set NZ status	POP	DE	RET;;	Read or write the granule allocation table (GAT);GATRD	DB	0F6H		; set NZ for testGATWR	XOR	A		; Set Z for test	PUSH	DE		; Save registers	PUSH	HL	PUSH	AF	PUSH	IY	@@GTDCT			; DCT to reg IY	LD	D,(IY+09H)	; Get dir track	POP	IY	LD	HL,GATBUF	; Point to buffer	LD	E,L		; Set to sector 0	POP	AF	JR	Z,GATRW1	; Go if GAT write	@@RDSSC			; Read GAT sector	LD	A,14H		; Init "Gat read error	JR	GATRW3GATRW1	@@WRSSC			; Write GAT sector	JR	NZ,GATRW2	; Skip verify if error	@@VRSEC			; Verify the writeGATRW2	CP	06H		; Error 6 expected	LD	A,15H		; Init "Gat write errorGATRW3	POP	HL	POP	DE	RET;;CKINDO	PUSH	IY		; Save IY	@@FLAGS			; Get flags in IY	BIT	5,(IY+'S'-'A')	; Check if DO in effect	POP	IY		; Restore IY	RET	Z		; Back if not in DO	LD	HL,NOINDO$	;   else set error code	LD	A,63		; Set extended error	RET			; Return with NZ;;	Messages;SPCREQ$	DB	'File spec required',CRNOTDUN$	DB	'Specifications Required',CRATBERR$	DB	'Attribute specification error',CRPROTS$	DB	'NO'	DB	'EX'	DB	'RE'	DB	'UP'	DB	'WR'	DB	'RN'	DB	'RM'	DB	'FU'NOINDO$	DB	'Invalid command during DO processing',CRPACKNM$	DB	'New disk pack name ?   ',03HNEWMPW$	DB	'New master password ?  ',03HCURMPW$	DB	'Master password ?      ',03HBADMPW$	DB	'Invalid master password',0DHBADNAM$	DB	'Invalid disk name',0DHABORT$	DB	'Command aborted',0DH;PRMTBL$	DB	80H;VAL	EQU	80HSW	EQU	40HSTR	EQU	20HSGL	EQU	10H;	DB	SW!STR!2,'PW',0	DW	PPARM+1	DB	SW!SGL!4,'LOCK',0	DW	LPARM+1	DB	SW!SGL!6,'UNLOCK',0	DW	UPARM+1	DB	SW!STR!SGL!4,'NAME',0	DW	NPARM+1	DB	SW!STR!SGL!3,'MPW',0	DW	MPARM+1	DB	00H;PSWDBUF	DS	8HASHBUF	DS	4FCB	DS	32;	ORG	$<-8+1<+8BUFFER	DS	256GATBUF	DS	256HITBUF	DS	256;	END	ATTRIB