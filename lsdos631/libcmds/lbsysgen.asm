;LBSYSGEN/ASM - SYSGEN command	TITLE	<SYSGEN - LS-DOS 6.3>;;PAR_ERR	EQU	44		; Parameter error codeETX	EQU	3		; End of textCR	EQU	13		; Carriage returnMOD3BUF	EQU	4300HRST28	EQU	28H		; RST 28 address;*GET	SVCMAC			; System SVC macros*GET	SYSRES/EQU		; SYSRES equates;;	ORG	2400H;SYSGEN	LD	(SAVESP+1),SP	; Save stack pointer	PUSH	HL		; Save command line ptr	LD	HL,SFLAG$	; Point to SFLAG$	LD	A,(HL)		; Get current SFLAG$	RES	5,(HL)		; Force JCL inactive bit	LD	(SVSFLG),A	; Save	POP	HL		; Recover cmd line ptr;	@@CKBRKC		; Clear pending break	JR	NZ,ABORT	; Abort if BREAK pressed	CALL	SYSGEN1		;   else call main code	LD	HL,0		; Init no errorSAVESP	LD	SP,0		; Recover stack ptr	CALL	RSTSFLG		; Restore old SFLAG$	@@CKBRKC		; Clear any BREAK	RET			; Exit;;	I/O Error handler;PRMERR	LD	A,PAR_ERR	; Parameter errorIOERR	LD	L,A		; Move error code to HL	LD	H,00H	OR	0C0H		; Abbrev, return	LD	C,A	@@ERROR			; Show error	JR	SAVESP		;   and exit;;	Internal error message handler;NOMDSK	LD	HL,NOMDSK$	; Memdisk active	DB	0DDHNORTES	LD	HL,NORTES$	; File routines active	DB	0DDHNOTFND	LD	HL,NOTFND$	; No config found	DB	0DDHNOSPL	LD	HL,NOSPL$	; Spool active	DB	0DDHWRPROT	LD	HL,WRPROT$	; Disk write protected	DB	0DDHNOCANDO	LD	HL,NOCNDO$	; Sysgen inhibit set	CALL	@LOGOT;ABORT	LD	HL,-1		; Set abort code	JR	SAVESP		; Exit;;	SYSGEN1 - Save the state of the system;SYSGEN1	LD	DE,PRMTBL$	; Check for user parameters	@@PARAM	JP	NZ,PRMERR	; Exit on param error	@@FLAGS			; Get system flags;;	Routine to process DRIVE parameter;DRIVE	LD	BC,0		; Get drive param response	LD	A,C	CP	08H		; Drive in range?	JP	NC,PRMERR	; Go if > 7	OR	'0'		; Make it ascii	LD	(CFGSPEC),A	; Save in drive spec	LD	(ATRSPEC),A	; and attrib cmd line	@@CKDRV			; Check drive	JP	C,WRPROT	; Abort if write protected	CALL	NPARM		; Check on yes/no entry	JP	Z,CFGOFF	; Jump if SYSGEN=OFF	BIT	0,(IY+'D'-'A')	; Can't sysgen if spool	JP	NZ,NOSPL	;   is active	BIT	4,(IY+'D'-'A')	; Can't sysgen if memdisk	JP	NZ,NOMDSK	;   is active	BIT	5,(IY+'C'-'A')	; Check user sysgen inhibit	JP	NZ,NOCANDO	; Quit if set	CALL	CKRTES		; Check if any route to file	JP	NZ,NORTES	; Can't do it if so;;	Initialize a CONFIG file on disk 0, or user spec'd drive;	LD	DE,GENDCB	; "config/sys.ccc	LD	HL,GENBUF	; Config I/O buffer	LD	B,00H		; Set LRL = 256	@@INIT			; Create config file	JP	NZ,IOERR	; Quit on init error;;	Generate the file header block;	LD	A,05H		; Put file header	CALL	PUTOUT	LD	A,06H		; Put header length	CALL	PUTOUT	LD	B,06H		; Put header name	LD	HL,CFGNAM$	; "CONFIG"WRNAM	LD	A,(HL)		; Write name to file	INC	HL	CALL	PUTOUT	DJNZ	WRNAM		; Loop for 6 chars;;	Generate disabling of all interrupts;	LD	B,01H		; Set block length	LD	DE,@RST38	; Set load address	LD	HL,C9FLD	; Point to block (X'C9')	CALL	WRBLCK		; Write the block;;	Dump memory from (DVRHI$) to DVREND$;	LD	HL,(DVRHI$)	; Point to max memory	LD	DE,DVREND$	; Point to start	XOR	A		; Clear carry	SBC	HL,DE		; How much to save	LD	B,H		;   into BC	LD	C,L	CALL	NZ,DUMP		; Dump block to file;;	Dump memory from HIGH$ to top of memory first;	LD	DE,(PHIGH$)	; Point to max memory	LD	HL,0		; Set up to get current	LD	B,L		;   HIGH$	@@HIGH$	EX	DE,HL		; HIGH$ to DE,	XOR	A		;   PHIGH to HL	SBC	HL,DE		; How much to save	LD	B,H	LD	C,L	INC	DE		; First byte to use	CALL	NZ,DUMP		; Dump HIGH$+1 to top;;	Generate all data from address table;	LD	HL,ADRTBL$	; Point to grab tableWRTBL	LD	C,(HL)		; Pick up lo-order length	INC	HL	LD	B,(HL)		; Get high order length	INC	HL	LD	A,B		; Are we done?	OR	C	JR	Z,GENDCT	; Exit on zero length	LD	E,(HL)		; Get low order address	INC	HL	LD	D,(HL)		;   and high order	INC	HL	PUSH	HL		; Save table pointer	CALL	DUMP		; Dump block to file	POP	HL		; Restore table pointer	JR	WRTBL		;   and loop for more;;	Generate the DCT$ (offset);GENDCT	LD	B,80		; Table is 80 bytes	LD	DE,MOD3BUF	; Place to stuff DCT$	LD	C,00H	@@GTDCT			; Write out the DCTs	PUSH	IY		;   handled by SYS0	POP	HL	CALL	WRBLCK		; Write to file;;	Generate the original interrupt vector jump;INTVEC	LD	B,01H		; File the interrupt	LD	DE,@RST38	;   vector address	LD	HL,JPINST	;   with a JP instruction	CALL	WRBLCK		; Write the block;;	Generate the transfer address;	LD	A,02H		; TRAADR	CALL	PUTOUT		; Write byte	LD	A,02H		; Length	CALL	PUTOUT	XOR	A		; Xfer addr is 0	CALL	PUTOUT	XOR	A	CALL	PUTOUT	@@CLOSE			; Close config file	JP	NZ,IOERR	; Quit on close error;;	Let the config sector know there's a CONFIG/SYS;	IF	@MOD2;	LD	A,(DRIVE+1)	; Drive #	LD	C,A		; Pass drive #	LD	HL,SBUFF$	; I/O buffer	@@GTDCT			; Fetch DCT;	LD	A,(IY+3)	; Get DCT data	AND	28H		; Bit 5/3	CP	20H		; 8" floppy?	JR	NZ,SETSYS1	; Go if not	LD	A,(IY+4)	; Get DCT data	AND	50H		; Bit 6/4	CP	40H		; DD and not alien?	JR	NZ,SETSYS1	; Go if not;	LD	D,(IY+9)	; Get GAT address	LD	E,0		; DE => GAT	@@RDSEC			; Read sector	CP	6		; Directory?	JP	NZ,IOERR	; Go on disk error	LD	A,(SBUFF$+0CDH)	; Get GAT data byte	BIT	7,A		; Data disk?SETSYS1	LD	D,0		; Init sys info sector	JR	NZ,$+3		; Go if not 8" floppy sys	INC	D		;   else sysinfo on cyl 1	LD	E,2		; Sysinfo sector;	ENDIF;	LD	HL,SBUFF$	; Use this as disk buffer;	IF	@MOD4	LD	DE,0<8+2	; Track 0, sector 2 (SysInfSec)	ENDIF;	LD	A,(DRIVE+1)	; Get logical drive #	LD	C,A		;   of drive (DRIVE)	@@RDSEC			; Read system info sector	JP	NZ,IOERR	; Quit on read error	XOR	A		; Turn on standard config	LD	(SBUFF$+1),A	@@WRSEC			; Write it back	JP	NZ,IOERR	; Quit on write error	LD	L,0C0H		; Point to SYS/DATA byte	OR	(HL)		; Check if system disk	LD	HL,WARN$	;   and inform if not	JR	NZ,M2554	@@LOGOT;;	Let the user know it's done;M2554	@@LOGOT	CFGBLT		; Log completion	CALL	RSTSFLG		; Restore SFLAG$	LD	HL,ATRBIT	; Make CONFIG invisible	LD	A,18H		; Init for CMNDI	JP	RST28		;    and execute	LD	A,18H		;  <-- dead code (pwc)	RST	28H		;  <-- dead code (pwc);;	Restore setting of "in JCL" bit;RSTSFLG	PUSH	HL		; Save HL	LD	HL,SFLAG$	; Point to SFLAG$	LD	(HL),00H	; Put old SFLAG$ backSVSFLG	EQU	$-1	POP	HL		; Recover HL	RET			; and return;;	Routine to DUMP core;DUMP	EX	DE,HL		; Load address to HL	LD	DE,GENDCB	; Config/sys FCBDUMP1	PUSH	HL	PUSH	BC		; Save block length	LD	H,B		; Length of this block	LD	L,C		;   to HL	LD	BC,254		; Write block in groups	XOR	A		;   of 254 bytes max	SBC	HL,BC		; Sub block len from dump len	JR	NC,DUMP2	; Go if write len > 254	POP	BC		; Recover block len	LD	HL,0		; Show block written	JR	DUMP3;DUMP2	POP	AF		; Remove old len from stackDUMP3	EX	(SP),HL		; Exchange length/address	LD	B,C	LD	A,01H		; Start of block	CALL	PUTOUT	LD	A,B	ADD	A,02H		; add for address	CALL	PUTOUT		; Write block length	LD	A,L		; Write lo-order address	CALL	PUTOUT	LD	A,H		; Write hi-order address	CALL	PUTOUTDUMP4	LD	A,(HL)	INC	HL	CALL	PUTOUT		; Write the block	DJNZ	DUMP4		; Loop for length	POP	BC		; Get remaining length	LD	A,B		; Anything left?	OR	C	JR	NZ,DUMP1	; Loop back if not doneC9FLD	RET			;   else go back;;	Routine to write an offset block;JPINST	DB	0C3H		; JP instructionWRBLCK	PUSH	HL		; Save real load address	LD	H,D		; HL = offset address	LD	L,E	LD	DE,GENDCB	; Config/sys FCB	LD	A,01H		; Start of block	CALL	PUTOUT	LD	A,B	ADD	A,02H		; Adjust for address	CALL	PUTOUT		; Write block length	LD	A,L		; Lo-order address	CALL	PUTOUT	LD	A,H		; Hi-order address	CALL	PUTOUT	POP	HL		; Recover real addressWRBLK1	LD	A,(HL)		;   and get data from there	INC	HL	CALL	PUTOUT		; Write the block	DJNZ	WRBLK1	RET;;	Perform SYSGEN OFF;CFGOFF	LD	HL,SBUFF$	; Set disk I/O buffer;	IF	@MOD2;	LD	A,(DRIVE+1)	; Get drive	LD	C,A		; Pass to C	@@GTDCT			; Fetch DCT	LD	D,(IY+9)	; Dir cylinder;	LD	A,(IY+3)	; Get DCT data	AND	28H		; Bit 5/3	CP	20H		; 8' floppy?	JR	NZ,SETSYS2	; Go if not	LD	A,(IY+4)	; Get data	AND	50H		; Bit 6/4	CP	40H		; DD not alien?	JR	NZ,SETSYS2	; Go if not;	LD	E,0		; GAT table	@RDSEC			; Read sector	CP	6		; Directory read?	JP	NZ,IOERR	; Quit if not	LD	A,(SBUFF$+0CDH)	; Get GET data byte	BIT	7,A		; System disk?SETSYS2	LD	D,0		; Cyl 0 if not	JR	NZ,$+3		; Go if not	INC	D		; else on cyl 1	LD	E,2		; Sysinfo sector;	ENDIF;	IF	@MOD4	LD	DE,0<8+2	; Trk 0, Sec 2 (SysInfo)	ENDIF;	LD	A,(DRIVE+1)	; Get drive number and	LD	C,A		;   note that no config	@@RDSEC			;   is on the disk	JP	NZ,IOERR	; Exit if read error	LD	A,0C9H	LD	(SBUFF$+1),A	; C9 indicates no config	@@WRSEC	JP	NZ,IOERR	; Quit if write error;;	Now that none is shown, kill the CONFIG/SYS file;	LD	DE,GENDCB	; Point to FCB	LD	B,00H	@@OPEN			; Try to open the config	JP	NZ,NOTFND	; Jump if not there	@@REMOV			; Kill CONFIG/SYS	JP	NZ,IOERR	; Quit if can't be killed	@@LOGOT	CFGDEL$		; "config deleted"	RET			; Done - return;;	Parameter parsing of yes/no;NPARM	LD	BC,0		; Get NO param entry	LD	A,B		; Set?	OR	C		; If no, make Z	XOR	0FFH	RET;YPARM	DW	0;;	Any devices routed to files?;CKRTES	LD	DE,'IK'		; Point to begin of area	@@GTDCB			; Get DCBCKRT0	PUSH	HL		; Save pointerCKRT1	BIT	4,(HL)		; Routed device?	JR	Z,CKRT2		; Jump if not	INC	L		; Bypass TYPE code	LD	A,(HL)		; Get route vector	INC	L	LD	H,(HL)		;   into HL	LD	L,A	BIT	7,(HL)		; Routed to a file?	JR	Z,CKRT1		; Check further if not	POP	HL		;   else exit with NZ	RET;;	Point to next device;CKRT2	POP	HL		; Recover DCB pointer	LD	A,L		; Advance to next DCB area	ADD	A,08H		; Loop through all	LD	L,A		;   devices while checking	JR	NZ,CKRT0	; Loop until table end	RET;;	Write a byte to the file;PUTOUT	LD	C,A		; Move byte into C	@@PUT	RET	Z		; Back if good	JP	IOERR		;   else abort;;;GENDCB	DB	'CONFIG/SYS.CCC:0',0CFGSPEC	EQU	$-2	DS	32-$+GENDCBCFGNAM$	DB	'CONFIG'CFGBLT	DB	'User configuration built',0DHATRBIT	DB	'Attrib CONFIG/SYS.CCC:d (I)',0DHATRSPEC	EQU	$-6CFGDEL$	DB	'User configuration deleted',0DHNOTFND$	DB	'No user configuration found',0DHWARN$	DB	'Warning: Target drive contains no system',0DHWRPROT$	DB	'Specified drive is write protected',0DHNOCNDO$	DB	'** SYSGEN inhibited at this time **',0DHNOSPL$	DB	'Can',27H,'t while SPOOL is active',0DHNOMDSK$	DB	'Can',27H,'t while MEMDISK is active',0DHNORTES$	DB	'Can',27H,'t while route-to-file is active',0DH;;	Parameter table;PRMTBL$	DB	80H		; Ver 6.x table format;	DB	42H,'ON',0	DW	YPARM;	DB	43H,'OFF',0	DW	NPARM+1;	DB	53H,'YES',0	DW	YPARM;	DB	52H,'NO',0	DW	NPARM+1;	DB	95H,'DRIVE',0	DW	DRIVE+1;	DB	00H		; End of table;;	Table of regions to SYSGEN;ADRTBL$	DW	2,HIGH$		; Save HIGH$	DW	2,LOW$		; Lowest user address	DW	1,TIMSL$	; Time slice	DW	250,DVRHI$	; Save primary DCBs	DW	3,EXTDBG$	; Ext DEBUG vector and DBGHK	DW	50,INTIM$	; Table and TDBs	DW	34,FLGTAB$	; Flag table & assorted	DW	2,75*2+SVCTAB$	; Save WRITE vector	DW	3,HKRES$	; Sys overlay hook	DW	2,KIDATA$+2	DW	1,DODATA$	DW	2,DODATA$+3	DW	16,240+SVCTAB$	; SVCs 120-127	DW	16,@RST08	; RST zones 8 and 10	DW	1,HERTZ$	; Hertz rate for timer	DW	1,TSLPX@	; Something in printer driver??;	IF	@MOD2	DW	3,$CRSCHAR	; Cursor char + column size	ENDIF	IF	@MOD4	DW	0,0	ENDIF;	DW	0,0		; End of table;	DC	46,0		; Patch space;	ORG	$<-8+1<+8;GENBUF	EQU	$;	END	SYSGEN