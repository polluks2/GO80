;FORMAT2/ASM - Format Initialization Code;;	Format routine entry point;FORMAT	@@CKBRKC		; Check for break	JR	Z,FORMATA	; Continue if none	LD	HL,-1		;   else abort	RET;FORMATA	LD	(SPSAV+1),SP	; Save the stack pointer	PUSH	HL		; Save cmd line pointer	LD	HL,HELLO$	; Hello message	@@DSPLY	CALL	GETSYS2		; Load SYS2 overlay;;	Read config sector and extract DCT # cyls;; I'm not typing any more Model 2 stuff in, doggone it. (pwc);	LD	DE,0002		; Track 0, sector 2	LD	C,D		; Drive 0	LD	HL,HITBUF	; Set disk buffer	@@RDSEC	JP	NZ,IOERR	LD	L,70H+6		; Point to default DCTs	PUSH	HL		; Move pointer to IY	POP	IY	LD	A,(IY+3-6)	; Get DCT$ default step	AND	03H		;   and strip off	LD	(STEPARM+1),A	; Keep for step param;;	Keep cyl count on all eight drives;	LD	B,08H	LD	IX,DCTCYL	; Point to where to stuff	LD	DE,10		; 10 byte incrementsDCTLP1	LD	A,(HL)		; Get default # cyls	LD	(IX+00H),A	; Save in table	INC	IX	ADD	HL,DE	DJNZ	DCTLP1		; Loop for 8 drives;	POP	HL		; Get ptr to cmdline backFMT1	LD	A,(HL)		; Ignore spaces	INC	HL	CP	' '	JR	Z,FMT1	CP	':'		; Colon drive indicator?	JR	Z,FMT2		; Go if it is;;	Drive not entered, prompt for it;	DEC	HL		; Backspace command line	DEC	HL		; & adjust for next inc	PUSH	HL		; Save pointerWHDRV	@@DSPLY	WHDRV$		; "Which drive	LD	HL,HITBUF	; Input buffer for now	LD	BC,1<8		; 1 char entry	@@KEYIN	JP	C,FMTABT	; Quit if break key	LD	A,(HL)		; Get the entry	SUB	'0'		; Convert to binary	CP	08H		; Is it in range?	JR	NC,WHDRV	; Loop until it is	POP	HL		; Cmd line ptr back	JR	FMT2A;;	Drive entered;FMT2	LD	A,(HL)		; Get drive #	SUB	'0'		; Convert to binary	CP	08H		; Check range	JP	NC,PRMERR	; Go if error;FMT2A	LD	(FMTDRV+1),A	; Save drive number	INC	HL		; Bump cmd line ptr	LD	DE,PRMTBL$	; Parse any parameters	@@PARAM	JP	NZ,PRMERR;;	Test if any other param was entered;SDPARM	LD	DE,0		; Single density param?	LD	A,D	OR	E		; Merge all these paramsDDPARM	LD	DE,0		; Double density	OR	D	OR	ESIDES	LD	DE,0		; Sides	OR	D	OR	ECPARM	LD	DE,0		; Cyls	OR	D	OR	ESTEPARM	LD	DE,0FF00H	; Init to show if entry	INC	D		; Did user enter it?	OR	D		; 0 = no user entry	LD	(PRMMRG+1),A	; Set to non-zero if any;;	if Q param, then set NAME and MPW if not entered;	LD	DE,(QPARM+1)	; Get Query param	LD	HL,(NPARM+1)	; Get Name param	LD	A,H	OR	L	JR	NZ,$+6		; Go if user entered name	LD	(NPARM+1),DE	;  else use Q-param	LD	HL,(MPARM+1)	; Get password param	LD	A,H	OR	L	JR	NZ,$+6		; Go if user entered password	LD	(MPARM+1),DE	; Set to Q-param entry;	LD	A,(FMTDRV+1)	; Get drive to format	LD	C,A		; Put in drive register	LD	HL,DCTCYL	; Find default # of cyls	ADD	A,L		; Index the DCTCYL table	LD	L,A		;   according to drive #	ADC	A,H	SUB	L	LD	H,A	LD	A,(HL)		; Get cylinder count	INC	A		; Offset from 1	LD	(PCYL2+1),A	; Stuff default for 5"	@@GTDCT			; Get the DCT pointer	PUSH	IY	POP	HL		;   into HL	LD	DE,SYSDCT	; Save the system's DCT	LD	BC,10		;   for the drive since	LDIR			;   we are altering it	LD	A,(SYSPRM+1)	; Check if "SYSTEM" param	INC	A		;   entered	JR	NZ,FMT2B	BIT	3,(IY+03H)	; Check if hard drive	JP	Z,NOTHARD	; Can't "SYSTEM" floppyFMT2B	CALL	DRVNOP		; Test if drive enabled	JP	NZ,IOERRNPARM	LD	HL,0		; Was NAME specified?	LD	A,H	OR	L	INC	A		; Was it just NAME	JR	Z,DSKNAM	; Prompt if so	DEC	A		; If entered, use it	JR	NZ,$+5		;DFTNAM	LD	HL,PAKNAM$	LD	DE,GATBUF+0D0H	; Yes, move name to field	LD	B,08H		; 8 chars maxMOVNAM	LD	A,(HL)		; Get a char	CP	'"'		; Closing quote?	JR	Z,CKNAME	CP	' '		; Space?	JP	C,CKNAME	CP	'a'	JR	C,MOVNAM1	CP	'z'+1	JR	NC,MOVNAM1	XOR	20H		; Force upper caseMOVNAM1	LD	(DE),A		; Put char into buffer	INC	HL		; Bump both pointers	INC	DE	DJNZ	MOVNAM		; Loop until complete	JR	CKNAME		; Check if valid name;;	Prompt user for name parameter;DSKNAM	@@DSPLY	DSKNAM$		; "Diskette name...	CALL	GET8		; Get 8 chars max, make UC	JR	Z,DFTNAM	; Use default if no entry	LD	C,B		; Only move to name field	LD	B,00H		;    the number entered	LD	DE,GATBUF+0D0H	LDIRCKNAME	LD	DE,GATBUF+0D0H	; Now check if illegal	CALL	CKMPW0		;   chars in name	JP	NZ,BADNAM	;   and quit if so	LD	HL,GATBUF+0D8H	; Get today's date and	@@DATE			;   put it in GAT;;	Master password handling;MPARM	LD	HL,0		; Did user enter the MPW?	LD	A,H	OR	L	INC	A		; If only MPW, then prompt	JR	Z,MPW		; Go prompt if not	DEC	A	JR	NZ,$+5		; If entered, use itDFTMPW	LD	HL,PAKMPW$	;   else use ours	LD	DE,MPWBUF	; Shift to pswd field	LD	B,08HMOVMPW	LD	A,(HL)		; Nothing less than "0"	CP	'0'	JR	C,PRSMPW	; Also ends on closing '"'	CP	'a'		; Need upper case conversion?	JR	C,MOVMPW1	; Go if not	CP	'z'+1	JR	NC,MOVMPW1	XOR	20H		; Force upper caseMOVMPW1	LD	(DE),A		; Store the char	INC	DE		;   and bump the pointers	INC	HL	DJNZ	MOVMPW		; Loop for # of chars	JR	PRSMPW		; Check if valid password;;	Prompt for master password;MPW	LD	HL,MPW$		; "Master pass...	CALL	INPMPW	JR	NC,DFTMPW	; Use default on ENTER;;	Parse the password & stuff into GAT sector buffer;PRSMPW	LD	DE,MPWBUF	CALL	CKMPW		; Check for valid MPW	JP	NZ,IOERR	LD	(GATBUF+0CEH),HL ; Stuff it	BIT	4,(IY+04H)	; Jump if alien controller	JP	NZ,CALCGPC	LD	HL,TBLDATA	; Point to config tables	LD	DE,6		; Index the data	BIT	5,(IY+03H)	; 8" drive?	JR	Z,INITDEN	; Bypass if not	ADD	HL,DE		; Else move to 8" cfgs	ADD	HL,DEINITDEN	LD	(SETSDEN+1),HL	; Stuff for SDEN options	EX	DE,HL		; 6 => HL, SDEN => DE	ADD	HL,DE		; Pt to DDEN index table	LD	(SETDDEN+1),HL	; Stuff DDEN config ptr	EX	DE,HL		; HL=SDEN, DE=DDEN	RES	6,(IY+03H)	; Set DCT to SDEN	BIT	6,(IY+04H)	; Test if DDEN capability	JR	Z,SETSTD	; Go if single	EX	DE,HL		; HL => DDEN table	SET	6,(IY+03H)	; Set DCT to DDENSETSTD	CALL	SETUP		; Init to std config	RES	4,(IY+03H)	; Set to use side 0	RES	5,(IY+04H)	; Set to 1 sidedPRMMRG	LD	A,00H		; <> 0 if config params	OR	A		;   in command line	JR	NZ,GETDENQPARM	LD	DE,-1		; Prompts? Default=Y	LD	A,D	OR	E	JP	Z,PSTEP1	; Go if no promptingGETDEN	BIT	6,(IY+04H)	; Bypass DDEN request msg	JR	Z,PMTSIDE	;   if no DDEN capability	LD	A,(PRMMRG+1)	; Also, don't prompt if any	OR	A		;   config param was entered	JR	NZ,GDDEN1	;   with command	LD	HL,DEN?$	; "Density <S,D>"	CALL	GET3	JR	Z,PMTSIDE	; Go on <ENTER>	LD	A,(HL)		; Get response	CP	'S'		; Single density?	JR	Z,SETSDEN	CP	'D'		; Double density?	JR	Z,SETDDEN	JR	GETDEN		; Redo if bad answerGDDEN1	LD	A,(DDPARM+1)	; Not prompted, was DDEN	XOR	0FFH		;   set in command line?	JR	NZ,GSDEN1SETDDEN	LD	HL,0		; Get DDEN index table	SET	6,(IY+03H)	; Set DCT to DDEN	JR	CHGDENGSDEN1	LD	A,(SDPARM+1)	; Was SDEN param	XOR	0FFH		;   on command line?	JR	NZ,PMTSIDE	; Go if notSETSDEN	LD	HL,0		; Get SDEN index table	RES	6,(IY+03H)	; Set DCT to SDENCHGDEN	CALL	SETUP		; Init #cyls & allocPMTSIDE	LD	A,(PRMMRG+1)	; Config params on	OR	A		;   the command line?	JR	NZ,PMTS1	; Bypass if yes	PUSH	IY		; Pick up flags table	@@FLAGS			;   and check if	BIT	5,(IY+'L'-'A')	;   2-side inhibit	POP	IY	JR	NZ,PMTS1	; If set, use 1 side	LD	HL,SIDES$	; "Double sided?"	CALL	GET3		; Get sides wanted	JR	Z,PMTCYL	; Go on <ENTER>	LD	A,(HL)		; Get the response	CP	'1'		; One is okay	JR	Z,PMTCYL	CP	'2'		; So is two	JR	NZ,PMTSIDE	; Redo if anything else	JR	TSTSID;;	Check side parameter from command line;PMTS1	LD	A,(SIDES+1)	; How many sides?	CP	02HTSTSID	JR	NZ,PMTCYL	; DCT okay if not 2	SET	5,(IY+04H)	; Set 2-sided drivePMTCYL	LD	A,(IY+03H)	; No cylinder request	AND	28H		;   if either hard disk	JR	NZ,PMTSTEP	;   or 8" drivePCYL1	LD	A,(PRMMRG+1)	; Get config test byte &	OR	A		;   bypass cyl req if user	JR	NZ,PCYL4	;   entered cmd line params	LD	HL,NUMCYL$	; "number of cyl...	CALL	GET3PCYL2	LD	A,00H		; Get default # of cyls	CALL	NZ,CVBIN	; Get # cyls on CR	CALL	PCYL3	JR	C,PCYL1	JR	PMTSTEPPCYL3	CP	96+1		; Cannot support anything	CCF			;   over 96	RET	C	CP	35		; Must be 35 or more	RET	C	DEC	A		; Adjust to 0 offset	LD	(IY+06H),A	;   and put in DCT	RET;;	User entered config params on the command line;PCYL4	LD	A,(CPARM+1)	; Was CYL= one of them?	OR	A	CALL	NZ,PCYL3	; Test cyls if so	JP	C,PRMERR	; Go if out of rangePMTSTEP	BIT	4,(IY+04H)	; Alien controller?	JR	NZ,CALCGPC;;	If step rate param wasn't entered, prompt;	for it but first determine 8" or 5" drive;	LD	A,(PRMMRG+1)	; Did user enter config	OR	A		;   params on cmd line?	JR	NZ,PSTEP1	; Go to step prompt if yes;	PUSH	IY	@@FLAGS			; Get flags table & check	BIT	0,(IY+0BH)	;   if step prompt inhibited	POP	IY	JR	NZ,PSTEP1	; Go if it's set;	BIT	5,(IY+03H)	; Need prompt.  Drive 8"?	JR	NZ,STEP8	; Jump if 8"STEP5	LD	HL,STEP5$	; "Step rate... 5"	LD	DE,SR5TBL	; Point to 5" step table	CALL	CALCSR		; Get 5" step rate	JR	NZ,STEP5	; Go back on error	JR	C,PSTEP1	JR	GOTSTEPSTEP8	LD	HL,STEP8$	; "Step rate...8"	LD	DE,SR8TBL	CALL	CALCSR	JR	NZ,STEP8	JR	NC,GOTSTEPPSTEP1	LD	A,(STEPARM+1)	; Get step param entry	AND	03H		; Keep 2 lo-order bits	JR	$+3GOTSTEP	LD	A,B		; Stuff boot step rate key	LD	(STEPDFT),A;;	Routine to calculate the # of grans per logical;	cylinder so that the GAT byte can be constructed;CALCGPC	LD	A,(IY+08H)	; Get # grans per cyl	RLCA			; Rotate into bits 0-2	RLCA	RLCA	AND	07H		; Strip off other data	INC	A		; Adjust for 0 offset;;	If double sided (cylindering), double the count;	BIT	5,(IY+04H)	; Test if 2 sided drive	JR	Z,$+3		; Skip if it's not	ADD	A,A		; Double the count	LD	BC,0FFFFH	; Init GAT byte to onesCGPC1	SLA	B		; Now keep removing low	DEC	A		;   order bits, 1 bit for	JR	NZ,CGPC1	;   each available granule	LD	HL,GATBUF	; Point to GAT buffer area	LD	A,(IY+06H)	; Get highest cylinder #CGPC2	LD	(HL),B		; Stuff the GAT byte into	INC	L		;   each position of the GAT	CP	L		;   one byte per cylinder	JR	NC,CGPC2;;	Test if we are at 202 first by ignoring the;	first two instructions with LD DE,xxxx;	LD	A,0CBH		; Continue to stuff GAT	DB	11H		;   until cyl 202CGPC3	LD	(HL),C		; Use FFH to show unused	INC	L	CP	L		; First test here for	JR	NZ,CGPC3	;   match against 202;;	Prompt for destination disk & prepare it;	LD	A,(FMTDRV+1)	; Get drive number	OR	A	JR	NZ,PFMT1	; Bypass if other than 0PMTDST	@@DSPLY	PMTDST$		; "Load dest disk..."	PUSH	IY		; Save DCT pointer	@@FLAGS			; Point to flags	BIT	5,(IY+'S'-'A')	; Check for JCL active	POP	IY	JP	NZ,FMTABT	; Abort if in JCL	LD	HL,HITBUF	LD	BC,0		; 0 chars means	@@KEYIN			; ENTER or BREAK only	JP	C,FMTABT	; Abort if breakPFMT1	PUSH	IY		; Move DCT to HL and	POP	HL		;   move it to temp	LD	DE,TMPDCT	;   storage again	LD	BC,10	LDIR	CALL	RESTOR		; Restore to cyl 0	JP	NZ,IOERR	CALL	RSELCT		; Reselect drive	JP	NZ,IOERR	BIT	4,(IY+04H)	; Jump if alien controller	JR	NZ,PFMT3	LD	HL,NOTRDY$	; Init "Drive not ready..."	BIT	7,A		; Test FDC ready status	JP	NZ,EXTERR	; Quit if not ready	LD	HL,NODRV$	; Init "Drive not in..."	BIT	2,A		; Test status for track=0	JP	Z,EXTERR	; Error if not at track 0	CALL	CKDRV		; Check if floppy not present	JR	NZ,PMTDST	LD	HL,CANTWR$	; Init "write protected...	RLCA			; Align to bit 7	OR	(IY+03H)	; Combine with soft WP setting	AND	80H		; Write protected?	JP	NZ,EXTERR	; Can't write if it is!	LD	A,(SYSPRM+1)	; Don't check space needed	OR	A		;   if SYSTEM info only	JR	NZ,PFMT3	LD	HL,FORMAT	; Start of format bufferPFMT2	LD	DE,0		; Get format space needed	ADD	HL,DE		; Pt to last addr needed	LD	D,H		; Transfer to DE	LD	E,L	LD	HL,0		; Set up to get HIGH$	LD	B,L	@@HIGH$			; Make sure it won't wrap	XOR	A		;   into protected memory	SBC	HL,DE	LD	HL,NOMEM$	; Init "insufficient mem...	JP	C,EXTERR	; Quit if not enough memoryPFMT3	LD	DE,0		; Init to cyl 0, sec 0	CALL	VERSEC		; Verify BOOT	JP	NZ,PFMT6	; Assume unformatted if err;;	Appears formatted, is there SYSTEM information?;	LD	A,(SYSPRM+1)	; Ignore data if SYSTEM	OR	A		;   info only	JP	NZ,PFMT6	LD	HL,HITBUF	; Point to IO buffer	CALL	RDSEC		; Try to read the BOOT	JP	NZ,IOERR	LD	HL,HASDAT$	; "System has data..."	@@LOGOT	LD	HL,NOFMT$	; "non-std format...;;	BOOT was read, is there a valid directory pointer?;	LD	A,(HITBUF+2)	; Get possible DIR cylinder	CP	(IY+06H)	; Check against max cyl #	JR	NC,PFMT5	; Go if higher or equal;;	Read the assumed GAT and test it;	LD	HL,HITBUF	; IO buffer	LD	E,L		; Sector 0	LD	D,A		; Assumed GAT cylinder	LD	HL,HITBUF	; <--- NOT NEEDED	CALL	RDSEC		; Read the sector	CP	06H		; DIR errcode returned?	JR	Z,PFMT4		; Jump if yes and grab data	LD	HL,CANTRD$	; Init "unreadable dir....	JR	PFMT5PFMT4	LD	HL,NODIR$	; "Init "non-init dir...	LD	A,(HITBUF+0DAH)	; Check if date field	CP	'/'		;   is present	JR	NZ,PFMT5	; Go if it isn't;;	The directory is readable - request its MPW;	LD	HL,HITBUF+0D0H	; Point to PACKID field	LD	DE,PACKID$+5	; Move name and date into	LD	BC,8		;   display message fields	LDIR	LD	DE,PACKID$+20	LD	C,8	LDIR;;	if MPW = "PASSWORD", just check ABS parameter;	LD	HL,(HITBUF+0CEH) ; Get disk's MPW	LD	DE,PASSWRD	; Hash of "PASSWORD"	XOR	A	SBC	HL,DE		; Is it that?	LD	HL,PACKID$	; Init "Name= date=...	JR	Z,PFMT5		; If match, go check ABS	PUSH	IY		; Save DCT	@@FLAGS			; Get system flags	BIT	7,(IY+'N'-'A')	; Skip MPW test in NFLAG$ set?	POP	IY	JR	NZ,PFMT5	; Go if we're skipping that	@@LOGOT	PUSH	IY	@@FLAGS	BIT	5,(IY+'S'-'A')	; Are we in JCL?	POP	IY	JP	NZ,FMTABT	; Abort if we are;;	User must enter currend disk's MPW to proceed;OLDMPW	LD	HL,OLDMPW$	; "What's the old MPW?	CALL	INPMPW		; Get user input to match	JR	NC,OLDMPW	LD	DE,MPWBUF	; Point to buffer	CALL	HASHMPW		; Hash the user entry;;	Routine to test MPW for match;	EX	DE,HL		; Xfer hashed MPW to DE	LD	HL,(HITBUF+0CEH) ;   Grab pack MPW	XOR	A		; Clear carry for subtract	SBC	HL,DE		; User entry match disk MPW?	JP	NZ,BADMPW	; Abort if no match	JR	PFMT6;;	The directory was not readable - request assurance;PFMT5	@@LOGOT			; Log messageAPARM	LD	DE,0		; Get ABS parameter	INC	E	JR	Z,PFMT6		; Go if ABS was used	PUSH	IY	@@FLAGS	BIT	5,(IY+12H)	; Are we in JCL?	POP	IY	JP	NZ,FMTABT	; Quit if in JCL and no ABS	LD	HL,SURE?$	; "Are you sure?	CALL	GET3		; Get response	LD	A,(HL)	CP	'Y'		; If not yes, abort	JP	NZ,FMTABTPFMT6	PUSH	IY		; Move DCT back into	POP	DE		;   place in system slot	LD	HL,TMPDCT	LD	BC,10	LDIR	CALL	RESTOR		; Restore to cyl 0	JP	NZ,IOERR	JP	GOFMT		; Go and format it;;	Routine to set up the DCT for format;SETUP	LD	A,(PCYL2+1)	; Get the highest cyl #	BIT	5,(IY+03H)	; If 8" drive use 77	JR	Z,$+4	LD	A,77	DEC	A	LD	(IY+06H),A	; Stuff in our DCT	LD	E,(HL)		; Grab address to	INC	HL		;   master formatting table	LD	D,(HL)	INC	HL	LD	(FMTTBL+1),DE	; Save that for later use	LD	E,(HL)		; Get DCT+7 data	INC	HL		; Max sector, # heads	LD	D,(HL)		; Get DCT+8, # sectors/gran	INC	HL		;   and grans/cylinder	LD	(IY+07H),E	; Stuff these values into	LD	(IY+08H),D	;   our DCT	LD	E,(HL)		; Get space needed for	INC	HL		;   the formatting buffer	LD	D,(HL)	LD	(PFMT2+1),DE	;   and save that for later	RET;;	Get and check the user supplied step rate;CALCSR	PUSH	DE		; Save step table	CALL	GET3		; Get user response	CALL	CVBIN		; Convert step to binary	POP	HL		; Step table back to HL	OR	A		; Use default?	SCF	RET	Z		; Return if not entered	LD	B,00H		; Init key to 0	CP	(HL)		; Step rate match?	RET	Z	INC	HL		; Bump table pointer	INC	B		; Init key to 1	CP	(HL)		; Match?	RET	Z	INC	B		; Init key to 2	INC	HL		; Bump pointer	CP	(HL)		; Match?	RET	Z	INC	HL		; Bump pointer	INC	B		; Init key to 3	CP	(HL)		; Match?	RET	Z	INC	HL		; Bump pointer	CP	(HL)		; Match?	RET			; Return with status;SR5TBL	DB	6,12,20,30,40SR8TBL	DB	3,6,10,15,20;;	Convert decimal ASCII to binary;CVBIN	LD	E,00H		; Init value to 0CVB1	LD	A,(HL)		; Get a character	INC	HL		; Bump buffer pointer	SUB	'0'		; Convert to binary	LD	B,A	CP	0AH		; Was it a decimal digit?	LD	A,E		; Get total so far	RET	NC		;   and return if not	ADD	A,A		; A=A*2	ADD	A,A		; A=A*4	ADD	A,E		; A=A*5	ADD	A,A		; A=A*10	ADD	A,B		; Add in new digit	LD	E,A		; Save result in E	JR	CVB1		; Loop until done;;	Get user master password entry;INPMPW	@@DSPLY			; Display the prompt	LD	HL,MPWBUF	; Use this buffer	LD	B,08H		; 8 chars max	CALL	GET8A		; Input the password	RET	Z		; Go if enter only	EX	DE,HL	ADD	A,E		; Find out where the CR	LD	L,A		;   was stuffed & cover it	LD	A,D	ADC	A,00H	LD	H,A	LD	A,08H		; If 8 chars entered	SUB	B	SCF			;   then we're done	RET	Z		;   else pad buffer with	LD	B,A		;   spacesFILLBLK	LD	(HL),' '	INC	HL	DJNZ	FILLBLK	SCF	RET;CKMPW	CALL	CKMPW0	RET	NZ;;	Hash a diskette password;HASHMPW	LD   A,0E4H		; Use SYS2 routine	RST	28H;CKMPW0	LD	B,08H		; 8 chars to check	PUSH	DE		; Xfer start of PW	POP	HL		;   to HL	LD	A,(HL)		; Get 1st char	JR	CKMPW2		;   and check A-ZCKMPW1	INC	HL		; Advance to next char	LD	A,(HL)		; Get it	CP	' '	JR	Z,CKMPW7	; Go on space	CP	'0'	JR	C,INVMPW	; Bad if < "0"	CP	'9'+1		;    or > "9"	JR	C,CKMPW3CKMPW2	CP	'A'	JR	C,INVMPW	;   but < "A"	CP	'Z'+1	JR	NC,INVMPW	; > Z is also badCKMPW3	DJNZ	CKMPW1		; Char okay, do another	XOR	A		; Set Z, PW good	RET;CKMPW5	INC	HL		; Next char position	CP	(HL)		; No embedded spaces	JR	NZ,INVMPWCKMPW7	DJNZ	CKMPW5		; Loop until 8 checked	XOR	A		; Set Z, PW good	RET;INVMPW	LD	HL,INVMPW$	; "Invalid PW...	LD	A,63		; Indicate extended error	OR	A		; Set NZ condition	RET;;	Brief routine to check a drive for availability;CKDRV	LD	HL,HITBUF	@@TIME			; Get the timer pointer	EX	DE,HL		; Time$ to HL	DEC	HL		; TIMER$ to HL	LD	A,(HL)		; Get current timer value	ADD	A,0FH		; Set timeout to 500 msec	LD	D,A		; Save for test later;;	Test for diskette in drive and rotating;CKDR1	CALL	CKDR6		; Test index pulse	JR	NZ,CKDR1	; Jump on indexCKDR2	CALL	CKDR6		; Test index pulse	JR	Z,CKDR2		; Jump on no indexCKDR2A	CALL	CKDR6	JR	NZ,CKDR2A	; Jump on index	RET;CKDR6	EI			; Make sure they're on	LD	A,(HL)		; Get latest TIMER$ value	SUB	D		; 500 msec passed yet?	JR	Z,CKDR7	CALL	RSELCT		; Reselect & wait not busy	BIT	1,A		; Test index	RETCKDR7	POP	DE		; Pop the return address	OR	01H		; Set "illegal drive #	RET			; return wiht NZ;;	Temporary storage space for format drive DCT;TMPDCT	DS	10		;EQU	3613HDCTCYL	DS	8		;EQU	361DH;;;;;;	ORG	3625H;;	Config table for single density 5";TBLDATA	DW	S5TBL,2409H,0D35H;;	Config table for double density 5";	DW	D5TBL,4511H,196AH;;	Config table for single density 8";	DW	S8TBL,270FH,1558H;;	Config table for double density 8";	DW	D8TBL,491DH,29B1H;;	Parameter error exit;BADNAM	LD	HL,BADNAM$	DB	0DDHBADMPW	LD	HL,INVMPW$	DB	0DDHNOTHARD	LD	HL,HARD$	JP	EXTERRPRMERR	LD	A,44		; Init param error	JP	IOERR;;	Load SYS2 overlay;GETSYS2	LD	A,84H		; Returns to caller	RST	28H;;	Messages and data areas;MPWBUF	DC	9,' ';;	Parameter table;PRMTBL$	DB	80H;	DB	74H	DB	'NAME'NRESP	DB	00H	DW	NPARM+1;	DB	73H	DB	'MPW'MRESP	DB	00H	DW	MPARM+1;	DB	44H	DB	'SDEN'	DB	00H	DW	SDPARM+1;	DB	44H	DB	'DDEN'	DB	00H	DW	DDPARM+1;	DB	85H	DB	'SIDES'	DB	00H	DW	SIDES+1;	DB	93H	DB	'CYL'	DB	00H	DW	CPARM+1;	DB	84H	DB	'STEP'	DB	00H	DW	STEPARM+1;	DB	53H	DB	'ABS'	DB	00H	DW	APARM+1;	DB	55H	DB	'QUERY'	DB	00H	DW	QPARM+1;	DB	46H	DB	'SYSTEM'	DB	00H	DW	SYSPRM+1;	DB	94H	DB	'WAIT'	DB	00H	DW	WAITPRM+1;	DB	93H	DB	'DIR'	DB	00H	DW	DIRPARM+1;	DB	00H;;;HELLO$	DB	'FORMAT'*GET	CLIENT;HARD$	DB	'Cannot "SYSTEM" a floppy',0DHNOMEM$	DB	'Out of memory',0DHWHDRV$	DB	'Which drive is to be used ? ',03HDSKNAM$	DB	'Diskette name ? ',03HMPW$	DB	'Master password ? ',03HNUMCYL$	DB	'Number of cylinders ? ',03HSTEP5$	DB	'Boot strap step rate <6, 12, 20, 30 msecs> ? ',03HSTEP8$	DB	'Bootstrap step rate <3, 6, 10, 15/20 msecs> ? ',03HSIDES$	DB	'Enter number of sides <1,2> ? ',03HDEN?$	DB	'Single or Double density <S,D> ? ',03HNOTRDY$	DB	'Drive not ready',0DHCANTWR$	DB	'Write protected disk',0DHNODRV$	DB	'Drive not in system',0DHPMTDST$	DB	'Load destination diskette  <ENTER>',0DHHASDAT$	DB	'Disk contains data -- ',03HNOFMT$	DB	'Non-standard format',0DHCANTRD$	DB	'Unreadable directory',0DHNODIR$	DB	'Non-initialized directory',0DHPACKID$	DB	'Name=XXXXXXXX  Date=MM/DD/YY',0DHOLDMPW$	DB	'  Enter its Master Password or <BREAK> to abort: ',03HLASTMSG	DB	'*** The target drive is a hard disk ***',0AHSURE?$	DB	'Are you sure you want to format it ? ',03HINVMPW$	DB	0AH,'Invalid Master Password',0AH,0DHBADNAM$	DB	'Invalid Disk Name',0DHPAKNAM$	DB	'DATADISK'PAKMPW$	DB	'PASSWORD'