;****************************************************************;* Filename: SYS12/ASM						*;* Rev Date: 30 Nov 97						*;* Revision: 6.3.1						*;****************************************************************;* Handler for mini directory and free space SVCs, as well	*;* as checking for a memory module header.			*;****************************************************************;	TITLE	<SYS12 - LS-DOS 6.3>;*LIST	OFF*GET	SYSRES/EQU*LIST	ONLF	EQU	10CR	EQU	13;*GET	COPYCOM;	ORG	1E00HSYS12	AND	70H		; Strip bit 7	RET	Z		; Back on zero entry	CP	30H		; Locate module address?	JP	Z,GTMOD	CP	20H		; Mini dir?	JP	Z,MDIR	CP	10H		; RAMDIR?	RET	NZ		; Ret if any other entry;;	RAMDIR interfacing;;	HL = user buffer area;	 B = drive #;	 C = 0 for entire directory;	 C = 1-254 for selected DEC-1 (02-FF);	 C = 255 for disk space; in use / free;RAMDIR	LD	A,07H		; Check valid drive #	CP	B	LD	A,32		; Init "illegal drive	RET	C	CALL	LNKFCB@		; Save regs	LD	A,B		; Get drive where needed	LD	B,C		; Xfer DEC to B	LD	C,A		; and drive to C	OR	'0'		; Make it ASCII	LD	(DSTDRV+1),A	; Stuff for STUFBUF	CALL	CKDRV		; Make sure disk is there	RET	NZ	INC	B		; Test 0, 1-254, 255	JR	NZ,DIRINFO	; Go if directory req;;	Get free space info;	PUSH	HL		; Save buffer pointer	CALL	SPACE		; Get our info	LD	B,(HL)		; Get free space in k	DEC	HL		;   into BC	LD	C,(HL)	DEC	HL	LD	A,(HL)		; Get total space in k	DEC	HL		;   into HL	LD	L,(HL)	LD	H,A	SBC	HL,DE		; Calc "in use" (CF=0)	EX	DE,HL		; Xfer to DE	POP	HL		; Recover user buf ptr	LD	(HL),E		; Stuff "in use"	INC	HL	LD	(HL),D	INC	HL	LD	(HL),C		; Stuff "free to use"	INC	HL	LD	(HL),B	XOR	A		; Show no error	RET;;	Do RAMDIR directory info;DIRINFO	DEC	B		; if DEC = 0 do it all	JR	Z,DOALL		; Go if all of it	INC	B		; 1=>2, 2=>3, etc;;	Calculate the number of directory sectors;	= (sectors * heads) - 2 for GAT & HIT;	LD	A,07H		; Get highest sector #	CALL	@DCTBYT	LD	D,A		; Store heads & sectors	AND	1FH		; Rake off # sectors	LD	E,A		;   & stuff it in E	INC	E		; Adjust for zero offset	XOR	D		; Recover # of heads	RLCA			;   into bits 0-2	RLCA	RLCA	INC	A		; Adjust for 0 offset	CALL	@MUL8		; Multiply sectors * heads	LD	E,A		; Now check double bit	LD	A,04H	CALL	@DCTBYT	BIT	5,A		; Set if 2-sided	LD	A,E	JR	Z,ONESID	; Go if not set else	ADD	A,A		;   double the valueONESID	SUB	02H		; Reduce for GAT & HIT	LD	D,A		; D -> # of dir sectors	LD	A,B		; Get requested DEC	AND	1FH	CP	D		; See if in range	JR	C,DIRINF1	; Go if so	LD	A,16		; "Illegal logical file #	OR	A		; Return out of range error	RET;DIRINF1	PUSH	HL		; Save buffer ptr	CALL	@DIRRD		; Get its directory record	POP	DE		; Recover buf pointer	RET	NZ		; Go back on error	LD	A,(HL)		; Get attributes	AND	0D8H		; Only if in use & VISible	XOR	10H		; Flip state so NZ=no	LD	A,25		; Init "File access denied	RET	NZ		; Return on no file, SYS, INVGETSTUF	PUSH	HL		; Save DIR ptr	CALL	STUFBUF		; Stuff the filespec	POP	HL	LD	A,(HL)	AND	07H		; Keep the access level	LD	(DE),A	INC	DE	INC	L		; Go up to EOF offset	INC	L	INC	L	LDI			; Move in offset & LRL	LDI	LD	A,L		; Bump to ERN	ADD	A,15	LD	L,A	LD	A,(HL)		; Get the ERN	LD	(DE),A		;   and xfer it	INC	L	INC	DE	LD	H,(HL)	LD	L,A		; # sectors to HL	EX	DE,HL		;   hence to DE	LD	(HL),D		; Stuff ERN high-order	INC	HL		; Bump buf ptr	INC	DE		; Adjust for rounding	INC	DE	INC	DE	SRL	D		; Divide by 4 to calc K	RR	E	SRL	D	RR	E	LD	(HL),E		; Move result to buffer	INC	HL	LD	(HL),D	INC	HL	LD	(HL),'+'	; Stuff buffer terminator	EX	DE,HL	XOR	A	RET;;	RAMDIR - Do all of the directory;DOALL	EX	DE,HL		; Buffer ptr to DE	CALL	HITRD1		; Read in the HIT	RET	NZ		; Exit if read error	JR	DOALL3;DOALL1	POP	BC		; Recover HIT ptr lo	LD	H,DIRBUF$<-8	LD	L,B		; Advance to next dirDOALL2	LD	A,L		;   record of this sector	ADD	A,32	LD	L,A	JR	NC,DOALL3	; Bypass if still the same	INC	L		;   else point to next one	BIT	5,L		; Finished with	JR	Z,DOALL3	;   this drive?	XOR	A	RET;DOALL3	LD	A,(HL)		; Get HIT entry	OR	A	JR	Z,DOALL2	; Jump if spare	LD	B,L		; Save DEC in reg B	PUSH	BC		;   and to stack	LD	A,L		; Point to dir rec for	AND	0E0H		;   this DEC	LD	L,A		; Get the dir sector for	XOR	B		;   this DECDOALL4	CP	0FFH		; Same as one in core?	JR	Z,DOALL5	; Jump if so, else	LD	(DOALL4+1),A	;   update one we have and	CALL	@DIRRD		;   read it into buffer	JP	NZ,MDIR12	; Jump on read errorDOALL5	LD	H,SBUFF$<-8	; Sysbuf high order byte	LD	A,(HL)		; Get attributes	AND	0D8H		; Test FXDE and in use	XOR	10H		; If not used or FXDE	JR	NZ,DOALL1	;   then back to DOALL1	PUSH	HL	CALL	GETSTUF		; Get the dir info	POP	HL	JR	DOALL1;;	Routine to display a mini directory;;	 C => Drive number in binary (0-7);	 B -> Option, 0=display, 1=buffer stuff;	      2=display /EXT, 3=buffer /EXT;	      4=space into buffer;	HL -> Address of buffer to stuff dir info & EXT;	 Z <- Set on valid conclusion;	NZ <- Set on any error;MDIR	LD	A,07H		; Test for bad drive #	CP	C	LD	A,32		; "illegal drive"	RET	C	CALL	CKDRV		; Be sure disk is there	RET	NZ	CALL	LNKFCB@		; Save the regs	LD	A,B		; Stuff the options	LD	(TSTOPT+1),A	CP	04H		; If option 4 go get	JP	Z,SPACE0	;   space info	LD	A,43		; Init SVC PARM error	RET	NC		; Back if option > 4	PUSH	HL		; Save possible buffer	PUSH	BC	LD	DE,LILBUF	; Save possible /EXT	LD	BC,3	LDIR	POP	BC	LD	A,C		; Get drive and	OR	'0'		;   make it ASCII	LD	(DSTDRV+1),A	LD	A,05H		; Init to 5 files/line	LD	(MDIR11+1),A	LD	A,23		; & 23 lines/page	LD	(CKPAGE+1),A	CALL	HITRD1		; Read in the HIt	POP	DE		; Recover possible buffer	RET	NZ		; Return on read error	JR	MDIR3MDIR1	POP	BC		; Recover HIT pointer lo	LD	H,DIRBUF$<-8	LD	L,B		; Advance to next dirMDIR2	LD	A,L		;   record of this sector	ADD	A,32	LD	L,A	JR	NC,MDIR3	; Bypass if still same	INC	L		;   else point to next one	BIT	5,L		; Finished with this drive?	JR	Z,MDIR3	LD	A,(TSTOPT+1)	; If option 1 or 3	AND	01H		;   must stuff buffer end	JR	NZ,CLSBUF	LD	A,CR		;   else do a blank line	CALL	@DSP	XOR	A	RET;CLSBUF	LD	A,0FFH		; Put in buffer terminator	LD	(DE),A	XOR	A	RET;MDIR3	LD	A,(HL)		; Get HIT entry	OR	A	JR	Z,MDIR2		; Jump if spare	LD	B,L		; Save DEC in reg B	PUSH	BC		;   and to stack	LD	A,L		; Point to dir rec for	AND	0E0H		;   this DEC	LD	L,A		; Get the dir sector	XOR	B		;   for this DECMDIR4	CP	0FFH		; Same as in core?	JR	Z,MDIR5		; Jump if so	LD	(MDIR4+1),A	;   else update what we have	CALL	@DIRRD		;   and read it into buffer	JR	NZ,MDIR12	; Jump on read errorMDIR5	LD	H,SBUFF$<-8	; Sysbyf high byte	LD	BC,MDIR1	; Set up return address	PUSH	BCTSTOPT	LD	A,00H		; Get the option #	PUSH	HL	PUSH	DE	CALL	TSTSAM		; Check for extension match	POP	DE	POP	HL	RET	NZ		; Back to MDIR1	LD	A,(TSTOPT+1)	RRCA			; Test for option 1 or 3	LD	A,(HL)	JR	NC,DSPLYIT	; Go if 0 or 2	AND	90H		; Test FXDE & in use	XOR	10H		; if not used, FXDE	RET	NZ		; Back to MDIR1	LD	BC,16	LDIR			; User's buffer	INC	L		; Bypass stored passwords	INC	L	INC	L	INC	L	LD	C,02H		; and xfer ERN	LDIR	RET			; back to MDIR1;DSPLYIT	AND	0D8H		; Test if we want this	XOR	10H		; Only if in use & VIS	RET	NZ		; Back to MDIR1	LD	DE,LILBUF+3	PUSH	DE	CALL	STUFBUF		; Move filespec to buffer	POP	HL		; Recover LILBUF ptr	CALL	@DSPLY		; Display the fileMDIR11	LD	A,00H		; Count down 5 across	DEC	A	LD	(MDIR11+1),A	; Update count	RET	NZ		; Loop if more to go	LD	A,05H		; Else re-init	LD	(MDIR11+1),A	LD	A,CR	CALL	@DSP		; New lineCKPAGE	LD	A,00H		; Get display count	DEC	A	LD	(CKPAGE+1),A	RET	NZ	LD	A,23	LD	(CKPAGE+1),A	; Reset for max	CALL	@KEY		; Wait for keyboard input	JP	@CLS		; Clear screen and return;MDIR12	POP	BC	RET;TSTSAM	BIT	1,A		; Chk if /EXT option	RET	Z		; Ret with Z if	LD	BC,13		;   option <> /EXT	ADD	HL,BC		; Else point to /EXT	LD	B,03H		;   field of dir record	LD	DE,LILBUF	;   & check for matchTSTS1	LD	A,(DE)	CP	'$'		; '$' matches with all	JR	Z,TSTS2	CP	'A'		; if numeric don't convert	JR	C,M1FDA		;   to upper case	RES	5,A		; Convert lc to ucM1FDA	CP	(HL)	RET	NZ		; Return on no matchTSTS2	INC	HL	INC	DE	DJNZ	TSTS1		; Loop for 3 chars	RET;;	Routine to construct the filespec fieldSTUFBUF	LD	A,L	ADD	A,05H		; Point to start of filename	LD	L,A	LD	C,0DH		; Init for 15-2 chars	LD	B,08H		; FilenameSTUFB1	LD	A,(HL)	INC	HL	CP	' '		; Exit on 1st space	JR	Z,STUFB2	LD	(DE),A		; Stuff the character	INC	DE	DEC	C		; String count down	DJNZ	STUFB1		; Field loop	JR	STUFB3		; Bypass ext calculationSTUFB2	LD	A,L		; Calc start of	ADD	A,B		; EXT field in dir record	DEC	A	LD	L,ASTUFB3	LD	A,(HL)		; Display EXT if present	CP	' '	JR	Z,STUFB5	; Exit if no ext	LD	A,'/'		; Display slash	LD	(DE),A		; Stuff the char	INC	DE	DEC	C		; Display char countdown	LD	B,03H		; Max 3 chars for EXTSTUFB4	LD	A,(HL)	INC	HL	CP	' '	JR	Z,STUFB5	; Exit on 1st blank	LD	(DE),A		;   else stuff the char	INC	DE	DEC	C	DJNZ	STUFB4		; Loop 3 charsSTUFB5	LD	A,':'		; Stuff a drive sep	LD	(DE),A		; Reg C  already accounted	INC	DE		;   for in the initDSTDRV	LD	A,00H		; Get drive number	LD	(DE),A	INC	DESTUFB6	LD	A,' '		; Stuff a space	LD	(DE),A	INC	DE	DEC	C		; Count down	JR	NZ,STUFB6	; Display trailing spaces	LD	A,03H		; Stuff the ETX	LD	(DE),A	RET;;	Routine to get the free space info;SPACE0	PUSH	HL		; Save buffer start	LD	DE,16		; Index for spacee	PUSH	DE	ADD	HL,DE	CALL	SPACE		; Get the space data	POP	BC		;   name & date	POP	DE		; Now shift in the	LD	HL,DIRBUF$+0D0H	;   disk name and date	LDIR	XOR	A	RET;SPACE	CALL	@GATRD		; Read GAT	RET	NZ		; Ret on gat read error	PUSH	IY	CALL	@GTDCT		; Get DCT vector	EX	DE,HL		; User buf ptr to DE	LD	H,00H		; Get highest cyl	LD	L,(IY+06H)	;   & adj for zero offset	INC	HL	LD	A,(IY+08H)	; Get sectors/gran	AND	1FH	INC	A		; Adjust for zero offset	PUSH	AF		; Save sectors per gran	PUSH	DE		; Save user buffer ptr	LD	E,A	LD	A,(IY+08H)	; Get grans / cyl	AND	0E0H	RLCA			; Shift into bits 0-2	RLCA	RLCA	INC	A		; Zero offset again	CALL	@MUL8		; Calc sectors / cyl	BIT	5,(IY+04H)	; Double sided?	JR	Z,M2062		; Skip if not	ADD	A,A		;   else double the countM2062	POP	BC		; Get user buf back	CALL	DOMUL16		; Calc total sectors	INC	HL		; Bump to next buf pos	PUSH	HL		;   & save pointer	LD	HL,DIRBUF$	; Point to start of GAT	LD	DE,0		; Init gran counter	LD	A,(DIRBUF$+0CCH)	; Get cyl excess	ADD	A,35		; Add in base	LD	B,A		; Set loop counterPUGAT	LD	A,(HL)		; Get GAT byteKEEP7	SCF			; Keep bit 7 set	RRA			; Slide gran bit to carry	JR	C,BYTEND?	; Ignore if in use	INC	DE		; Free, bump gran counterBYTEND?	CP	0FFH		; End of byte?	JR	NZ,KEEP7	; Loop if not	INC	L		; Bump GAT byte pointer	DJNZ	PUGAT		; Loop for # of cyls	EX	DE,HL		; Free grans -> HL	POP	BC		; Get user buffer back	POP	AF		; Get sectors / gran	POP	IYDOMUL16	CALL	@MUL16		; Calc # of free sectors	LD	H,B		; Convert #	LD	D,L	LD	L,C		;   to free space in K by	LD	E,A	INC	DE		;   dividing the # by 4	INC	DE		; Round up adjustment	SRL	D		; Divide 16 bit reg by 2	RR	E	SRL	D		;   & divide again	RR	E	LD	(HL),E		; Stuff the value	INC	HL	LD	(HL),D	RET;;	Read the hash index table;HITRD1	LD	HL,DIRBUF$	; Point to buffer	PUSH	BC	PUSH	DE	CALL	@DIRCYL		; Get dir cyl in reg D	LD	E,01H		; Sector 1	CALL	@RDSSC	POP	DE	POP	BC	LD	A,22		; HIT read error	RET;;	Routine to locate the address of a module;;	DE -> Pointer to module name;	HL <- Address of module start if found;	DE <- Address of end-of-module-name +1 if found;	 Z <- if found, else NZ and A=8;GTMOD	PUSH	BC		; Save this reg pair	LD	C,0FFH		; Init length counter	PUSH	DE		; Save name startGTM1	INC	C		; Bump counter	LD	A,(DE)		; Search for end-of-name	INC	DE	CP	' '+1	JR	NC,GTM1	POP	DE;;	Start search at system core;	LD	HL,@$SYS	; Pointer to driver start;;	Loop through core searching names;GTM2	LD	A,H		; Are we currently in	CP	@BYTEIO<-8+1	;   the driver zone?	JR	NC,GTM2A	; No - check himem;;	In the driver zone - is it allocated?;	PUSH	BC		; Save BC	LD	BC,(DVRHI$)	; Get next available	OR	A		;   addr in Driver Zone	PUSH	HL		; Is this module	SBC	HL,BC		;   accounted for in	POP	HL		;   the driver zone?	POP	BC		;	JR	NC,GTM8		; No - get out of D/Z;;	Does this module have a legal header?;GTM2A	LD	A,(HL)		; Check for JR xx	CP	18H	JR	NZ,GTM7		; Exit on non-JR	PUSH	HL		; Save pointer to start	INC	HL		; Advance to length/name	INC	HL	INC	HL	INC	HL	LD	A,(HL)		; Get length field	AND	0FH		; Strip flags	CP	C		; Lengths match?	JR	NZ,GTM5	INC	HL		; Point to start of name	LD	B,A		; Set loop counter	PUSH	DE		; Save users name pointerGTM3	LD	A,(DE)		; Compare strings	CP	(HL)	JR	NZ,GTM4		; Go if no match	INC	HL	INC	DE	DJNZ	GTM3	EX	DE,HL		; Name+1 to DE;;	Found a match - exit with info;	POP	HL		; Keep DE to name end + 1	POP	HL		; Module start address	POP	BC		; Reg restoral	XOR	A		; Set Z flag for return	RET;;	No match - loop to next module;GTM4	POP	DEGTM5	POP	HL	INC	HL		; Point to last byte used	INC	HL	LD	A,(HL)		; Get low order byte	INC	HL	LD	H,(HL)		; Get high order byte	LD	L,AGTM5A	INC	HL		; Bump to next address	LD	A,H		; Check for wrap to zero	OR	L	JR	NZ,GTM2		; Loop if not throughGTM6	POP	BC		; Restore reg	LD	A,8		; "device not avail" error	OR	A	RET;;	Found non-JR - advance to high memory;GTM7	LD	A,H		; Past driver core?	CP	@BYTEIO<-8	JR	NC,GTM6		; Exit with "not found"GTM8	LD	HL,(HIGH$)	;   else get himem pointer	JR	GTM5A		;   & hop to it if in use;;	Check a drive for availability;CKDRV	PUSH	IY		; We use IY in disk I/O	CALL	@GTDCT		; Get driver routine addr	LD	A,(IY+00H)	; Get drive vector	CP	0C3H		; Check for enabled	LD	A,20H		; Error code?	JP	NZ,CKDR5	; Bypass if disabled	PUSH	HL	PUSH	DE	LD	A,(IY+06H)	; Make sure current cyl count	CP	(IY+05H)	;   is in range	JP	NC,CKDRV1	; Go if in range	CALL	@RSTOR		; Restore drive	JP	NZ,CKDR7A	; Go if error;CKDRV1	LD	D,(IY+05H)	; Get current track	LD	E,00H		; Set for sector 0	CALL	@SEEK		; Set track info to FDC	JR	NZ,CKDR7A	; Go if error	CALL	@RSLCT		; Wait until not busy	JR	NZ,CKDR7A	; Not there - ret NZ	BIT	3,(IY+03H)	; If hard drive bypass	JR	NZ,CKDR3A	;  GAT data update	BIT	4,(IY+04H)	; If "alien" bypass 	JR	NZ,CKDR2B	;   test of index pulses	IF	@MOD4	LD	A,(FDDINT$)	; Check 'SMOOTH' state	OR	A	LD	A,09H		; Set MSB of count down	JR	Z,INTRON	; Go if not SMOOTH	SRL	A		; Divide the count by 2	DI	ENDIF	IF	@MOD2	LD	A,20	ENDIFINTRON	LD	(CDCNT+1),A	; Store in LD H instruction	LD	HL,0020H	; Set up count (short);;	Test for diskette in drive and rotating;CKDR1	CALL	INDEX		; Test index pulse	JR	NZ,CKDR1	; Jump on index	BIT	7,(IY+04H)	; Check CKDRV inhibit bit	JR	NZ,CKDR2B	;   if on skip index testCDCNT	LD	H,00H		; CKDRV counter (long)				; Count set from aboveCKDR2	CALL	INDEX		; Test index pulse	JR	Z,CKDR2		; Jump on no index	IF	@MOD4	EI			; Okay for INTS now	ENDIF	LD	HL,20H		; Index off wait (short)CKDR2A	CALL	INDEX	JR	NZ,CKDR2A	; Jump on index;;	Diskette is rotating;CKDR2B	PUSH	AF		; Save FDC status	CALL	@DIRCYL		; Get dir track in D	LD	HL,SBUFF$	; Point to HIT buffer	LD	E,L		; Sector 0 for GAT	CALL	@RDSSC		; Read the GAT	JR	NZ,CKDR7	; Jump on error	LD	HL,(SBUFF$+0CCH)	; Get excess tracks	LD	A,22H		; Add offset	ADD	A,L	LD	(IY+06H),A	; Max track # to DCT	RES	5,(IY+04H)	; Set side to 0	BIT	5,H		; Test double sided	JR	Z,CKDR3		; Jump if only single	SET	5,(IY+04H)	; Set for side 2CKDR3	POP	AF		; Recover FDC statusCKDR3A	RLCA			; Shift WProt to 7	OR	(IY+03H)	; Merge soft WP bit	AND	80H		; Strip all but 7	ADD	A,A		; Write prot to carry flag;CKDR4	EQU	$	EI	POP	DE	POP	HLCKDR5	POP	IY	RET;INDEX	LD	A,H		; Check countdown timer	OR	L	JR	Z,CKDR7		; Err exit if 0	DEC	HL	CALL	@RSLCT		; Check for index pulse	BIT	1,A		; Test index	RET;CKDR7	POP	AFCKDR7A	LD	A,08H		; Set device not avail	OR	A		; Set NZ ret	JR	CKDR4		; Exit;LILBUF	DS	18LAST	EQU	LILBUF	IFGT	$,DIRBUF$	ERR	'Module too big'	ENDIF	ORG	MAXCOR$-2	DW	LAST-SYS12;	END	SYS12