;LBDIRC/ASM - DIR math, strings and buffers	SUBTTL	'<LBDIRC - Math routines>'	PAGE;;	CALCK - Calculate the # of K given # of grans;	DE => # of granules;	HL => Destination of kb ASCII string;CALCK	LD	(CALCK2+1),HL	; Store dest address;;	Calc # free sectors (Sectors/gran * grans);	EX	DE,HL		; HL = # free gransCALCK1	LD	C,00H		; C = sectors / gran	@@MUL16			; Multiply HL * C;;	LA = total # of sectors - divide by 4 for K;	PUSH	AF		; Save offset	LD	H,L		; Set HL = LA	LD	L,A	SRL	H		; Divide HL by 4	RR	L	SRL	H	RR	L;;	Get dest address and put in # of *FULL* K;CALCK2	LD	DE,$-$		; Get destination addr	@@HEXDEC		; Convert to ASCII	INC	DE		; DE => hundredths;;	Stuff hundredths value into string;	POP	AF		; Recover offset to	AND	03H		; Get offset	ADD	A,A	LD	B,00H	LD	C,A		; BC = offset	LD	HL,HUNDTAB	; HL => Hundredths table	ADD	HL,BC		; HL => Hundredths offset	LD	C,02H		; 2 characters	LDIR			; Move into buffer	RET;;	CPHLDE - compare HL to DE;CPHLDE	LD	A,H		; Get high byte	CP	D		; The same?	RET	NZ		; No - return C or NC	LD	A,L		; Get low byte	CP	E		; Greater or less?	RET			; Return C, NC or Z;;	UNPACK - Unpack the date from a directory entry;UNPACK	LD	A,(HL)		; Get DIR+1 byte	AND	0FH		; Bits 3-0 contain month*LIST	OFF	IFLT	@DOSLVL,'L'	;---> Before changes for 6.3.1L*LIST	ON	LD	E,00H	LD	D,A		; D contains month;;	D = month (1-12);	SRL	D	RR	E	INC	HL	LD	A,(HL)		; Get DIR+2	AND	0F8H		; Mask off the year	RRCA	OR	E	LD	E,ASVYFLG1	LD	A,($-$)		; Get YFLAG$TSTBIT1	BIT	0,A		; Test bit for drive	JR	NZ,M2A91	; Go if new date style	LD	A,(HL)		; Get day	AND	07H		; Strip off restM2A8B	RLCA	RLCA	RLCA	OR	D		; Merge in month	LD	D,A		; Save it in D	RET			;   and return;;	Unpack new style date;M2A91	LD	A,L		; Point to year	ADD	A,11H	LD	L,A	LD	A,(HL)		; Get it	AND	1FH		; Mask off rest	JR	M2A8B		; and jump back*LIST	OFF	ELSE			;<-->*LIST	ON	LD	B,A		; B contains month	INC	HL		; Point to DIR+2	LD	A,(HL)		; Get year and day	RRCA			; Bring day	RRCA			;	RRCA			;	AND	1FH		; Mask off year	LD	C,A		; C contains day	PUSH	BC		; Save month & day	CALL	GTDIRYR		; Get year in A	POP	BC		; Restore month & day	CALL	PKDAT		; Pack YMD to BC	LD	D,B		; Move to DE	LD	E,C	RET			; Done;;	Get year (Y-1980) from directory;	IN:	HL = DIR+2;	OUT:	A = Y-1980;		Cy set if Lev.H+ date style;GTDIRYR	LD	A,(HL)		; get day and year from DIR+2	AND	07H		; keep year (0-7)	LD	B,A		; to B (old date style)SVYFLG1	LD	A,($-$)		; Get YFLAG$TSTBIT1	BIT	0,A		; Test bit for drive	JP	Z,RETOLDY	; Go if old dates (return yr-80 in A);	New date scheme	LD	A,L		; Point to DIR+19 = Lev.H+ date	ADD	A,11H	LD	L,A	JP	GTEXTYR		; Unpack Lev.H date*LIST	OFF	ENDIF			;<--- 6.3.1L*LIST	ON;;	Output a carriage return;CR_OUT	LD	A,CR	CALL	BYTOUTCKPAGE	LD	A,00H		; Check for display pause	DEC	A		; Count down	LD	(CKPAGE+1),A	; Update the count	RET	NZ		; Return if not full page;;	Displayed a full page - reset counter;	LD	A,22		; Reset to max lines/page	LD	(CKPAGE+1),A;;	Don't pause if NOPAUSE (N) param entered;NPAGE	LD	DE,$-$		; Get NOPAUSE parameter	LD	A,E		; Specified?	OR	D	RET	NZ		; Return if so;;	Non-stop if DO in effect;SFLAG	LD	A,00H		; Get SFLAG$	AND	20H		; Strip all but DO bit	RET	NZ		; Return if DO in effect;;	DO not in effect - wait for a key;	@@KEYM2AB9	JP	NZ,IOERR;;	Clear the screen;	LD	A,105		; @CLS	NOP			; Replace with RST 28H	JR	NZ,M2AB9;;	If the NOTITLE flag is set, don't display;NOTITLE	LD	A,00H		; Get flag	OR	A		; No title?	RET	NZ		; then return;;	Display a title if there were matching files;	LD	A,(FILFLAG)	; Was  a matching file	OR	A		;   displayed?	CALL	NZ,CKTITL	; Yes - display title	RET			; Return;;	CKPAWS - Check for SHIFT-@ or BREAK;CKPAWS	LD	A,($-$)		; Get KFLAG$	RRCA			; BREAK hit?	JP	C,ABORT		; Yes - cease and desist;;	Is the pause bit set?;	RRCA			; Check pause bit	RET	NC		; Return if not set;;	The pause bit is set - wait for a character;CKPAW1	@@KEY			; Scan the keyboard;;	Character entered - ignore it if SHIFT-@;	CP	60H		; SHIFT-@?	JR	Z,CKPAW1	; Loop back if so	CP	80H		; Break?	JP	Z,ABORT		; Abort if so;;	Reset PAUSE and ENTER bits;RESKFL	LD	A,($-$)		; Get KFLAG$	AND	0F9H		; Reset PAUSE and ENTERKFLAG1	LD	($-$),A		; And put it back	RET			; and return to caller;;	Display disk type header;CKTITL	LD	HL,DSTRING	; HL => Heading	CALL	LINOUT		; Output line	CALL	CKPAGE		; Bump line counter	CALL	CKPAGE		;   twice;;	Display attributes header if A param specified;	LD	A,(APARM+1)	; Get param flag	OR	A		; Specified?	LD	A,CR		; Output a CR if A	JP	Z,BYTOUT	;   wasn't specified.;	LD	HL,HEADING	; Point to attr heading	CALL	LINOUT		; Display it;;	Display the underline;	PUSH	BC		; Save BC	LD	B,79		; do 79 charactersD79L	LD	A,'-'	CALL	BYTOUT	DJNZ	D79L		; Do a whole line	POP	BC		; Get BC back	JP	CR_OUT		; Send C/R and return;	SUBTTL	'<LBDIRC - Sort Code>';;	SORTIT - Set up directory records for shell sort;SORTIT	LD	HL,(DIRPTR)	; Calculate # of records	LD	DE,MEMORY	; Point to buffer start	LD	(HL),E		; Prime the 1st index	INC	HL		;   in case there is	LD	(HL),D		;   only one record	DEC	HL		;   to sort	XOR	A	SBC	HL,DE		; PTREND - PRTBGN	RET	Z		; Return if nothing;;	Set HL = number of directory entries;	LD	B,5		; Divide bySORT1	SRL	H		;   32 bytes per record	RR	L	DJNZ	SORT1;;	Set B to # of entries and init count;	LD	B,L		; Set loop counter	PUSH	BC		; Save it for printing	LD	(COUNTM1),HL	; Init the count;;	Skip sort if number of entries = 0;	LD	A,H		; If length = 0	OR	L		;   then no need to sort	JR	Z,SORT2A	ADD	HL,HL		; Make sure enough room	EX	DE,HL	LD	HL,(MAXMEM)	XOR	A	SBC	HL,DE	JP	C,NOMEM	LD	HL,(DIRPTR)	; Set up the index array	LD	DE,MEMORY	; Starting record pointerSORT2	LD	(HL),E		; Place record pointers	INC	HL		;   into index array	LD	(HL),D	INC	HL	LD	A,E		; Increment pointer by 32	ADD	A,' '	LD	E,A	JR	NC,M2B4F	; Go if no overflow	INC	D		;   else bump high orderM2B4F	DJNZ	SORT2		; Loop for all records	CALL	SHELL		; Sort the recordsSORT2A	POP	BC		; Recover loop counter	LD	HL,(DIRPTR)	; Get starting recordSORT3	LD	E,(HL)		; Grab its address	INC	HL	LD	D,(HL)	INC	HL	PUSH	HL		; Save index pointer	PUSH	BC		; Save loop counter	EX	DE,HL		; Record address to HL	CALL	MATCH		; Display the record	POP	BC	POP	HL	DJNZ	SORT3	RET;;	SHELL - Shell sort routine;SHELL	LD	HL,$-$		; Pick up count minus 1COUNTM1	EQU	$-2	LD	(STORM),HL;;	Select and compare routine;CYCLE	LD	DE,0		; M = M / 2STORM	EQU	$-2	SRL	D	RR	E	LD	A,D		; Return when M = 0	OR	E	RET	Z	LD	(STORM),DE	LD	HL,(COUNTM1)	; K = N - M	SBC	HL,DE	LD	(STORK),HL	LD	HL,0		; J = 0	LD	(STORJ),HLAGAIN	LD	HL,0		; I = JSTORJ	EQU	$-2	LD	(STORI),HLREPEAT	LD	HL,$-$		; L = I + MSTORI	EQU	$-2	LD	DE,(STORM)	ADD	HL,DE	ADD	HL,HL		; L * 2 to regHL	PUSH	HL		; Save L	LD	HL,(STORI)	; I * 2 to regHL	ADD	HL,HL	LD	BC,(DIRPTR)	; Get string parm ptr	ADD	HL,BC		; Pt to A$(I) parm	EX	DE,HL		; Ptr to DE	POP	HL		; Pt to A$(L) parm	ADD	HL,BC		; Ptr to HL	PUSH	HL		; Save ptr to A$(L)	PUSH	DE		; Save ptr to A$(I)	LD	B,11		; Set compare length	PUSH	BC		; Save cmp len & flag	LD	A,(HL)		; Get string 2 ptr	INC	HL	LD	H,(HL)	LD	L,A	LD	BC,5		; Key is 5 bytes in	ADD	HL,BC	EX	DE,HL		; String 2 ptr to DE	LD	A,(HL)	INC	HL	LD	H,(HL)	LD	L,A	ADD	HL,BC		; Key is 5 bytes in	POP	BC		; Get len and flagBACK	LD	A,(DE)		; Go swap if str1>str2	SUB	(HL)	JR	C,POP	JR	NZ,FINIS	; Next str if str2>str1	INC	DE		; Loop if this matches	INC	HL	DJNZ	BACK	JR	FINIS		; None really should matchPOP	POP	DE		; Else swap	POP	HL	LD	B,02H		; Swap 2 byteSWAP	LD	C,(HL)		; string pointer	EX	DE,HL	LD	A,(HL)	LD	(HL),C	EX	DE,HL	LD	(HL),A	INC	HL	INC	DE	DJNZ	SWAP	LD	HL,(STORM)	; Get M	EX	DE,HL	LD	HL,(STORI)	; Get I	XOR	A	SBC	HL,DE	LD	(STORI),HL	; I = I - M	JR	NC,REPEAT	; Repeat if I => 0	JR	EXITSRTFINIS	POP	DE	POP	HLEXITSRT	LD	HL,(STORJ)	INC	HL		; J = J + 1	LD	(STORJ),HL	XOR	A	LD	DE,0STORK	EQU	$-2	SBC	HL,DE		; J - K	JP	NC,CYCLE	; Cycle if J => K *	JP	AGAIN		; else again;;	SUBTTL	'<LBDIRC - Data>';PRMTBL$	DB	80H		; 6.x parameters;	DB	FLAG!1,'A',0	DW	APARM+1;	DB	FLAG!ABB!3,'INV',0	DW	IPARM+1;	DB	FLAG!1,'P',0	DW	PPARM+1;	DB	FLAG!ABB!3,'SYS',0	DW	SPARM+1;	DB	FLAG!1,'N',0	DW	NPAGE+1;	DB	FLAG!STR!ABB!4,'DATE'DRESP	DB	0	DW	DATPRM+1;	DB	FLAG!ABB!3,'MOD',0	DW	CKMOD+1;	DB	FLAG!4,'SORT',0	DW	SORTPRM+1;	DB	FLAG!1,'O',0	DW	SORTPRM+1;	DB	00H;;	Strings;DEN	DB	'xDEN'HARD	DB	'Hard'DSTRING	DB	'Drive :'DRIVE	DB	'd  'NAME	DB	'diskname'CYLCNT	DB	'      Cyl, 'DENSITY	DB	'nDEN, Free ='KFREE	DB	'     .  K / 'KPOSS	DB	'     .  K,  Date 'DATBUF	DB	'dd-'M2C85	DB	'mmm-'M2C89	DB	'yy',CRHEADING	DB	'Filespec    MOD Attr   Prot  LRL  #Recs  EOF  File Size  Ext  Mod Date   Time',CRFDISP	DB	'    files of 'FUSED	DB	'    selected, 'SPUSED	DB	'     .  K',LF,CRNODISK	DB	'Drive :'NDRIVE	DB	'n  [No  Disk]',LF,CRTDATE	DB	'mm/dd/yy"'PROTS$	DB	'FULL'	DB	'REMV'	DB	'NAME'	DB	'WRIT'	DB	'UPDT'	DB	'READ'	DB	'EXEC'	DB	'NO  '*LIST	OFF	IFLT	@DOSLVL,'L'	;---> Before changes for 6.3.1L*LIST	ONMAXDAYS	DB	1FH	DB	1CH,1FH,1EH,1FH,1EH,1FH	DB	1FH,1EH,1FH,1EH,1FH*LIST	OFF	ELSE			;<-->*LIST	ON;;	New routine to unpack Lev.H+ year from dir entry;	IN:	HL = DIR+19, Lev.H+ date;		B  = old year (can contain (Y-1980)/32 ;			XORed with (HL)'s bits 0-2);GTEXTYR	LD	A,(HL)		; Get byte	AND	1FH		; keep bits 0-4 (Lev.H Y-1980)	LD	C,A		; Save to C	LD	A,B		; XOR with B	XOR	C		;	AND	07H		; Check bits 0-2	JR	Z,L2D50		; Skip if 0 (old year == Lev.H year);	New dates: add 8 * high bits	RRCA			; Mult by 32	RRCA			;	RRCA			;	OR	C		; Combine with low bits (Y-1980)%32	CP	100		; less than 100 ?	RET	C		; return Lev.L year if yes with CY set;	Old datesL2D50	LD	A,C		; Else return Lev.H year	SCF			; with CY set to indicate Lev.H+ date	RET			; Done;	Portion of code to return B in A with Z set if zero and CY resetRETOLDY	LD	A,B		; For old dates ...	OR	A		; Cy reset for old date style	RET			; Done	NOP			; Filler	NOP	NOP	NOP	NOP*LIST	OFF	ENDIF			;<--- 6.3.1L*LIST	ONHUNDTAB	DB	'00255075'NOMEM$	DB	'No memory for SORT',CR*LIST	OFF	IFLT	@DOSLVL,'L'	;---> Before changes for 6.3.1L*LIST	ONBADFMT$	DB	'Bad date format',CR*LIST	OFF	ENDIF			;<--- 6.3.1L*LIST	ON;;	6.3.1 added code	<----------;M2D76	DEC	HL		; Dec value	@@FLAGS			; Get system flags	LD	A,(HL)		; Get char at HL	RET			; And return;M2D7C	BIT	4,(IY+08H)	; Test AM/PM indicator	POP	IY		; display a/p if zero	JP	M294F		; Jump back;;	end of 6.3.1 added code	<----------*LIST	OFF	IFLT	@DOSLVL,'L'	;---> Before changes for 6.3.1L*LIST	ON	DB	'JunJulAugSepOctNov'	DB	'Dec'*LIST	OFF	ELSE			;<-->*LIST	ON;;	New routine to pack date;	IN:	A=Year, B=Month, C=Day;	OUT:	BC=(A*16+B)*32+C;PKDAT	PUSH	HL	LD	L,A		;L=A=year	ADD	HL,HL	ADD	HL,HL	ADD	HL,HL	ADD	HL,HL		;times 16	LD	A,B		;B=month	OR	L	LD	L,A		;HL=16*A+B	ADD	HL,HL	ADD	HL,HL	ADD	HL,HL	ADD	HL,HL	ADD	HL,HL		;times 32	LD	A,C		;c=day	OR	L	LD	C,A		;BC=(A*16+B)*32+C	LD	B,H	POP	HL	RET	DB	'c'		;garbage*LIST	OFF	ENDIF			;<--- 6.3.1L*LIST	ONFTFLG	DB	00HFILFLAG	DB	00HDIRPTR	EQU	$		;M2D9CMAXMEM	EQU	DIRPTR+2	;M2D9EFMPAKD	EQU	MAXMEM+2	;M2DA0TOPAKD	EQU	FMPAKD+2	;M2DA2LILBUF$	EQU	TOPAKD+2	;M2DA4;;	BLANKS is where the DIR display line is created;BLANKS	EQU	LILBUF$+3	;M2DA7;PLEVEL	EQU	BLANKS+13	;M2DB4LRL	EQU	BLANKS+18	;M2DB9RECORDS	EQU	BLANKS+24	;M2DBFOFFSET	EQU	BLANKS+29	;M2DC4KSIZE	EQU	BLANKS+36	;M2DCBEXTENTS	EQU	BLANKS+48	;M2DD7DATEFLD	EQU	BLANKS+52	;M2DDB;;;GAT	EQU	LILBUF$+3<-8+1<+8HIT	EQU	GATBUF2	EQU	GAT+256MEMORY	EQU	GAT+512;	SUBTTL	'<LBDIRC - Initialization code>'	PAGE;;	DIR Entry point - Initialization code;DIR	@@CKBRKC		; Check for break	JR	Z,DIRA		; Go if no	LD	HL,-1		;   else abort	RET;DIRA	LD	(SAVESP+1),SP	; Save SP address	PUSH	HL;;	Pick up flag table base address;	@@FLAGS	PUSH	IY		; Move Flags table	POP	DE		;   into DE;;	Calculate YFLAG$ address and save it;	LD	HL,YFLAG$	; Point to YFLAG$	ADD	HL,DE	LD	(SVYFLG1+1),HL	; Save YFLAG$	LD	(SVYFLG2+1),HL	;   in both places;;	Calculate KFLAG$ address and save it;	LD	HL,KFLAG$	; Point to KFLAG$	ADD	HL,DE	LD	(CKPAWS+1),HL	; and save that	LD	(RESKFL+1),HL	;   in a couple	LD	(KFLAG1+1),HL	;   of places;	CALL	RESKFL		; Reset bits 0-2 of KFLAG$	POP	HL		; Recover cmd line ptr;;	Pick up SFLAG;	LD	A,(IY+'S'-'A')	; Get SFLAG$	LD	(SFLAG+1),A	; Save for later testing;;	Find parameter entry if existant;	PUSH	HL		; Save command ptrFPLP	LD	A,(HL)		; Get character	CP	'('		; Parameters?	JR	Z,GETPRM	; Yes - go get 'em	CP	0DH		; End of line?	JR	Z,RESTPTR	; Yes - restore ptr	INC	HL		; No - bump 'til end	JR	FPLP		; To until EOL or (;;	Process any parameters entered;GETPRM	LD	DE,PRMTBL$	; Point to parameter table	@@PARAM			; Parse themRESTPTR	POP	HL		; Recover pointer	JP	NZ,IOERR	; NZ - Parameter error;;;	PUSH	HL		; Save pointer	LD	HL,BLANKS	; Point to blank line	LD	(HL),' '	; Fill with a space	LD	D,H		; Move pointer to DE	LD	E,L	INC	DE		; Adjust to next pos	LD	BC,0044H	; 69 bytes to fill	LDIR	LD	A,03H		; Stuff an ETX at the end	LD	(DE),A	LD	A,'.'	LD	(BLANKS+41),A	LD	A,'K'	LD	(BLANKS+44),A	POP	HL;;	If first char is a "8" or "9", abort;	LD	A,(HL)		; Check character	CP	0DH		; if CR, then global	JR	Z,DIR2	CP	'8'		; Check illegal drive	JR	Z,ILLDRV	; Yes - abort	CP	'9'	JR	NZ,CKITOUT	; Not 8 or 9;;	Illegal drive number;ILLDRV	JP	ERR32;;	Pick up drive # and range field if any;CKITOUT	PUSH	HL		; Save source ptr	CALL	CKDSPEC		; Legal drive range?	POP	DE		; Save source ptr in DE	JR	Z,DIR3		; Legal - use HL;;	Point DE => partspec match field.  B=8 chars;	EX	DE,HL		; Illegal, use DE	LD	A,(HL)		; Get 1st char	INC	HL		;   and bump to nextDIR0	LD	DE,BLANKS	; DE => partspec area	LD	B,08H		; B = 8 chars/filename;;	Was the NOT switch entered?;	CP	'-'		; NOT?	JR	NZ,DIR1		; No - continue;;	NOT "-" entered - set flag and bump cmd pointer;	LD	(MFLG+1),A	; Stuff "-' in flag	LD	A,(HL)		; Get next char	INC	HL		;   and increment;;	Transfer name to filespec buffer;DIR1	CALL	CVTSTAR		; Parse 8 chars	CP	'/'		; Extension?	JR	Z,DIR1A		; Yes - go check	CP	'.'		; Password?	JR	NZ,DIR2		; No - don't check;;	Transfer extension to Filespec buffer;DIR1A	LD	DE,BLANKS+8	; DE => extension field	LD	B,03H		; Max 3 chars	LD	A,(HL)		; Get next char	INC	HL		; Bump pointer	CALL	CVTSTAR		; Transfer extension;;	Was a drivespec entered?;DIR2	CP	':'		; Drive entered?	LD	BC,7		; St=0, term=7	JR	Z,DIR2A		; Go if entered	CP	')'		; End of params?	JR	C,DIR3	LD	A,13H		; Init error code	JP	IOERR		;    and go;;	Check if char following is a legal drive #;DIR2A	CALL	CKDSPEC		; Legal drive field?	JR	NZ,ILLDRV	; No - abort	CP	08H		; Trap "DIR :8"	JR	Z,ILLDRV;;	B=Start drive #, C=Term drive # - Save them;DIR3	LD	A,B		; Save starting drive	LD	(DIR3A+1),A	SUB	C		; Set specified drive flag	LD	(SPECIF+1),A	LD	A,C		; Save term drive	LD	(TERMDRV+1),A;;	Command line parsed - check available mem;	BIT	1,(IY+CFLAG$)	; Called from CMNDR?	LD	HL,0		; Set sotr (O) param = 0	JR	Z,GETHI		; No - fine;;	Executing from @CMNDR - turn off SORT;	LD	(SORTPRM+1),HL;;	Pick up current HIGH$ and set max mem to use;GETHI	LD	B,L		; B = 0	@@HIGH$			; Get HIGH$	LD	DE,-33		; Subtract 33 from it	ADD	HL,DE	LD	(MAXMEM),HL	; Set max mem to use;;	Turn on N param if P param used;	LD	HL,(PPARM+1)	; Get P param	LD	A,H		; Specified?	OR	L	JR	Z,GTDATE	; No - skip	LD	(NPAGE+1),HL	; Turn on N param;;	Was  the DATE parameter specified?;GTDATE	LD	A,(DRESP)	; Check out response	OR	A		; Any response?	JR	Z,DIR3A		; None entered - no date;;	Something was specified - check type;DATPRM	LD	HL,$-$		; Pick up date	BIT	6,A		; Flag input?	JR	Z,CHKSTR	; No - must be string;;	Flag input - if YES then use today's date;	LD	A,H		; DATE=OFF?	OR	L	JR	Z,DIR3A		; Yes - ignore it;;	DATE parameter entered - get today's date;	LD	HL,TDATE	; HL => Today's date	PUSH	HL		; Save position	@@DATE			; Get today's date	POP	HL		; Restore HL;;	Display dates before "-mm/dd/yy"?;CHKSTR	LD	A,(HL)		; Get first char	CP	'-'		; "to-"?	JR	Z,CKTO		; Yes - do it;;	Not before - set flag accordingly;	LD	A,80H		; Set FROM bit	LD	(FTFLG),A	; Note FROM entered;	CALL	PAKDAT		; Pack the date	LD	(FMPAKD),BC	; Store FROM date;;	End of first date?;	LD	A,(HL)		; Get terminator	CP	'"'		; End of date?	JR	Z,FRCTO		; Yes - use spec'd date;;	Is there a "-" symbol after the date?;	CP	'-'		; Check for "-to"	JR	NZ,DIR3A	; No - check if legal;;	Is there a date following?;CKTO	INC	HL		; Bump past "-"	LD	A,(HL)		; Get next char	CP	'"'		; End of param?	JR	Z,DIR3A		; Yes - use that date;	CP	0DH		; End of param?	JR	Z,DIR3A		; Yes again;;	Something following - parse date;	CALL	PAKDAT		; Pack the date;;	Stuff in "TO" packed date and set TO flag;FRCTO	LD	A,(FTFLG)	; Get FROM/TO flag	OR	01H		; Set TO bit	LD	(FTFLG),A	; Save it back	LD	(TOPAKD),BC	; Save packed date;;	Pick up starting drive and init page counter;DIR3A	LD	C,$-$		; Get starting drive	LD	A,22		; Max lines to display	LD	(CKPAGE+1),A	; Stuff in counter	JP	DIR4		; Directory start;;	CKDSPEC - Check if a drive spec field is legal;;	HL => Drive specification field;	Z - Set if drive spec field is legal;	B <= Startind drive # (0-7);	Z <= Terminating drive (0-7);CKDSPEC	LD	A,(HL)		; Get first char	CP	'-'		; To or NOT?	JR	NZ,NOTDASH	; No - check if drive #;;	Char is a "-" ---- Could be "TO" or "NOT";	CALL	LEGDRV		; Legal drive number?	RET	C		; No - return NZ;;	Legal drive # - Next char must be a terminator;	LD	C,A		; C = terminating drive	INC	HL		; Point to next char	CALL	TERM		; Does a term follow?	LD	B,00H		; Default start is 0	RET			; Return Z or NZ;;	Is the first character a legal drive #?;NOTDASH	CALL	LEGDRV1		; Legal drive (0-7)?	RET	C		; No - return NZ	LD	B,A		; Set B = starting drive	LD	C,A		; Set C = terminator;;	Legal drive - a "-" or term MUST follow;	INC	HL		; Bump to next char	LD	A,(HL)		; If next char is not a	CP	'-'		;   "-", return Z or NZ	JR	Z,CKTDRIV	;   depending on next char	CALL	TERM		; Legal terminator?	JP	NZ,ILLDRV	; No - illegal drive #	RET			; Yes - return;;	Is the character a terminator?;TERM	LD	A,(HL)		; Get char	CP	' '		; Space is legal	RET	Z		; Return Z if space	CP	0DH		; CR is legal	RET	Z	CP	'('		; Paren is legal	RET			; Return with condition;;	Next char must be a valid drive # or terminator;CKTDRIV	CALL	LEGDRV		; Legal drive #?	LD	C,07H		; C = default term drive 7	JR	C,TERM		; Not drive #, chk for term;;	Make sure Term drive # > or = start drive;	LD	C,A		; Set C = Term drive #	CP	B		; > or = start drive?	RET	C		; Less - return;;	Drive span range good - make sure term legal;	INC	HL		; Bump pointer	JR	TERM		; RETurn Z or NZ;;	LEGDRV - Is a character a legal drive #?;;	HL => One before character to check;	HL <= Character in question;	A  <= Drive number (0-7);	CF <= Set if character not a legal drive;LEGDRV	INC	HL		; Bump to nextLEGDRV1	LD	A,(HL)		; Get character	SUB	'0'		; Convert to binary	CP	7+1		; Grater than 7?	CCF			; C - Illegal	RET			; Return with condition;;	Convert * into ???;CVTSTAR	CP	'*'		; Asterisk?	JR	NZ,PRSPC	LD	A,'$'		; Init to '?'sCVTSTA1	LD	(DE),A		; Stuff char	INC	DE		; Bump pointer	DJNZ	CVTSTA1		; Loop for (B) chars	LD	A,(HL)		; Get input char	INC	HL		; Bump input pointer	RET			;   and return;;	PRSPC - Parse a line and stuff into buffer;;	HL => Source buffer;	DE => Destination of converted field;	B  =  # of chars to parse;PRSPC	CP	'$'		; Wild character?	JR	Z,PS2		; Yes - stuff in buf	CP	'A'		; Alphabetic?	JR	NC,PS1		; Maybe, convert to UC;;	Is the character a numeric value?;	CP	'9'+1		; Greater than "9"?	RET	NC		; Yes - return	CP	'0'		; Less than "0"?	RET	C		; Yes - return;;	Convert character to upper case;PS1	CP	'a'		; Lower case alpha?	JR	C,PS2		; No - stuff in buffer	CP	'z'+1	JR	NC,PS2	RES	5,A		; Convert to U/C;;	Put char in buffer, & bump cmd and buffer ptrs;PS2	LD	(DE),A		; Stuff in bufferPS3	INC	DE		; bump	LD	A,(HL)		; Get command buf char	INC	HL		; Bump	DJNZ	CVTSTAR		; Do it B times	RET;;	PAKDAT - Pack date and stuff into buffer;;	HL => Buffer containing the date string;	BC <= Packed date in LSB,MSB format;PAKDAT	LD	A,(HL)		; Get character	LD	C,'/'		; Init separator;;	Is the date a valid entry?;	CALL	PARSDAT		; Parse entry*LIST	OFF	IFLT	@DOSLVL,'L'	;---> Before changes for 6.3.1L*LIST	ON	JP	NZ,BADFMT	; Abort on format error;;	If year is leap year, set Feb to 29 days;	LD	A,(DE)		; Get year	CP	0CH		; Less than 12?	JR	NC,M2F5D	; Go if it's not	ADD	A,100		; Add 100 to it	LD	(DE),A		; Save it backM2F5D	EX	DE,HL		; Save cmd ptr	AND	03H		; Mask off bits 0-2	LD	HL,MAXDAYS+1	; Set Feb to have 29 days	JR	NZ,NOTLEAP	; No, don't inc it	INC	(HL)		; Leap year - bump max days;;	Check range of month - must be 1-12;NOTLEAP	LD	A,(LILBUF$+2)	; Pick up month	DEC	A		; Set month = 1-11	CP	12		; Valid month?	JP	NC,BADFMT	; Abort if 0 or > 12;;	Valid month, point HL to max days/month;	DEC	HL		; Point to JAN entry	ADD	A,L		; Add the month	LD	L,A		; HL => max days for month	JR	NC,NOINC	; Bump H if C set	INC	H;;	Check if day entry is valid;NOINC	LD	A,(LILBUF$+1)	; Get day entry	DEC	A		; Reduce for test (0->FF)	CP	(HL)		; More than max days?	JP	NC,BADFMT	; Go if too large (or 0);;	Pick up month from buffer;	LD	HL,LILBUF$+2	; HL => month	LD	B,(HL)		; Store it in B	LD	C,00H		; Set C = 0	SRL	B		; Shift bit 0 to	RR	C		; Bit 7 of C*LIST	OFF	ELSE			;<-->*LIST	ON;;	Handle new dating;	(no strong check on day-of-month);L2F51	EQU	$-1		; Garbage	JP	NZ,BADFMT	; Abort on format error	INC	DE		; Point to day	LD	A,(DE)		; Get day	DEC	A	CP	31		; Less than 31?	JR	NC,L2F63	; Error if no	LD	C,A		; C=Day-1	INC	C		; C=Day	INC	DE		; Point to month	LD	A,(DE)		; Get month	DEC	A		; Month-1	CP	12		; Less than 12?L2F63	JP	NC,BADFMT	; Error if no	LD	B,A		; B=Month-1	INC	B		; B=Month	DEC	DE		;	DEC	DE		; Point to year	LD	A,(DE)		; Get year	SUB	80		; -80	JR	NC,L2F71	; Jump if >= 80	ADD	A,64H		; Else add 100L2F71	JP	PKDAT		; Jump to new Pack date routineBADFMT$	DB	'Bad date format',0DH	JR	C,L2F51		;garbage	ADD	HL,DE		;*LIST	OFF	ENDIF			;<--- 6.3.1L*LIST	ON	DEC	HL		; Dec buffer	LD	A,(HL)		; Get value;;		;	DEC	HL		; HL => year	RLCA	RLCA	OR	C	LD	C,A;;;	LD	A,(HL)		; Get value	SUB	80		; Convert	CP	112		; More than 2012?	JR	C,GDATE		; Go if < 112	XOR	A		; Clear year;;	Shift year into positions 7-5;GDATE	RLCA	RLCA	RLCA;;	Merge with month and return;	OR	B		; Merge month	LD	B,A		; Stuff in B	EX	DE,HL		; HL => Buffer	RET			;   and go back;;	PARSDAT - Parse TIME/DATE string entry;	HL => Buffer containing string to parse;	C  => Delimiter ("/" = DATE, ":" = TIME);	LILBUF$-LILBUF$+2 <= Data in compressed form;	Z - Set if successful;PARSDAT	LD	DE,LILBUF$+2	; Point to buffer end	LD	B,03H		; Process 3 fields;;	Parse  a field - return NZ if bad;PRS1	PUSH	DE		; Save pointer	CALL	PRS2		; Get a digit pair	POP	DE		; Recover pointer	RET	NZ		; Return if bad pair;;	Good field - Put in buff, DEC pointer & count;	LD	(DE),A		; Put value in	DEC	B		; Dec counter	RET	Z		; Do for 3 fields	DEC	DE		; Dec pointer;;	Parsed a field - is the separator valid?;	LD	A,(HL)		; Get separator	INC	HL		; Bump pointer	CP	C		; Correct?	JR	Z,PRS1		; Yes - continue	RET			; No  - return NZ;;	PRS2 - Parse a digit pair at HL;PRS2	CALL	PRS4		; Get a digit	JR	NC,PRS3		; Illegal - clr stk & ret;;	Legal digit - multiply it by 10;	LD	E,A		; Save in E	RLCA			; A * 2	RLCA			; A * 4	ADD	A,E		; A * 5	RLCA			; A * 10	LD	E,A		; Put into E;;	Get another digit;	CALL	PRS4		; Get ones digit	JR	NC,PRS3		; Bad - return NZ;;	Legal digit - add to tens and set Z flag;	ADD	A,E		; Accumulate new digit	LD	E,A		; Store in E	CP	A		; Clear flags	RET			; Return with Z set;;	Force NZ and return;PRS3	OR	A		; Set NZ	RET			; Bye...;;	Pick up a digit and convert to binary;PRS4	LD	A,(HL)		; Get digit	INC	HL		; Bump pointer	SUB	'0'		; Convert to binary	CP	10		; Check range	RET			; C=legal, NC=illegal;	END